# 测试链接库

针对链接库的测试说白了可与分为如下两种:

1. 单元测试,用于测试接口的实现是否符合预期
2. 性能测试,一般用于测试实现代码的运行时效率,方便后续优化

C/C++作为以性能安生立命的编程语言可以说这两块都有充足的工具支撑.C/C++的单元测试框架非常多,此处我只介绍[Catch](https://github.com/catchorg/Catch2).这个库只有头文件,非常的轻量.而且完全开源,由社区维护,简单好用.

我们使用的是`catch 2.13.5`,catch 3也正在开发中,据说是完全重构,后续稳定了我再更新

本文测试的例子是前面二元向量的c++版本,其主要代码如下.

+ `binary_vector.hpp`

    ```c++
    /* $Id$ */
    #ifndef BINARY_VECTOR_HPP
    #define BINARY_VECTOR_HPP//一般是文件名的大写 头文件结尾写上一行

    namespace vector{
        class BinaryVector{
        public:
            float x;
            float y;
            
            BinaryVector(float x,float y): x(x),y(y) {};
            float mod();
            BinaryVector add(const BinaryVector&);
            float mul(const BinaryVector&);
        };
    }

    #endif
    ```

+ `binary_vector.cc`

    ```c++
    #include "binary_vector.hpp"
    #include <cmath>


    namespace vector{
        float BinaryVector::mod(){
            auto result = std::sqrt(std::pow(this->x,2)+std::pow(this->y,2));
            return result;
        }
        BinaryVector BinaryVector::add(const BinaryVector& that){
            auto x = this->x + that.x;
            auto y = this->y + that.y;
            BinaryVector b(x,y);
            return b;
        }
        float BinaryVector::mul(const BinaryVector& that){
            float result = this->x * that.x + this->y * that.y;
            return result;
        }
    }
    ```

+ `CmakeLists.txt`

    ```cmake
    #项目编译环境
    cmake_minimum_required (VERSION 3.17)
    project (myvector
        VERSION 0.0.0
        DESCRIPTION "简单测试编译包"
        LANGUAGES CXX
    )

    # 设置源码位置
    file(GLOB SRC "${CMAKE_CURRENT_LIST_DIR}/src/*.cc")
    # 准备存放位置
    file(MAKE_DIRECTORY ${CMAKE_CURRENT_LIST_DIR}/dist/lib)
    # 编译为iobject对象减少重复编译
    add_library(objlib OBJECT ${SRC})
    target_include_directories(objlib
        PUBLIC ${CMAKE_CURRENT_LIST_DIR}/inc
    )
    set_target_properties(objlib PROPERTIES
        POSITION_INDEPENDENT_CODE 1
    )
    # 编译静态库
    add_library(${PROJECT_NAME} STATIC)
    add_library(${PROJECT_NAME}::${PROJECT_NAME} ALIAS ${PROJECT_NAME})
    target_sources(${PROJECT_NAME}
        PRIVATE $<TARGET_OBJECTS:objlib>
    )
    target_include_directories(${PROJECT_NAME}
        PUBLIC ${CMAKE_CURRENT_LIST_DIR}/inc
    )
    set_target_properties(${PROJECT_NAME} PROPERTIES 
        OUTPUT_NAME ${PROJECT_NAME}
        CLEAN_DIRECT_OUTPUT 1
        ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_CURRENT_LIST_DIR}/dist/lib
        PUBLIC_HEADER ${CMAKE_CURRENT_LIST_DIR}/inc/binary_vector.hpp
    )
    # 编译动态库
    option(WITHSHARE "build share lib also?" off)
    if(WITHSHARE)
        message("also build share library")
        # shared and static libraries built from the same object files
        add_library(${PROJECT_NAME}_shared SHARED)
        target_sources(${PROJECT_NAME}_shared
            PRIVATE $<TARGET_OBJECTS:objlib>
        )
        target_include_directories(${PROJECT_NAME}_shared
            PUBLIC ${CMAKE_CURRENT_LIST_DIR}/inc
        )
        set_target_properties(${PROJECT_NAME}_shared PROPERTIES 
            OUTPUT_NAME ${PROJECT_NAME}
            CLEAN_DIRECT_OUTPUT 1
            LIBRARY_OUTPUT_DIRECTORY ${CMAKE_CURRENT_LIST_DIR}/dist/lib
        )

        # 安装
        install(TARGETS ${PROJECT_NAME} ${PROJECT_NAME}_shared
            ARCHIVE
                DESTINATION ${CMAKE_INSTALL_LIBDIR}
            LIBRARY
                DESTINATION ${CMAKE_INSTALL_LIBDIR}
            PUBLIC_HEADER
                DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}
        )
    else()
        message("only build static library")
        # 安装
        install(TARGETS ${PROJECT_NAME}
            ARCHIVE
                DESTINATION ${CMAKE_INSTALL_LIBDIR}
            PUBLIC_HEADER
                DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}
        )
    endif()
    ```

下面我们来为它写测试

## 单元测试

单元测试的写法按风格来说可以大致分为`TDD-style`(测试驱动开发风格)和`BDD-style`(行为驱动开发风格),catch两种都支持,而且支持分项分组分标签(`section/case/tag`)的组织测试.基本上该有的功能都有,而且更关键的它就一个头文件.

### 使用`Catch`写单元测试

首先我们我们先来说下catch中的几个概念:

1. `断言`用于申明指定目标符合特定条件.可以认为断言是判断测试是否符号要求的最基本单元
2. `匹配器`,用于处理特定类型数据的工具帮助断言.
3. `数据生成器`,用于快速生成一组数据作为测试的目标进行测试.
4. `section`最小的测试项单位,每一个section就是一个测试项
5. `case`测试用例,多个section的组合,一般用于组织一组关联性很强的测试项,这些测试项会在同一个测试用例中被顺序执行
6. `tag`标签,标签是case的属性,一般相同标签的测试用例存在一些关联性,比如都是测同一个类型.他们是可以并行执行的.`tag`都必须符合格式`[xxxx]`.一个case可以被打上多个标签,另外一些特定tag是有特定含义的
   1. `[!hide]`/`[.]`,跳过这个case,该case不执行
   2. `[!throws]`申明该case即使成功也可能会引发异常,当执行时带上flag`-e`或`--nothrow`时,该case会被排除在外
   3. `[!mayfail]`如果case中任何给定的断言失败(但仍会报告)不会使测试失败.
   4. `[!shouldfail]`类似于[！mayfail]，但如果有该标签的case不报错则无法通过测试
   5. `[!nonportable]`表示行为在平台或编译器之间可能有所不同
   6. `[#<filename>]`使用`#`或`--filenames-as-tags`运行会导致Catch为所有包含的测试添加一个以`#`开头的文件名(并去除所有扩展名)作为标签,例如`testfile.cpp`中的测试将全部标记为`[#testfile]`
   7. `[@<alias>]`tag的别名,可以使用`CATCH_REGISTER_TAG_ALIAS( <alias string>, <tag expression> )`定义,比如我们希望用一个tag表示所有tag名为`[failing]`的且没有被跳过的case,可以这样定义`CATCH_REGISTER_TAG_ALIAS( "[@nhf]", "[failing]~[.]" )`,然后使用`[@nhf]`这个tag就可以了
   8. `[!benchmark]`声明这个case实际是性能测试,因此不计入case列表中,也不会被默认执行

#### 断言

catch支持的断言类型有如下几种:

1. `REQUIRE(<expression>)`/`CHECK(<expression>)`断言条件是成立的
2. `REQUIRE_THAT(<expression>, <matcher expression>)`/`CHECK_THAT(<expression>, <matcher expression>)`表达式的结果满足指定的匹配器或者匹配器,注意1,2项中的`<expression>`一定是谓词,而且值得一提的是都可以使用`Approx(float/double)`来模糊匹配浮点数.浮点数因为精度问题不可能完全相等,所以要用这个来断言.`Approx`后面还可以接如下设置:
   1. `epsilon`精度系数
   2. `margin`边界
   3. `scale`用于更改近似值的大小
3. `REQUIRE_FALSE(<expression>)`/`CHECK_FALSE(<expression>)`断言条件是不成立的,注意`<expression>`一定是谓词
4. `REQUIRE_THROW(<expression>)`/`CHECK_THROW(<expression>)`断言执行的表达式会出错
5. `REQUIRE_NOTHROW(<expression>)`/`CHECK_NOTHROW(<expression>)`断言执行的表达式不会出错
6. `REQUIRE_THROWS_AS(<expression>,<exception_type>)`/`CHECK_THROWS_AS(<expression>,<exception_type>)`,断言执行表达式会报出指定类型的错误
7. `REQUIRE_THROWS_WITH(<expression>,<string or string matcher>)`/`CHECK_THROWS_WITH(<expression>,<string or string matcher>)`,断言执行表达式会报出错误信息为指定字符串或者字符串匹配的错误
8. `REQUIRE_THROWS_MATCHES(<expression>,<exception type or matcher for given exception type>)`/`CHECK_THROWS_MATCHES(<expression>,<exception type or matcher for given exception type>)`,断言执行表达式会报出错误类型为指定类型或者匹配的错误

#### 匹配器

匹配器是用来处理一些特殊类型数据的工具,匹配器可以使用与`&&`或`||`非`!`进行连接.

下面是常用的匹配器:

> `std::string`

+ `Catch::Matchers::StartsWith(string x)`以x开始
+ `Catch::Matchers::EndsWith(string x)` 以x结尾
+ `Catch::Matchers::Contains(string x)` 包含x
+ `Catch::Matchers::Equals(string x)` 于x相同
+ `Catch::Matchers::Matches(string x)` 满足x描述的正则表达式匹配

> `std::vector`

+ `Catch::Matchers::Contains(<vector>)`vector是其子集
+ `Catch::Matchers::VectorContains(<element>)`包含元素
+ `Catch::Matchers::Equals(s<vector>)`完全相同
+ `Catch::Matchers::UnorderedEquals(<vector>)`内容相同,可以顺序不同
+ `Catch::Matchers::Approx(<vector>)`顺序相同,各项值相似

> 浮点数(float,double),主要有关精度

+ `Catch::Matchers::WithinAbs(double/float target, double margin)`设置精度内匹配
+ `Catch::Matchers::WithinULP(double/float target, int64_t ULPs)`设置[最后一位上的单位值](https://zh.wikipedia.org/wiki/%E6%9C%80%E5%90%8E%E4%B8%80%E4%BD%8D%E4%B8%8A%E7%9A%84%E5%8D%95%E4%BD%8D%E5%80%BC)内精度匹配
+ `Catch::Matchers::WithinRel(double/float target, double margin)`根据公式`|lhs - rhs| <= epsilon * max(|lhs|, |rhs|)`匹配精度.epsilon为机器精度

#### 数据生成器

宏`GENERATE`可以用于生成数据,和python中的生成器类似,这里的生成器也是包含`next()`接口的东西,它的用法就是类似`auto i = GENERATE(1, 2);`这个形式,其中i就是第几次调用时给出的元素.

执行测试时如果有`GENERATE`他就会被遍历

#### TDD风格的测试项写法

所谓TDD风格的测试项可以理解为一项一项的测试,这种风格就像写个列表,你把要测的分好组,分好项,一项一项列出来就行了.

我们为我们的例子写一个TDD风格的测试用例

+ `test/test_tdd.cc`

    ```c++
    #include <catch2/catch.hpp>
    #include "binary_vector.hpp"
    using vector::BinaryVector;
    using Catch::Matchers::WithinRel;
    TEST_CASE( "Test_TDD", "[vector][unittest]" ) {
        BinaryVector A(1.0,2.0);
        BinaryVector B(3.0,4.0);
        SECTION( "check mod A" ) {
            REQUIRE_THAT(2.23607,WithinRel(A.mod()));
        }
        SECTION( "check mod B" ) {
            REQUIRE_THAT(5.000000,WithinRel( B.mod()));
        }
        SECTION( "check mul A B" ) {
            REQUIRE_THAT(11.000000,WithinRel( A.mul(B)));
        }
        SECTION( "check add A B" ) {
            auto C =  A.add(B);
            REQUIRE_THAT(4.000000,WithinRel(C.x));
            REQUIRE_THAT(6.000000,WithinRel(C.y));
        }
    }
    ```

可以看到很直白的,tag是tag,case是case,section是section.

其中`TEST_CASE(<case_name>, "[tag]..." ){...}`就是用于声明case的语句,`SECTION( <section_name> ) {...}`则是用于声明section的语句.

#### BDD风格的测试项写法

所谓BDD更像是描述测试过程,需要写明条件和预期的行为.

我们为我们的例子写一个BDD风格的测试用例

+ `test/test_bdd.cc`

    ```c++
    #include <catch2/catch.hpp>
    #include "binary_vector.hpp"
    using vector::BinaryVector;
    using Catch::Matchers::WithinRel;

    SCENARIO("Test_BDD", "[vector][unittest]" ) {
        GIVEN( "2 vector A(1.0,2.0) and B(3.0,4.0)" ) {
            BinaryVector A(1.0,2.0);
            BinaryVector B(3.0,4.0);
            WHEN( "check mod A" ){
                THEN( "A mod is not far-off 2.23607" ){
                    REQUIRE_THAT(2.23607,WithinRel(A.mod()));
                }
            }
            WHEN( "check mod B" ) {
                THEN( "B mod is not far-off 5.000000" ){
                    REQUIRE_THAT(5.000000,WithinRel( B.mod()));
                }
            }
            WHEN( "check mul A B" ) {
                THEN( "A mul B is not far-off 11.000000" ){
                    REQUIRE_THAT(11.000000,WithinRel( A.mul(B)));
                }
            }
            WHEN( "check add A B" ) {
                auto C =  A.add(B);
                THEN( "A add B is not far-off {4.000000 , 6.000000}" ){
                    REQUIRE_THAT(4.000000,WithinRel(C.x));
                    REQUIRE_THAT(6.000000,WithinRel(C.y));
                }
            }
        }
    }
    ```

需要注意BDD风格的测试`casename`为`Scenario: <name>`这个name就是上文中`"Test_BDD"`的位置.这种风格相对来说附加信息更多些可读性更强些.

### 编译测试

我们依然使用cmake来管理项目,在cmake中我们首先需要构建一个可执行文件用于测试,上面两个测试的源文件并不够,因为没有入口函数,catch提供了一个标识`CATCH_CONFIG_MAIN`用于自动创建入口函数,我们需要将这个标识引入一个文件作为入口.

+ `test/test_main.cc`

    ```c++
    #define CATCH_CONFIG_MAIN  // This tells Catch to provide a main() - only do this in one cpp file
    #include <catch2/catch.hpp>
    ```

然后编译的时候我们将整个test文件夹中的所有文件名符合`test_*.cc`的文件作为源文件编译.

+ `CmakeLists.txt`

    ```cmake
    ...

    ## 编译测试文件
    message(NOTICE "下载外部依赖")
    include(FetchContent)
    ## catch2
    message(NOTICE "下载Catch2")
    FetchContent_Declare(Catch2
    TLS_VERIFY     FALSE
    URL  https://github.com/catchorg/Catch2/archive/refs/tags/v2.13.5.tar.gz
    )
    FetchContent_MakeAvailable(Catch2)

    # 准备存放位置
    file(MAKE_DIRECTORY ${CMAKE_CURRENT_LIST_DIR}/dist/test)
    add_executable(Test_${PROJECT_NAME} EXCLUDE_FROM_ALL)
    # 设置源码位置
    file(GLOB TESTSRC "${CMAKE_CURRENT_LIST_DIR}/test/test_*.cc")
    target_sources(Test_${PROJECT_NAME} 
        PRIVATE ${TESTSRC}
    )
    # 设置头文件
    target_include_directories(Test_${PROJECT_NAME}
        PRIVATE ${CMAKE_CURRENT_LIST_DIR}/inc
    )
    # 设置链接库
    target_link_libraries(Test_${PROJECT_NAME}
    PRIVATE ${PROJECT_NAME}::${PROJECT_NAME}
    PRIVATE Catch2::Catch2
    )
    # 设置可执行文件的存放位置
    set_target_properties(Test_${PROJECT_NAME} PROPERTIES 
        RUNTIME_OUTPUT_DIRECTORY ${CMAKE_CURRENT_LIST_DIR}/dist/test
    )

    ```

需要注意我们通常测试项的target会设置为`EXCLUDE_FROM_ALL`,以避免在作为依赖时编译测试项.

要编译测试项我们只要执行`make <target_name>`即可这个例子中就是`make Test_myvector`

### 执行测试

编译出来的测试文件可以被直接执行,其执行命令如下:

```bash
<target_name> [<case name|pattern|tags> ... ] options
```

我们可以指定case_name,tags来限定要执行的测试用例,也可以什么也不指定,不指定意思就是执行全部测试用例

`options`则是一些配置项,比较常用的有:

+ `-l`查看有哪些测试用例
+ `-t`查看有哪些标签
+ `-s`即便测试通过也打印报告
+ `-o`指定报告的输出位置,不指定就会打在stdout上
+ `-r`指定报告的格式,默认为consle,比较有用的是xml,junit,这两种可以嵌入到一些报告文本中
+ `--order`指定执行测试用例的顺序,可以是`decl`表示根据声明顺序;`lex`表示根据测试用例名称排序;`rand`表示随机顺序

### cmake中注册测试项

cmake中可以注册测试项来管理测试的执行,它的作用就是将执行命令注册到测试中.编译好后

+ `CmakeLists.txt`

    ```cmake
    ...

    ## 注册测试项
    enable_testing()
    add_test(Test_TDD ${CMAKE_CURRENT_LIST_DIR}/dist/test/Test_${PROJECT_NAME} Test_TDD)
    add_test(Test_BDD ${CMAKE_CURRENT_LIST_DIR}/dist/test/Test_${PROJECT_NAME} "Scenario: Test_BDD")
    ```

### 单元测试覆盖率

catch并不提供测试覆盖率功能,它只是个测试框架不要要求太多.C/C++的测试覆盖率可以使用[gcovr](https://gcovr.com/en/stable/)这个工具是受python的`coverage`启发设计的,结合cmake用法也很简单

1. 创建一个文件`cmake/CodeCoverage.camke`复制下下面的代码(注意下版权声明,感谢原作者Lars Bilke和后续的开发维护人员):

    ```cmake
    # Copyright (c) 2012 - 2017, Lars Bilke
    # All rights reserved.
    #
    # Redistribution and use in source and binary forms, with or without modification,
    # are permitted provided that the following conditions are met:
    #
    # 1. Redistributions of source code must retain the above copyright notice, this
    #    list of conditions and the following disclaimer.
    #
    # 2. Redistributions in binary form must reproduce the above copyright notice,
    #    this list of conditions and the following disclaimer in the documentation
    #    and/or other materials provided with the distribution.
    #
    # 3. Neither the name of the copyright holder nor the names of its contributors
    #    may be used to endorse or promote products derived from this software without
    #    specific prior written permission.
    #
    # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
    # ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
    # WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    # DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
    # ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
    # (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
    # LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
    # ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    # SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    #
    # CHANGES:
    #
    # 2012-01-31, Lars Bilke
    # - Enable Code Coverage
    #
    # 2013-09-17, Joakim Söderberg
    # - Added support for Clang.
    # - Some additional usage instructions.
    #
    # 2016-02-03, Lars Bilke
    # - Refactored functions to use named parameters
    #
    # 2017-06-02, Lars Bilke
    # - Merged with modified version from github.com/ufz/ogs
    #
    # 2019-05-06, Anatolii Kurotych
    # - Remove unnecessary --coverage flag
    #
    # 2019-12-13, FeRD (Frank Dana)
    # - Deprecate COVERAGE_LCOVR_EXCLUDES and COVERAGE_GCOVR_EXCLUDES lists in favor
    #   of tool-agnostic COVERAGE_EXCLUDES variable, or EXCLUDE setup arguments.
    # - CMake 3.4+: All excludes can be specified relative to BASE_DIRECTORY
    # - All setup functions: accept BASE_DIRECTORY, EXCLUDE list
    # - Set lcov basedir with -b argument
    # - Add automatic --demangle-cpp in lcovr, if 'c++filt' is available (can be
    #   overridden with NO_DEMANGLE option in setup_target_for_coverage_lcovr().)
    # - Delete output dir, .info file on 'make clean'
    # - Remove Python detection, since version mismatches will break gcovr
    # - Minor cleanup (lowercase function names, update examples...)
    #
    # 2019-12-19, FeRD (Frank Dana)
    # - Rename Lcov outputs, make filtered file canonical, fix cleanup for targets
    #
    # 2020-01-19, Bob Apthorpe
    # - Added gfortran support
    #
    # 2020-02-17, FeRD (Frank Dana)
    # - Make all add_custom_target()s VERBATIM to auto-escape wildcard characters
    #   in EXCLUDEs, and remove manual escaping from gcovr targets
    #
    # 2021-01-19, Robin Mueller
    # - Add CODE_COVERAGE_VERBOSE option which will allow to print out commands which are run
    # - Added the option for users to set the GCOVR_ADDITIONAL_ARGS variable to supply additional
    #   flags to the gcovr command
    #
    # 2020-05-04, Mihchael Davis
    #     - Add -fprofile-abs-path to make gcno files contain absolute paths
    #     - Fix BASE_DIRECTORY not working when defined
    #     - Change BYPRODUCT from folder to index.html to stop ninja from complaining about double defines
    # USAGE:
    #
    # 1. Copy this file into your cmake modules path.
    #
    # 2. Add the following line to your CMakeLists.txt (best inside an if-condition
    #    using a CMake option() to enable it just optionally):
    #      include(CodeCoverage)
    #
    # 3. Append necessary compiler flags:
    #      append_coverage_compiler_flags()
    #
    # 3.a (OPTIONAL) Set appropriate optimization flags, e.g. -O0, -O1 or -Og
    #
    # 4. If you need to exclude additional directories from the report, specify them
    #    using full paths in the COVERAGE_EXCLUDES variable before calling
    #    setup_target_for_coverage_*().
    #    Example:
    #      set(COVERAGE_EXCLUDES
    #          '${PROJECT_SOURCE_DIR}/src/dir1/*'
    #          '/path/to/my/src/dir2/*')
    #    Or, use the EXCLUDE argument to setup_target_for_coverage_*().
    #    Example:
    #      setup_target_for_coverage_lcov(
    #          NAME coverage
    #          EXECUTABLE testrunner
    #          EXCLUDE "${PROJECT_SOURCE_DIR}/src/dir1/*" "/path/to/my/src/dir2/*")
    #
    # 4.a NOTE: With CMake 3.4+, COVERAGE_EXCLUDES or EXCLUDE can also be set
    #     relative to the BASE_DIRECTORY (default: PROJECT_SOURCE_DIR)
    #     Example:
    #       set(COVERAGE_EXCLUDES "dir1/*")
    #       setup_target_for_coverage_gcovr_html(
    #           NAME coverage
    #           EXECUTABLE testrunner
    #           BASE_DIRECTORY "${PROJECT_SOURCE_DIR}/src"
    #           EXCLUDE "dir2/*")
    #
    # 5. Use the functions described below to create a custom make target which
    #    runs your test executable and produces a code coverage report.
    #
    # 6. Build a Debug build:
    #      cmake -DCMAKE_BUILD_TYPE=Debug ..
    #      make
    #      make my_coverage_target
    #

    include(CMakeParseArguments)

    option(CODE_COVERAGE_VERBOSE "Verbose information" FALSE)

    # Check prereqs
    find_program( GCOV_PATH gcov )
    find_program( LCOV_PATH  NAMES lcov lcov.bat lcov.exe lcov.perl)
    find_program( FASTCOV_PATH NAMES fastcov fastcov.py )
    find_program( GENHTML_PATH NAMES genhtml genhtml.perl genhtml.bat )
    find_program( GCOVR_PATH gcovr PATHS ${CMAKE_SOURCE_DIR}/scripts/test)
    find_program( CPPFILT_PATH NAMES c++filt )

    if(NOT GCOV_PATH)
        message(FATAL_ERROR "gcov not found! Aborting...")
    endif() # NOT GCOV_PATH

    get_property(LANGUAGES GLOBAL PROPERTY ENABLED_LANGUAGES)
    list(GET LANGUAGES 0 LANG)

    if("${CMAKE_${LANG}_COMPILER_ID}" MATCHES "(Apple)?[Cc]lang")
        if("${CMAKE_${LANG}_COMPILER_VERSION}" VERSION_LESS 3)
            message(FATAL_ERROR "Clang version must be 3.0.0 or greater! Aborting...")
        endif()
    elseif(NOT CMAKE_COMPILER_IS_GNUCXX)
        if("${CMAKE_Fortran_COMPILER_ID}" MATCHES "[Ff]lang")
            # Do nothing; exit conditional without error if true
        elseif("${CMAKE_Fortran_COMPILER_ID}" MATCHES "GNU")
            # Do nothing; exit conditional without error if true
        else()
            message(FATAL_ERROR "Compiler is not GNU gcc! Aborting...")
        endif()
    endif()

    set(COVERAGE_COMPILER_FLAGS "-g -fprofile-arcs -ftest-coverage"
        CACHE INTERNAL "")
    if(CMAKE_CXX_COMPILER_ID MATCHES "(GNU|Clang)")
        include(CheckCXXCompilerFlag)
        check_cxx_compiler_flag(-fprofile-abs-path HAVE_fprofile_abs_path)
        if(HAVE_fprofile_abs_path)
            set(COVERAGE_COMPILER_FLAGS "${COVERAGE_COMPILER_FLAGS} -fprofile-abs-path")
        endif()
    endif()

    set(CMAKE_Fortran_FLAGS_COVERAGE
        ${COVERAGE_COMPILER_FLAGS}
        CACHE STRING "Flags used by the Fortran compiler during coverage builds."
        FORCE )
    set(CMAKE_CXX_FLAGS_COVERAGE
        ${COVERAGE_COMPILER_FLAGS}
        CACHE STRING "Flags used by the C++ compiler during coverage builds."
        FORCE )
    set(CMAKE_C_FLAGS_COVERAGE
        ${COVERAGE_COMPILER_FLAGS}
        CACHE STRING "Flags used by the C compiler during coverage builds."
        FORCE )
    set(CMAKE_EXE_LINKER_FLAGS_COVERAGE
        ""
        CACHE STRING "Flags used for linking binaries during coverage builds."
        FORCE )
    set(CMAKE_SHARED_LINKER_FLAGS_COVERAGE
        ""
        CACHE STRING "Flags used by the shared libraries linker during coverage builds."
        FORCE )
    mark_as_advanced(
        CMAKE_Fortran_FLAGS_COVERAGE
        CMAKE_CXX_FLAGS_COVERAGE
        CMAKE_C_FLAGS_COVERAGE
        CMAKE_EXE_LINKER_FLAGS_COVERAGE
        CMAKE_SHARED_LINKER_FLAGS_COVERAGE )

    if(NOT CMAKE_BUILD_TYPE STREQUAL "Debug")
        message(WARNING "Code coverage results with an optimised (non-Debug) build may be misleading")
    endif() # NOT CMAKE_BUILD_TYPE STREQUAL "Debug"

    if(CMAKE_C_COMPILER_ID STREQUAL "GNU" OR CMAKE_Fortran_COMPILER_ID STREQUAL "GNU")
        link_libraries(gcov)
    endif()

    # Defines a target for running and collection code coverage information
    # Builds dependencies, runs the given executable and outputs reports.
    # NOTE! The executable should always have a ZERO as exit code otherwise
    # the coverage generation will not complete.
    #
    # setup_target_for_coverage_lcov(
    #     NAME testrunner_coverage                    # New target name
    #     EXECUTABLE testrunner -j ${PROCESSOR_COUNT} # Executable in PROJECT_BINARY_DIR
    #     DEPENDENCIES testrunner                     # Dependencies to build first
    #     BASE_DIRECTORY "../"                        # Base directory for report
    #                                                 #  (defaults to PROJECT_SOURCE_DIR)
    #     EXCLUDE "src/dir1/*" "src/dir2/*"           # Patterns to exclude (can be relative
    #                                                 #  to BASE_DIRECTORY, with CMake 3.4+)
    #     NO_DEMANGLE                                 # Don't demangle C++ symbols
    #                                                 #  even if c++filt is found
    # )
    function(setup_target_for_coverage_lcov)

        set(options NO_DEMANGLE)
        set(oneValueArgs BASE_DIRECTORY NAME)
        set(multiValueArgs EXCLUDE EXECUTABLE EXECUTABLE_ARGS DEPENDENCIES LCOV_ARGS GENHTML_ARGS)
        cmake_parse_arguments(Coverage "${options}" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})

        if(NOT LCOV_PATH)
            message(FATAL_ERROR "lcov not found! Aborting...")
        endif() # NOT LCOV_PATH

        if(NOT GENHTML_PATH)
            message(FATAL_ERROR "genhtml not found! Aborting...")
        endif() # NOT GENHTML_PATH

        # Set base directory (as absolute path), or default to PROJECT_SOURCE_DIR
        if(DEFINED Coverage_BASE_DIRECTORY)
            get_filename_component(BASEDIR ${Coverage_BASE_DIRECTORY} ABSOLUTE)
        else()
            set(BASEDIR ${PROJECT_SOURCE_DIR})
        endif()

        # Collect excludes (CMake 3.4+: Also compute absolute paths)
        set(LCOV_EXCLUDES "")
        foreach(EXCLUDE ${Coverage_EXCLUDE} ${COVERAGE_EXCLUDES} ${COVERAGE_LCOV_EXCLUDES})
            if(CMAKE_VERSION VERSION_GREATER 3.4)
                get_filename_component(EXCLUDE ${EXCLUDE} ABSOLUTE BASE_DIR ${BASEDIR})
            endif()
            list(APPEND LCOV_EXCLUDES "${EXCLUDE}")
        endforeach()
        list(REMOVE_DUPLICATES LCOV_EXCLUDES)

        # Conditional arguments
        if(CPPFILT_PATH AND NOT ${Coverage_NO_DEMANGLE})
        set(GENHTML_EXTRA_ARGS "--demangle-cpp")
        endif()
        
        # Setting up commands which will be run to generate coverage data.
        # Cleanup lcov
        set(LCOV_CLEAN_CMD 
            ${LCOV_PATH} ${Coverage_LCOV_ARGS} --gcov-tool ${GCOV_PATH} -directory . 
            -b ${BASEDIR} --zerocounters
        )
        # Create baseline to make sure untouched files show up in the report
        set(LCOV_BASELINE_CMD 
            ${LCOV_PATH} ${Coverage_LCOV_ARGS} --gcov-tool ${GCOV_PATH} -c -i -d . -b 
            ${BASEDIR} -o ${Coverage_NAME}.base
        )
        # Run tests
        set(LCOV_EXEC_TESTS_CMD 
            ${Coverage_EXECUTABLE} ${Coverage_EXECUTABLE_ARGS}
        )    
        # Capturing lcov counters and generating report
        set(LCOV_CAPTURE_CMD 
            ${LCOV_PATH} ${Coverage_LCOV_ARGS} --gcov-tool ${GCOV_PATH} --directory . -b 
            ${BASEDIR} --capture --output-file ${Coverage_NAME}.capture
        )
        # add baseline counters
        set(LCOV_BASELINE_COUNT_CMD
            ${LCOV_PATH} ${Coverage_LCOV_ARGS} --gcov-tool ${GCOV_PATH} -a ${Coverage_NAME}.base 
            -a ${Coverage_NAME}.capture --output-file ${Coverage_NAME}.total
        ) 
        # filter collected data to final coverage report
        set(LCOV_FILTER_CMD 
            ${LCOV_PATH} ${Coverage_LCOV_ARGS} --gcov-tool ${GCOV_PATH} --remove 
            ${Coverage_NAME}.total ${LCOV_EXCLUDES} --output-file ${Coverage_NAME}.info
        )    
        # Generate HTML output
        set(LCOV_GEN_HTML_CMD
            ${GENHTML_PATH} ${GENHTML_EXTRA_ARGS} ${Coverage_GENHTML_ARGS} -o 
            ${Coverage_NAME} ${Coverage_NAME}.info
        )
        

        if(CODE_COVERAGE_VERBOSE)
            message(STATUS "Executed command report")
            message(STATUS "Command to clean up lcov: ")
            string(REPLACE ";" " " LCOV_CLEAN_CMD_SPACED "${LCOV_CLEAN_CMD}")
            message(STATUS "${LCOV_CLEAN_CMD_SPACED}")

            message(STATUS "Command to create baseline: ")
            string(REPLACE ";" " " LCOV_BASELINE_CMD_SPACED "${LCOV_BASELINE_CMD}")
            message(STATUS "${LCOV_BASELINE_CMD_SPACED}")

            message(STATUS "Command to run the tests: ")
            string(REPLACE ";" " " LCOV_EXEC_TESTS_CMD_SPACED "${LCOV_EXEC_TESTS_CMD}")
            message(STATUS "${LCOV_EXEC_TESTS_CMD_SPACED}")

            message(STATUS "Command to capture counters and generate report: ")
            string(REPLACE ";" " " LCOV_CAPTURE_CMD_SPACED "${LCOV_CAPTURE_CMD}")
            message(STATUS "${LCOV_CAPTURE_CMD_SPACED}")

            message(STATUS "Command to add baseline counters: ")
            string(REPLACE ";" " " LCOV_BASELINE_COUNT_CMD_SPACED "${LCOV_BASELINE_COUNT_CMD}")
            message(STATUS "${LCOV_BASELINE_COUNT_CMD_SPACED}")

            message(STATUS "Command to filter collected data: ")
            string(REPLACE ";" " " LCOV_FILTER_CMD_SPACED "${LCOV_FILTER_CMD}")
            message(STATUS "${LCOV_FILTER_CMD_SPACED}")

            message(STATUS "Command to generate lcov HTML output: ")
            string(REPLACE ";" " " LCOV_GEN_HTML_CMD_SPACED "${LCOV_GEN_HTML_CMD}")
            message(STATUS "${LCOV_GEN_HTML_CMD_SPACED}")
        endif()

        # Setup target
        add_custom_target(${Coverage_NAME}
            COMMAND ${LCOV_CLEAN_CMD}
            COMMAND ${LCOV_BASELINE_CMD} 
            COMMAND ${LCOV_EXEC_TESTS_CMD}
            COMMAND ${LCOV_CAPTURE_CMD}
            COMMAND ${LCOV_BASELINE_COUNT_CMD}
            COMMAND ${LCOV_FILTER_CMD} 
            COMMAND ${LCOV_GEN_HTML_CMD}

            # Set output files as GENERATED (will be removed on 'make clean')
            BYPRODUCTS
                ${Coverage_NAME}.base
                ${Coverage_NAME}.capture
                ${Coverage_NAME}.total
                ${Coverage_NAME}.info
                ${Coverage_NAME}/index.html
            WORKING_DIRECTORY ${PROJECT_BINARY_DIR}
            DEPENDS ${Coverage_DEPENDENCIES}
            VERBATIM # Protect arguments to commands
            COMMENT "Resetting code coverage counters to zero.\nProcessing code coverage counters and generating report."
        )

        # Show where to find the lcov info report
        add_custom_command(TARGET ${Coverage_NAME} POST_BUILD
            COMMAND ;
            COMMENT "Lcov code coverage info report saved in ${Coverage_NAME}.info."
        )

        # Show info where to find the report
        add_custom_command(TARGET ${Coverage_NAME} POST_BUILD
            COMMAND ;
            COMMENT "Open ./${Coverage_NAME}/index.html in your browser to view the coverage report."
        )

    endfunction() # setup_target_for_coverage_lcov

    # Defines a target for running and collection code coverage information
    # Builds dependencies, runs the given executable and outputs reports.
    # NOTE! The executable should always have a ZERO as exit code otherwise
    # the coverage generation will not complete.
    #
    # setup_target_for_coverage_gcovr_xml(
    #     NAME ctest_coverage                    # New target name
    #     EXECUTABLE ctest -j ${PROCESSOR_COUNT} # Executable in PROJECT_BINARY_DIR
    #     DEPENDENCIES executable_target         # Dependencies to build first
    #     BASE_DIRECTORY "../"                   # Base directory for report
    #                                            #  (defaults to PROJECT_SOURCE_DIR)
    #     EXCLUDE "src/dir1/*" "src/dir2/*"      # Patterns to exclude (can be relative
    #                                            #  to BASE_DIRECTORY, with CMake 3.4+)
    # )
    # The user can set the variable GCOVR_ADDITIONAL_ARGS to supply additional flags to the
    # GCVOR command.
    function(setup_target_for_coverage_gcovr_xml)

        set(options NONE)
        set(oneValueArgs BASE_DIRECTORY NAME)
        set(multiValueArgs EXCLUDE EXECUTABLE EXECUTABLE_ARGS DEPENDENCIES)
        cmake_parse_arguments(Coverage "${options}" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})

        if(NOT GCOVR_PATH)
            message(FATAL_ERROR "gcovr not found! Aborting...")
        endif() # NOT GCOVR_PATH

        # Set base directory (as absolute path), or default to PROJECT_SOURCE_DIR
        if(DEFINED Coverage_BASE_DIRECTORY)
            get_filename_component(BASEDIR ${Coverage_BASE_DIRECTORY} ABSOLUTE)
        else()
            set(BASEDIR ${PROJECT_SOURCE_DIR})
        endif()

        # Collect excludes (CMake 3.4+: Also compute absolute paths)
        set(GCOVR_EXCLUDES "")
        foreach(EXCLUDE ${Coverage_EXCLUDE} ${COVERAGE_EXCLUDES} ${COVERAGE_GCOVR_EXCLUDES})
            if(CMAKE_VERSION VERSION_GREATER 3.4)
                get_filename_component(EXCLUDE ${EXCLUDE} ABSOLUTE BASE_DIR ${BASEDIR})
            endif()
            list(APPEND GCOVR_EXCLUDES "${EXCLUDE}")
        endforeach()
        list(REMOVE_DUPLICATES GCOVR_EXCLUDES)

        # Combine excludes to several -e arguments
        set(GCOVR_EXCLUDE_ARGS "")
        foreach(EXCLUDE ${GCOVR_EXCLUDES})
            list(APPEND GCOVR_EXCLUDE_ARGS "-e")
            list(APPEND GCOVR_EXCLUDE_ARGS "${EXCLUDE}")
        endforeach()
        
        # Set up commands which will be run to generate coverage data
        # Run tests
        set(GCOVR_XML_EXEC_TESTS_CMD
            ${Coverage_EXECUTABLE} ${Coverage_EXECUTABLE_ARGS}
        )
        # Running gcovr
        set(GCOVR_XML_CMD
            ${GCOVR_PATH} --xml -r ${BASEDIR} ${GCOVR_ADDITIONAL_ARGS} ${GCOVR_EXCLUDE_ARGS} 
            --object-directory=${PROJECT_BINARY_DIR} -o ${Coverage_NAME}.xml
        )
        
        if(CODE_COVERAGE_VERBOSE)
            message(STATUS "Executed command report")

            message(STATUS "Command to run tests: ")
            string(REPLACE ";" " " GCOVR_XML_EXEC_TESTS_CMD_SPACED "${GCOVR_XML_EXEC_TESTS_CMD}")
            message(STATUS "${GCOVR_XML_EXEC_TESTS_CMD_SPACED}")

            message(STATUS "Command to generate gcovr XML coverage data: ")
            string(REPLACE ";" " " GCOVR_XML_CMD_SPACED "${GCOVR_XML_CMD}")
            message(STATUS "${GCOVR_XML_CMD_SPACED}")
        endif()

        add_custom_target(${Coverage_NAME}
            COMMAND ${GCOVR_XML_EXEC_TESTS_CMD}
            COMMAND ${GCOVR_XML_CMD}
            
            BYPRODUCTS ${Coverage_NAME}.xml
            WORKING_DIRECTORY ${PROJECT_BINARY_DIR}
            DEPENDS ${Coverage_DEPENDENCIES}
            VERBATIM # Protect arguments to commands
            COMMENT "Running gcovr to produce Cobertura code coverage report."
        )

        # Show info where to find the report
        add_custom_command(TARGET ${Coverage_NAME} POST_BUILD
            COMMAND ;
            COMMENT "Cobertura code coverage report saved in ${Coverage_NAME}.xml."
        )
    endfunction() # setup_target_for_coverage_gcovr_xml

    # Defines a target for running and collection code coverage information
    # Builds dependencies, runs the given executable and outputs reports.
    # NOTE! The executable should always have a ZERO as exit code otherwise
    # the coverage generation will not complete.
    #
    # setup_target_for_coverage_gcovr_html(
    #     NAME ctest_coverage                    # New target name
    #     EXECUTABLE ctest -j ${PROCESSOR_COUNT} # Executable in PROJECT_BINARY_DIR
    #     DEPENDENCIES executable_target         # Dependencies to build first
    #     BASE_DIRECTORY "../"                   # Base directory for report
    #                                            #  (defaults to PROJECT_SOURCE_DIR)
    #     EXCLUDE "src/dir1/*" "src/dir2/*"      # Patterns to exclude (can be relative
    #                                            #  to BASE_DIRECTORY, with CMake 3.4+)
    # )
    # The user can set the variable GCOVR_ADDITIONAL_ARGS to supply additional flags to the
    # GCVOR command.
    function(setup_target_for_coverage_gcovr_html)

        set(options NONE)
        set(oneValueArgs BASE_DIRECTORY NAME)
        set(multiValueArgs EXCLUDE EXECUTABLE EXECUTABLE_ARGS DEPENDENCIES)
        cmake_parse_arguments(Coverage "${options}" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})

        if(NOT GCOVR_PATH)
            message(FATAL_ERROR "gcovr not found! Aborting...")
        endif() # NOT GCOVR_PATH

        # Set base directory (as absolute path), or default to PROJECT_SOURCE_DIR
        if(DEFINED Coverage_BASE_DIRECTORY)
            get_filename_component(BASEDIR ${Coverage_BASE_DIRECTORY} ABSOLUTE)
        else()
            set(BASEDIR ${PROJECT_SOURCE_DIR})
        endif()

        # Collect excludes (CMake 3.4+: Also compute absolute paths)
        set(GCOVR_EXCLUDES "")
        foreach(EXCLUDE ${Coverage_EXCLUDE} ${COVERAGE_EXCLUDES} ${COVERAGE_GCOVR_EXCLUDES})
            if(CMAKE_VERSION VERSION_GREATER 3.4)
                get_filename_component(EXCLUDE ${EXCLUDE} ABSOLUTE BASE_DIR ${BASEDIR})
            endif()
            list(APPEND GCOVR_EXCLUDES "${EXCLUDE}")
        endforeach()
        list(REMOVE_DUPLICATES GCOVR_EXCLUDES)

        # Combine excludes to several -e arguments
        set(GCOVR_EXCLUDE_ARGS "")
        foreach(EXCLUDE ${GCOVR_EXCLUDES})
            list(APPEND GCOVR_EXCLUDE_ARGS "-e")
            list(APPEND GCOVR_EXCLUDE_ARGS "${EXCLUDE}")
        endforeach()

        # Set up commands which will be run to generate coverage data
        # Run tests
        set(GCOVR_HTML_EXEC_TESTS_CMD
            ${Coverage_EXECUTABLE} ${Coverage_EXECUTABLE_ARGS}
        )
        # Create folder
        set(GCOVR_HTML_FOLDER_CMD
            ${CMAKE_COMMAND} -E make_directory ${PROJECT_BINARY_DIR}/${Coverage_NAME}
        )
        # Running gcovr
        set(GCOVR_HTML_CMD
            ${GCOVR_PATH} --html --html-details -r ${BASEDIR} ${GCOVR_ADDITIONAL_ARGS}
            ${GCOVR_EXCLUDE_ARGS} --object-directory=${PROJECT_BINARY_DIR} 
            -o ${Coverage_NAME}/index.html
        )

        if(CODE_COVERAGE_VERBOSE)
            message(STATUS "Executed command report")

            message(STATUS "Command to run tests: ")
            string(REPLACE ";" " " GCOVR_HTML_EXEC_TESTS_CMD_SPACED "${GCOVR_HTML_EXEC_TESTS_CMD}")
            message(STATUS "${GCOVR_HTML_EXEC_TESTS_CMD_SPACED}")

            message(STATUS "Command to create a folder: ")
            string(REPLACE ";" " " GCOVR_HTML_FOLDER_CMD_SPACED "${GCOVR_HTML_FOLDER_CMD}")
            message(STATUS "${GCOVR_HTML_FOLDER_CMD_SPACED}")

            message(STATUS "Command to generate gcovr HTML coverage data: ")
            string(REPLACE ";" " " GCOVR_HTML_CMD_SPACED "${GCOVR_HTML_CMD}")
            message(STATUS "${GCOVR_HTML_CMD_SPACED}")
        endif()

        add_custom_target(${Coverage_NAME}
            COMMAND ${GCOVR_HTML_EXEC_TESTS_CMD}
            COMMAND ${GCOVR_HTML_FOLDER_CMD}
            COMMAND ${GCOVR_HTML_CMD}

            BYPRODUCTS ${PROJECT_BINARY_DIR}/${Coverage_NAME}/index.html  # report directory
            WORKING_DIRECTORY ${PROJECT_BINARY_DIR}
            DEPENDS ${Coverage_DEPENDENCIES}
            VERBATIM # Protect arguments to commands
            COMMENT "Running gcovr to produce HTML code coverage report."
        )

        # Show info where to find the report
        add_custom_command(TARGET ${Coverage_NAME} POST_BUILD
            COMMAND ;
            COMMENT "Open ./${Coverage_NAME}/index.html in your browser to view the coverage report."
        )

    endfunction() # setup_target_for_coverage_gcovr_html

    # Defines a target for running and collection code coverage information
    # Builds dependencies, runs the given executable and outputs reports.
    # NOTE! The executable should always have a ZERO as exit code otherwise
    # the coverage generation will not complete.
    #
    # setup_target_for_coverage_fastcov(
    #     NAME testrunner_coverage                    # New target name
    #     EXECUTABLE testrunner -j ${PROCESSOR_COUNT} # Executable in PROJECT_BINARY_DIR
    #     DEPENDENCIES testrunner                     # Dependencies to build first
    #     BASE_DIRECTORY "../"                        # Base directory for report
    #                                                 #  (defaults to PROJECT_SOURCE_DIR)
    #     EXCLUDE "src/dir1/" "src/dir2/"             # Patterns to exclude.
    #     NO_DEMANGLE                                 # Don't demangle C++ symbols
    #                                                 #  even if c++filt is found
    #     SKIP_HTML                                   # Don't create html report
    # )
    function(setup_target_for_coverage_fastcov)

        set(options NO_DEMANGLE SKIP_HTML)
        set(oneValueArgs BASE_DIRECTORY NAME)
        set(multiValueArgs EXCLUDE EXECUTABLE EXECUTABLE_ARGS DEPENDENCIES FASTCOV_ARGS GENHTML_ARGS)
        cmake_parse_arguments(Coverage "${options}" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})

        if(NOT FASTCOV_PATH)
            message(FATAL_ERROR "fastcov not found! Aborting...")
        endif()

        if(NOT GENHTML_PATH)
            message(FATAL_ERROR "genhtml not found! Aborting...")
        endif()

        # Set base directory (as absolute path), or default to PROJECT_SOURCE_DIR
        if(Coverage_BASE_DIRECTORY)
            get_filename_component(BASEDIR ${Coverage_BASE_DIRECTORY} ABSOLUTE)
        else()
            set(BASEDIR ${PROJECT_SOURCE_DIR})
        endif()

        # Collect excludes (Patterns, not paths, for fastcov)
        set(FASTCOV_EXCLUDES "")
        foreach(EXCLUDE ${Coverage_EXCLUDE} ${COVERAGE_EXCLUDES} ${COVERAGE_FASTCOV_EXCLUDES})
            list(APPEND FASTCOV_EXCLUDES "${EXCLUDE}")
        endforeach()
        list(REMOVE_DUPLICATES FASTCOV_EXCLUDES)

        # Conditional arguments
        if(CPPFILT_PATH AND NOT ${Coverage_NO_DEMANGLE})
            set(GENHTML_EXTRA_ARGS "--demangle-cpp")
        endif()

        # Set up commands which will be run to generate coverage data
        set(FASTCOV_EXEC_TESTS_CMD ${Coverage_EXECUTABLE} ${Coverage_EXECUTABLE_ARGS})

        set(FASTCOV_CAPTURE_CMD ${FASTCOV_PATH} ${Coverage_FASTCOV_ARGS} --gcov ${GCOV_PATH}
            --search-directory ${BASEDIR}
            --process-gcno
            --lcov
            --output ${Coverage_NAME}.info
            --exclude ${FASTCOV_EXCLUDES}
            --exclude ${FASTCOV_EXCLUDES}
        )

        if(Coverage_SKIP_HTML)
            set(FASTCOV_HTML_CMD ";")
        else()
            set(FASTCOV_HTML_CMD ${GENHTML_PATH} ${GENHTML_EXTRA_ARGS} ${Coverage_GENHTML_ARGS}
                -o ${Coverage_NAME} ${Coverage_NAME}.info
            )
        endif()

        if(CODE_COVERAGE_VERBOSE)
            message(STATUS "Code coverage commands for target ${Coverage_NAME} (fastcov):")

            message("   Running tests:")
            string(REPLACE ";" " " FASTCOV_EXEC_TESTS_CMD_SPACED "${FASTCOV_EXEC_TESTS_CMD}")
            message("     ${FASTCOV_EXEC_TESTS_CMD_SPACED}")

            message("   Capturing fastcov counters and generating report:")
            string(REPLACE ";" " " FASTCOV_CAPTURE_CMD_SPACED "${FASTCOV_CAPTURE_CMD}")
            message("     ${FASTCOV_CAPTURE_CMD_SPACED}")

            if(NOT Coverage_SKIP_HTML)
                message("   Generating HTML report: ")
                string(REPLACE ";" " " FASTCOV_HTML_CMD_SPACED "${FASTCOV_HTML_CMD}")
                message("     ${FASTCOV_HTML_CMD_SPACED}")
            endif()
        endif()

        # Setup target
        add_custom_target(${Coverage_NAME}

            # Cleanup fastcov
            COMMAND ${FASTCOV_PATH} ${Coverage_FASTCOV_ARGS} --gcov ${GCOV_PATH}
                --search-directory ${BASEDIR}
                --zerocounters

            COMMAND ${FASTCOV_EXEC_TESTS_CMD}
            COMMAND ${FASTCOV_CAPTURE_CMD}
            COMMAND ${FASTCOV_HTML_CMD}

            # Set output files as GENERATED (will be removed on 'make clean')
            BYPRODUCTS
                ${Coverage_NAME}.info
                ${Coverage_NAME}/index.html  # report directory

            WORKING_DIRECTORY ${PROJECT_BINARY_DIR}
            DEPENDS ${Coverage_DEPENDENCIES}
            VERBATIM # Protect arguments to commands
            COMMENT "Resetting code coverage counters to zero. Processing code coverage counters and generating report."
        )

        set(INFO_MSG "fastcov code coverage info report saved in ${Coverage_NAME}.info.")
        if(NOT Coverage_SKIP_HTML)
            string(APPEND INFO_MSG " Open ${PROJECT_BINARY_DIR}/${Coverage_NAME}/index.html in your browser to view the coverage report.")
        endif()
        # Show where to find the fastcov info report
        add_custom_command(TARGET ${Coverage_NAME} POST_BUILD
            COMMAND ${CMAKE_COMMAND} -E echo ${INFO_MSG}
        )

    endfunction() # setup_target_for_coverage_fastcov

    function(append_coverage_compiler_flags)
        set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} ${COVERAGE_COMPILER_FLAGS}" PARENT_SCOPE)
        set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${COVERAGE_COMPILER_FLAGS}" PARENT_SCOPE)
        set(CMAKE_Fortran_FLAGS "${CMAKE_Fortran_FLAGS} ${COVERAGE_COMPILER_FLAGS}" PARENT_SCOPE)
        message(STATUS "Appending code coverage compiler flags: ${COVERAGE_COMPILER_FLAGS}")
    endfunction() # append_coverage_compiler_flags
    ```

2. 全局安装`gcover`
3. 修改你的`CmakeLists.txt`加入对覆盖率的支持

    ```cmake
    ...
    #测试
    ## 测试覆盖率
    option(WITH_TEST_COVERAGE "with test coverage?" off)
    if(WITH_TEST_COVERAGE)
        list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_LIST_DIR}/cmake")
        include(CodeCoverage)
        append_coverage_compiler_flags()
    endif()

    ## 编译测试文件
    message(NOTICE "下载外部依赖")
    include(FetchContent)
    ## catch2
    message(NOTICE "下载Catch2")
    FetchContent_Declare(Catch2
    TLS_VERIFY     FALSE
    URL  https://github.com/catchorg/Catch2/archive/refs/tags/v2.13.5.tar.gz
    )
    FetchContent_MakeAvailable(Catch2)

    # 准备存放位置
    file(MAKE_DIRECTORY ${CMAKE_CURRENT_LIST_DIR}/dist/test)
    add_executable(Test_${PROJECT_NAME} EXCLUDE_FROM_ALL)
    # 设置源码位置
    file(GLOB TESTSRC "${CMAKE_CURRENT_LIST_DIR}/test/test_*.cc")
    target_sources(Test_${PROJECT_NAME} 
        PRIVATE ${TESTSRC}
    )
    # 设置头文件
    target_include_directories(Test_${PROJECT_NAME}
        PRIVATE ${CMAKE_CURRENT_LIST_DIR}/inc
    )
    # 设置链接库
    target_link_libraries(Test_${PROJECT_NAME}
    PRIVATE ${PROJECT_NAME}::${PROJECT_NAME}
    PRIVATE Catch2::Catch2
    )
    # 设置可执行文件的存放位置
    set_target_properties(Test_${PROJECT_NAME} PROPERTIES 
        RUNTIME_OUTPUT_DIRECTORY ${CMAKE_CURRENT_LIST_DIR}/dist/test
    )

    ## 注册测试项
    enable_testing()
    add_test(Test_TDD ${CMAKE_CURRENT_LIST_DIR}/dist/test/Test_${PROJECT_NAME} Test_TDD)
    add_test(Test_BDD ${CMAKE_CURRENT_LIST_DIR}/dist/test/Test_${PROJECT_NAME} "Scenario: Test_BDD")
    if (WITH_TEST_COVERAGE)
        setup_target_for_coverage_gcovr_html(
            NAME coverage
            EXECUTABLE Test_${PROJECT_NAME}
            BASE_DIRECTORY "${CMAKE_CURRENT_LIST_DIR}"
            EXCLUDE "${CMAKE_CURRENT_LIST_DIR}/build/*" "${CMAKE_CURRENT_LIST_DIR}/test/*"
        )
    endif()
    ```

我们修改后是否生成测试覆盖率文档就成了一个可选项(通过`-DWITH_TEST_COVERAGE=on`打开).如果要生成覆盖率文档,那么我们需要导入之前复制下来的模块,,然后首先是使用`append_coverage_compiler_flags()`设置对应的编译器flag,然后根据需求选一个coverage taget生成器配置好就行,我这边用的是gcovr的html生成器,他会在执行目录下生成一个名为`coverage`的文件夹,下面就是生成的html文件了.我们需要指定`EXECUTABLE`为前面编译的测试文件,`BASE_DIRECTORY`为项目根目录,`EXCLUDE`为不用关心覆盖率的文件夹,这边把build和test文件夹略去了.

## 性能测试

Catch也实验性的支持简单性能测试,不过它只能做函数级别的性能测试

+ `test/test_benchmark.cc`

    ```c++
    #define CATCH_CONFIG_ENABLE_BENCHMARKING
    #include <catch2/catch.hpp>
    #include "binary_vector.hpp"
    using vector::BinaryVector;
    using Catch::Matchers::WithinRel;

    TEST_CASE( "Test_Benchmark", "[vector][benchmark]" ) {
        BinaryVector A(1.0,2.0);
        BinaryVector B(3.0,4.0);
        BENCHMARK( "benchmark mod A" ) {
            return A.mod();
        };
        BENCHMARK( "benchmark mod B" ) {
            return B.mod();
        };
        BENCHMARK( "benchmark mul A B" ) {
            return A.mul(B);
        };
        BENCHMARK( "benchmark add A B" ) {
            return  A.add(B);
        };
    }
    ```

需要注意引入`CATCH_CONFIG_MAIN`的文件中也必须引入标志`CATCH_CONFIG_ENABLE_BENCHMARKING`,否则编译时会找不到性能测试相关的实现:

+ `test/test_main.cc`

    ```c++
    #define CATCH_CONFIG_MAIN  // This tells Catch to provide a main() - only do this in one cpp file
    #define CATCH_CONFIG_ENABLE_BENCHMARKING
    #include <catch2/catch.hpp>
    ```

编译完成执行后我们就可以执行以查看性能指标了:

比如如下结果:

```txt
...............................................................................

benchmark name                       samples       iterations    estimated
                                     mean          low mean      high mean
                                     std dev       low std dev   high std dev
-------------------------------------------------------------------------------
benchmark mod A                                100           801     5.2866 ms 
                                         73.231 ns    70.0861 ns    77.5456 ns 
                                        18.6054 ns    14.3834 ns    23.6253 ns 
                                                                               
benchmark mod B                                100           703     5.2725 ms 
                                        79.7027 ns    78.5391 ns    81.7112 ns 
                                        7.60234 ns    5.04185 ns    11.0251 ns 
                                                                               
benchmark mul A B                              100          3477     5.2155 ms 
                                         14.906 ns    14.7639 ns     15.136 ns 
                                       0.906081 ns   0.636687 ns    1.28447 ns 
                                                                               
benchmark add A B                              100          2333     5.1326 ms 
                                        23.0463 ns    22.6601 ns    23.6494 ns 
                                        2.41954 ns    1.73759 ns    3.31989 ns 
                                                                               
```

性能测试的惯常思路是抽取一定数量的样本进行多次测试,然后计算每次测试的平均耗时和耗时的标准差,catch的性能测试使用的就是这种方式
表格中

+ `benchmark name`列表示测试项
+ `samples`表示抽取的样本量
+ `iterations`表示全样本执行的批次数
+ `estimated`表示总耗时
+ `mean`表示每次执行的平均耗时
+ `low mean`表示各个批次中均值最小的值
+ `high mean`表示各个批次中均值最大的值
+ `std dev`表示总体标准差
+ `low std dev`表示各个批次中标准差最小的值
+ `high std dev`表示各个批次中标准差最大的值
