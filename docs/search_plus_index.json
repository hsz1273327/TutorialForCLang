{"./":{"url":"./","title":"Introduction","keywords":"","body":"C++攻略 C语言程序设计是工科生的基本技能,而C++程序设计是计算机,信息学科的基本技能,对于搞数据科学的python程序员来说,c/c++是最好的第二门编程语言,因为它解决了python最大的问题--性能.并且学习它可以更好的了解计算机是如何运行的,利用ctypes也可以充分利用已有的c动态库.本文基于c++11,这也是目前最流行的版本. Copyright © hsz 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-07-04 00:55:35 "},"C语言风格的Cpp编程/":{"url":"C语言风格的Cpp编程/","title":"C语言风格的Cpp编程","keywords":"","body":"C语言风格的Cpp编程 说到底C++是以C为基础的,区块,语句,预处理,内置数据类型,数组,指针等都来自C, 许多时候C++对问题的解法其实不过是较高级的C解法.当然了在C++中使用C语言的成分的时候要比C语言中方便太多了, 因为它有着大量的现代语言特性,比如异常处理,比如类型推导,比如函数重载 本文分为以下几个部分: Cpp的基本形式 数据类型与变量常量 运算符 逻辑控制语句 函数 数组 自定义结构 指针与引用 头文件与多文件编译 静态连接库和动态链接库 Copyright © hsz 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-07-04 01:03:52 "},"C语言风格的Cpp编程/Cpp的基本形式.html":{"url":"C语言风格的Cpp编程/Cpp的基本形式.html","title":"Cpp的基本形式","keywords":"","body":"C++的基本形式 C++可以看做是C语言的一个威力加强版,因此C++向下兼容多数C语言的特性,如果把c++按c的写法来写,一个最简单的C++语言程序源文件如下: %%writefile src/c1/helloworldc.cpp #include int main(void){ printf(\"hello world\"); return 0; } Writing src/c1/helloworldc.cpp 上面是名为helloworld.cpp的源文件,和python一样,C++语言需要有源文件,源文件就是人能看得懂的写给机器执行的文件 这个源文件有如下几个部分: 引入头文件,c和c++中的头文件引入都是在标记位置直接复制文件中的内容,这会引起一些循环依赖之类的问题,这部分会在后面的部分着重理解. 入口函数main函数,函数会在后面详细讲解,这边只要先记住形式,入口函数有固定的写法.这边先记住是这样就好. 入口函数在{}块包围中有用分号断句的语句这些语句就是函数要执行的步骤了,C语言是面向过程语言,说简单点就是写好编译好了程序就按顺序一步一步执行 C++源程序的编译 和python不同,C++不是动态语言,必须静态的编译成可执行文件才能运行,python使用pvm解释生成字节码执行,而C++使用编译工具直接将源文件编译为机器可以执行的二进制文件. 由于平台不同,常见的C++编译器也不同,linux下最常见的是g++工具,mac下是clang,而window则是使用集成开发环境vs来编译,本文在mac下编写,所以使用的是clang,但g++和clang基本一样,所以linux下也可以按这个来. 编译上面的源文件 !g++-7 -o bin/helloworldc src/c1/helloworldc.cpp !./bin/helloworldc hello world 一个更加典型的C++helloworld: %%writefile src/c1/helloworld.cpp: #include #include using std::string; using std::cout; using std::endl; namespace helloworld { class Helloworld { private: string name; public: void print(){ cout name) > (this->name); } Helloworld(string name){ this->name = name; } }; } int main(){ namespace h=helloworld; h::Helloworld hello; hello.print(); return 0; } Writing src/c1/helloworld.cpp: ```python !g++-7 -o bin/helloworldc src/c1/helloworld.cpp !./bin/helloworld hello world mac下g++其实是连接到clang的, g++使用-o参数指出编译出来的文件放置地址. C++中的注释 不同于python,c++的行注释使用//,而段注释使用/**/ 标准库引用 C/C++都使用#include 引入模块,但C的标准库使用#include ,而C++的标准库使用#include using关键字和命名空间 命名空间是C中没有的概念,pythoner可以将其理解为python中的模块或者包的概念,他的用处就是区分不用来源的同名变量.有点类似一个定语,比如三班有小明四班也有小明,在各自班,老师喊小明都不会有歧义,但如果全校广播就会造成混乱.所以全校广播的话就会说是找三班的小明或者找四班的小明.命名空间就是类似几班的这种定语. C++在引用机制上和C是一样的,都是将多份不同的文件中的源文件直接复制到一起,也就类似于全校广播了,那怎么办?使用命名空间就可以解决了.由于命名空间引入,C++对大型项目可以有更好的支持. 创建命名空间 正如例子中一样,我们使用 namespace { xxx } 来创建命名空间,这个空间内的所有变量常量函数类都将不能直接访问,而要借助命名空间才能访问 使用命名空间 使用命名空间又两种方式: 直接使用 上面例子中std::cin就是典型,其中::代表所属关系,可以和python中的这种引用模块的方式做类比: import numpy numpy.add(1,2) ::符号就类似python模块引用中的.,起到表明从属关系的作用. 将命名空间中的对象引入当前空间 使用using ::;就可以将命名空间中的对象引入当前的变量空间,这就有点类似python中的from numpy import add,这样的坏处就是容易污染当前变量空间 为命名空间创建别名 依然是使用namespace关键字,使用如下表达式:namespace =;这样就可以使用代替了,不过要注意,这只是别名,并不是替换. 输入输出流 C++中使用流这个概念来描述输入输出,在标准库中有iostream来处理标准输入输出流,如例子中一样, iostream包括4个io对象: 输入流cin 输出cout log信息clog 标准错误cerr 输出流需要使用endl作为结尾 具体的使用方法可以看上面例子代码,其中称为输出运算符,>>称为输入运算符 iostream与stdio.h相比,增加了可扩展性,因为是流,但同时效率相比stdio.h差了一些. 字符串 C中只有字符,字符串则是字符数组,在C++中标准库string包含了针对string类型的一系列方法,虽然与python相比C++的字符串处理能力很弱,但已经比C好多了,他们包括: .c_str()转化为C风格的字符串 .length()获取字符串长度 + 字符串相加就是拼接 []访问字符串中的某位的字符 .insert(, )在指定位插入字符串 .erase([, ]) 在指定位删除一定长度的字符串内容 .substr(, )pos 为要提取的子字符串的起始下标，len 为要提取的子字符串的长度。 .find([, ])从pos位置开始向后找字符串是否匹配,str可以是std::string也可以是C的字符串,与之相似的是.rfind([, ])不同之处就是查找从右向左 .find_first_of(),字符串str在被查字符串中第一次出现的位置 Copyright © hsz 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-07-04 00:24:05 "},"C语言风格的Cpp编程/数据类型与变量常量.html":{"url":"C语言风格的Cpp编程/数据类型与变量常量.html","title":"数据类型与变量常量","keywords":"","body":"数据类型与变量常量 C++中的数据类型 C++中的数据类型很少,但很繁琐,讲起来很容易乱套,这边有一张图很好的总结了C++中的数据类型,除了bool型外的数据类型都可以在其中找到对应 short、int、long、char、float、double这6种被称为基本类型,他们除了意义不同精度不同,更加关键的是他们所占用的内存大小不同. 在32 位的系统上: short 在32位的系统上占用2个byte； int 在32位的系统上占用4 个byte； long 在32位的系统上占用4 个byte；64位系统 8个byte float 在32位的系统上占用4 个byte； double 在32位的系统上占用8 个byte； char 在32位的系统上占用1 个byte。 针对int,long,short,char,还有一个修饰关键词unsigned可以放在他们前面,表示无符号. 另外处理大数可以使用longlong数据类型,表示一个8byte的数 基本类型转换 C++语言的类型转换，可以分为两种： 自动类型转换（隐式类型转换，有编译器帮你去完成） 对于自动类型转换，最常见的就是混合运算以及赋值运算，还有一种就是函数值的类型转换 赋值运算：自动把“＝”右边的表达式的类型转换成“＝”右边的变量的类型，例如 int a=4.5; a的值实际是4！ 混合运算：就是一个运算表达式当中包含了多个类型，这时候就需要有类型转换。当运算符两边的操作数类型不同时，其中一个操作数就要经过类型转换以和另一个操作数的类型相一致，然后才能进行运算。 变换操作数采取就高不就低的原则，即级别低的操作数先被转换成和级别高的操作数具有同一类型，然后再进行运算，结果的数据类型和级别高的操作数相同。 高 double ←← float ↑ ↑ ↑ long ↑ ↑ ↑ unsigned ↑ ↑ 低 int ←← char,short 自动转换顺序表 函数返回值的类型转换： int f1(){ return 36.8;} 强制类型转换（你知道自己想要什么，所以才转换）。 强制类型转换运算符 可以利用强制类型转换运算符将一个表达式转换成所需类型: 例如： (double)a (将a转换成double类型) (int)(x+y) (将x+y的值转换成整型) (float)(5%3) (将5%3的值转换成float型) 注意，表达式应该用括号括起来。如果写成(int)x+y 则只将x转换成整型，然后与y相加。 变量 和python中类似,C++中也有变量,变量的定义方式如下: int a,b,c...; 也就是 (存储说明符 )数据类型 变量名1,变量名2...; C++语言和python不同的是python的变量不需要事先声明,而C++语言必须事先声明,习惯上变量会在一起声明,而不是东一块西一块的,这样也有助于debug. 存储说明符则是对变量特性的声明,常见的存储说明符有: static 静态局部变量,有时希望函数中的局部变量的值在函数调用结束后不消失而保留原值，这时就应该指定局部变量为\"静态局部变量\".它具有以下特点： 静态局部变量在函数内定义，但不象自动变量那样，当调用时就存在，退出函数时就消失。静态局部变量始终存在着，也就是说它的生存期为整个源程序。 静态局部变量的生存期虽然为整个源程序，但是其作用域仍与自动变量相同，即只能在定义该变量的函数内使用该变量。退出该函数后， 尽管该变量还继续存在，但不能使用它。 register 寄存器变量,为了提高效率，C++ 语言允许将局部变量得值放在CPU中的寄存器中，这种变量叫\"寄存器变量\" extern 外部变量（即全局变量）是在函数的外部定义的，它的作用域为从变量定义处开始，到本程序文件的末尾。如果外部变量不在文件的开头定义，其有效的作用范围只限于定义处到文件终了。如果在定义点之前的函数想引用该外部变量，则应该在引用之前用关键字 extern对该变量作“外部变量声明”。表示该变量是一个已经定义的外部变量。有了此声明，就可以从“声明”处起，合法地使用该外部变量。 总结： 从作用域来划分分为: 局部变量 静态局部变量static(离开函数，值还保留) 寄存器局部变量register(离开函数，值消失) 形式参数可以定义为自动变量或者register变量 全局变量 静态外部变量(作用域只能在该文件中，文件作用域) 外部变量(非静态外部变量,全局变量，可以被其它文件使用) 从变量的生存周期来分： 动态存储 寄存器变量register 形式参数 静态存储 静态局部变量 静态外部变量 外部变量(全局变量) 从变量值存放的位置： 内存中的静态存储区(全局数据区) 静态局部变量 静态外部变量 外部变量(全局变量) 内存中的动态存储区(栈) 形式参数 CPU中的寄存器 寄存器变量register 注意:当局部变量与全局变量重名的时候,和python一样,以局部变量为准,屏蔽全局变量 常量 常量是指值不可变的变量,C++语言中的常量其实一直以来都被误解,记得我学C的时候常量定义是这样的: #define Pi 3.14 其实这不是C++语言的常量,而是使用了所谓的宏,利用宏把3.14替换了Pi而已,你说这是常量吧也算,但C语言层面的常量定义方式实际上是这样的: const double Pi = 3.14; Python中没有常量一说,我们就写一个例子来理解下什么是常量 %%writefile src/C2/constant.cpp #include const float Pi = 3.1415; int main(void){ int r; float s; r = 2; s = Pi*r*r; printf(\"半径2m圆的面积为:%f\\n\",s); Pi = 3.14; printf(\"Pi=%f\\n\",Pi); return 0; } Overwriting src/C2/constant.cpp !g++-7 -o bin/constant src/C2/constant.cpp \u001b[01m\u001b[Ksrc/C2/constant.cpp:\u001b[m\u001b[K In function '\u001b[01m\u001b[Kint main()\u001b[m\u001b[K': \u001b[01m\u001b[Ksrc/C2/constant.cpp:13:10:\u001b[m\u001b[K \u001b[01;31m\u001b[Kerror: \u001b[m\u001b[Kassignment of read-only variable '\u001b[01m\u001b[KPi\u001b[m\u001b[K' Pi = \u001b[01;31m\u001b[K3.14\u001b[m\u001b[K; \u001b[01;31m\u001b[K^~~~\u001b[m\u001b[K 看,常数赋值后就无法再次赋值,将这句注释掉 %%writefile src/C2/constant.cpp #include const float Pi = 3.1415; int main(void){ int r; float s; r = 2; s = Pi*r*r; printf(\"半径2m圆的面积为:%f\\n\",s); //Pi = 3.14; printf(\"Pi=%f\\n\",Pi); return 0; } Overwriting src/C2/constant.cpp !g++-7 -o bin/constant src/C2/constant.cpp !bin/constant 半径2m圆的面积为:12.566000 Pi=3.141500 类型推导[C++11] auto auto在C++11中是用于类型推断关键字,auto是一个类型的占位符,通知编译器去根据初始化代码推断所声明变量的真实类型.各种作用域内声明变量都可以用到它.例如,名空间中,程序块中,或是for循环的初始化语句中.也就是说我们可以像scala中一样直接用var定义变量了,只是变量必须后面有赋值,这点对pythoner来说简直就是必须的. 需要注意的是，auto不能用来声明函数的返回值.但如果函数有一个尾随的返回类型时,auto是可以出现在函数声明中返回值位置.这种情况下,auto并不是告诉编译器去推断返回类型，而是指引编译器去函数的末端寻找返回值类型.在下面这个例子中，函数的返回值类型就是operator+操作符作用在T1、T2类型变量上的返回值类型. %%writefile src/C2/auto_test.cpp #include #include #include using std::cout; using std::endl; using std::vector; int quadratic_sum(vector &list){ auto sum=0; auto quadratic = [](int x)->decltype(sum){return pow(x,2);}; for(auto i :list){ sum += quadratic(i); } return sum; } int main(){ vector val = {1,2,3,4,5}; cout Overwriting src/C2/auto_test.cpp !g++-7 -o bin/auto_test src/C2/auto_test.cpp !bin/auto_test 55 decltype decltype可以说是auto的反义,它的作用是可以根据变量推断类型来声明,比如我们不知道a的类型,但我们想让b和a类型相同局可以使用 auto x = 3; decltype(x) y; Copyright © hsz 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-07-04 00:20:33 "},"C语言风格的Cpp编程/运算符.html":{"url":"C语言风格的Cpp编程/运算符.html","title":"运算符","keywords":"","body":"运算符 C++中的运算符和python中的类似,这边只拉出不同的几个 自增运算符 也就是传说中的++/--当然最好别用,语义不清.当然C中也有赋值运算符+=,但还是讲下,前置++速度高于后置,结果的区别看例子: %%writefile src/C3/increment.cpp #include int main(void){ int a = 5,b = 5; a++; ++b; printf(\"a:%d,b:%d\\n\",a,b); a = b++; printf(\"after a=b++\\na:%d,b:%d\\n\",a,b); a = ++b; printf(\"after a=++b\\na:%d,b:%d\\n\",a,b); return 0; } Overwriting src/C3/increment.cpp !g++-7 -o bin/increment src/C3/increment.cpp !bin/increment a:6,b:6 after a=b++ a:6,b:7 after a=++b a:8,b:8 如果前面有赋值,前置++后变量值自增1,后置++变量先赋值过去,然后再自增 逻辑运算符 Python中使用and or not 这些英文单词作为逻辑运算符,C++中则使用符号: C++中 python中 意义 && and 与 ll or 或 ! not 非 条件运算符 这个算是比较奇葩的了,C++中使用?:来做条件运算(三元运算),与之对应的是python中的条件表达式 True if exp else False. 看个例子: %%writefile src/c3/conditional_operator.cpp #include int main(void){ int a = 5; printf(\"a=5 是%s\\n\",(a%2==0? \"偶数\":\"奇数\")); return 0; } Overwriting src/c3/conditional_operator.cpp !g++-7 -o bin/conditional_operator src/c3/conditional_operator.cpp !bin/conditional_operator a=5 是奇数 sizeof运算符 sizeof运算符用来获取变量或者类型占用的内存大小 %%writefile src/c3/size.cpp #include int main(void){ long long a = 5; printf(\"a=5 占用%lu位\\n\",(sizeof(a))); return 0; } Overwriting src/c3/size.cpp !g++-7 -o bin/size src/c3/size.cpp !bin/size a=5 占用8位 强制类型转换运算符 伴随着类型系统,必然会有的就是类型转换操作,在python中形式是这样 a = 10 float(a) 10.0 c++中类似但形式不同 他的操作符是这样 (float) 变量名 %%writefile src/c3/type_conversions.cpp #include int main(void){ int a = 5; float b; b = (float) a; printf(\"a = %d,b = %f\\n\",a,b); return 0; } Overwriting src/c3/type_conversions.cpp !g++-7 -o bin/type_conversions src/c3/type_conversions.cpp !bin/type_conversions a = 5,b = 5.000000 逗号运算符 这个比较奇葩,它表示从左到右的计算 Copyright © hsz 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-07-04 00:22:17 "},"C语言风格的Cpp编程/逻辑控制语句.html":{"url":"C语言风格的Cpp编程/逻辑控制语句.html","title":"逻辑控制语句","keywords":"","body":"逻辑控制语句 C++中的逻辑控制语句其实还是基本的那么几个,与python相比,多了switch语句和goto语句.作为pythoner这部分其实没啥可讲,这边只列出形式. 循环语句 for循环 for(exp1;exp2;exp3){ 代码块 } exp1 一般是变量初始化,注意变量需要先声明,标准c语言不允许在exp1中直接声明变量,但其实很多编译器已经支持这种写法 exp2 用于判断是否停止循环,如果为为true则执行下面的代码块,否则不执行并且语句结束 exp3 如果exp2为true,则在执行完代码块后执行exp3,然后进入下一循环 while循环 while(exp){ 代码块 } exp 判断其是否为真,如果是则循环结束,否则进入代码块执行,然后进入下一循环 do...while循环 do{ 代码块 }while(exp); 先执行do中代码块 在判断while中表达式,如果为真则循环结束,否则继续循环执行do中代码 break和continue 和python中一样,我们也可以用break和contiue来中断循环.规则也相同 例: 牛顿法求2开根 python版本 EPS = 0.00001 a = 2 X = a/2.0 lastX = 0 while(abs(X - lastX) > EPS ): lastX = X X = (lastX+float(a/lastX))/2 print(X) 1.4142135623746899 C版本: %%writefile src/C4/sqrt2.cpp #include #include const double N = 2.0; double sqrt_my(double a,double EPS){ double x,last_x; x = a/2; do{ last_x = x; x = (last_x + a/last_x)/2; }while(fabs(last_x - x) > EPS); return x; } int main(void){ printf(\"根号2是%lf\\n\",sqrt_my(N,0.0001)); return 0; } Overwriting src/C4/sqrt2.cpp !g++-7 -o bin/sqrt2 src/C4/sqrt2.cpp !bin/sqrt2 根号2是1.414214 条件语句 if(exp1){ 代码块 }else if(exp2){ 代码块 }else{ 代码块 } 这个和python的差不多 分支语句 switch在python中被去掉了,主要也是因为它与if语句功能重复,不过swtich还是有用的,可以让代码看起来干净不少 switch(exp){ case 常量表达式1: 语句组1 break; case 常量表达式2: 语句组2 break; case 常量表达式3: 语句组3 break; default: 语句组4 } case是可以贯通的,如果case下面没有break,则它会穿到下一个break之上的位置才执行结束. goto goto就厉害了,这个体现了c++对底层的支持,它表示无条件跳转,用法是用label:标记要跳转的位置,然后goto label就可以了 这个语句是汇编语言的常用语句,用好了很牛,用烂很烂,建议不要用 基于Range的for循环[C++11] 基于Range的for循环一般配合可迭代对象使用,最常见的就是vector. 基本语法: attr(optional) for ( range_declaration : range_expression ) loop_statement %%writefile src/C4/forrange_test.cpp #include #include int main() { std::vector c { 1,2,3,4,5,6,7 }; int x = 5; std::cout Overwriting src/C4/forrange_test.cpp !g++-7 -o bin/forrange_test src/C4/forrange_test.cpp !./bin/forrange_test c: 2 4 6 异常处理语句 C语言本身不支持异常处理语句,而C++则原生的支持异常处理,其语法类似javascript的异常处理.相关的关键字有: throw抛出异常 try/catch异常捕获 我们可以将catch看做一个没有返回值的函数,当异常发生后catch会被调用,并且会接收实参(异常数据) 但是catch和真正的函数调用又有区别: 真正的函数调用,形参和实参的类型必须要匹配,或者可以自动转换,否则在编译阶段就报错了. 而对于catch,异常是在运行阶段产生的,它可以是任何类型,没法提前预测,所以不能在编译阶段判断类型是否正确,只能等到程序运行后,真的抛出异常了,再将异常类型和catch能处理的类型进行匹配,匹配成功的话就\"调用\"当前的catch,否则就忽略当前的catch. 总起来说catch和真正的函数调用相比多了一个「在运行阶段将实参和形参匹配」的过程. 另外需要注意的是，如果不希望catch处理异常数据，也可以将variable省略掉. 默认异常 C++语言本身或者标准库抛出的异常都是exception的子类,称为标准异常.你可以通过下面的语句来捕获所有的标准异常: try{ //可能抛出异常的语句 }catch(exception &e){ //处理异常的语句 } 之所以使用引用,是为了提高效率.如果不使用引用,就要经历一次对象拷贝(要调用拷贝构造函数)的过程. exception类位于头文件中,它被声明为: class exception{ public: exception () throw(); //构造函数 exception (const exception&) throw(); //拷贝构造函数 exception& operator= (const exception&) throw(); //运算符重载 virtual ~exception() throw(); //虚析构函数 virtual const char* what() const throw(); //虚函数 } 这里需要说明的是what()函数.what()函数返回一个能识别异常的字符串,正如它的名字'what'一样,可以粗略地告诉你这是什么异常.不过C++标准并没有规定这个字符串的格式,各个编译器的实现也不同,所以what()的返回值仅供参考. exception类的直接派生类: 异常名称 说明 logic_error 逻辑错误。 runtime_error 运行时错误。 bad_alloc 使用 new 或 new[ ] 分配内存失败时抛出的异常。 bad_typeid 使用 typeid 操作一个 NULL 指针，而且该指针是带有虚函数的类，这时抛出 bad_typeid 异常。 bad_cast 使用 dynamic_cast 转换失败时抛出的异常。 ios_base::failure io 过程中出现的异常。 bad_exception 这是个特殊的异常,如果函数的异常列表里声明了bad_exception异常,当函数内部抛出了异常列表中没有的异常时,如果调用的unexpected()函数中抛出了异常,不论什么类型,都会被替换为bad_exception类型. logic_error的派生类: 异常名称 说明 length_error 试图生成一个超出该类型最大长度的对象时抛出该异常，例如 vector 的 resize 操作。 domain_error 参数的值域错误，主要用在数学函数中，例如使用一个负值调用只能操作非负数的函数。 out_of_range 超出有效范围。 invalid_argument 参数不合适。在标准库中，当利用string对象构造 bitset 时，而 string 中的字符不是 0 或1 的时候，抛出该异常。 runtime_error的派生类: 异常名称 说明 range_error 计算结果超出了有意义的值域范围。 overflow_error 算术计算上溢。 underflow_error 算术计算下溢。 %%writefile src/C4/exception_test.cpp #include #include #include using namespace std; int main(){ string str = \"http://c.biancheng.net\"; try{ char ch1 = str[100]; cout头文件中 cout Overwriting src/C4/exception_test.cpp !g++-7 -o bin/exception_test src/C4/exception_test.cpp !./bin/exception_test \u0000 [2]out of bound! Copyright © hsz 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-07-04 00:48:14 "},"C语言风格的Cpp编程/函数.html":{"url":"C语言风格的Cpp编程/函数.html","title":"函数","keywords":"","body":"函数 函数的定义 C++语言中的函数声明和定义必须带参数和返回值类型,他的形式是这样 返回变量类型 函数名(参数类型 参数1,参数类型,参数2){ 语句组 return 返回值; } 在上一讲中我们计算开放已经使用了函数,需要注意的是C++中的函数并不像python中那么万能,它无法作为参数或者返回值,也没有匿名函数,它的作用只是写接口和一些简单抽象而已. 函数的类型 我们定义函数的类型就是它返回值的类型,别问为啥反正就是这样. 函数的调用 C++中的函数只在被调用时才会在内存中开辟出空间,当调用结束后,为函数开辟出的空间就会被回收,C++是一种非常节俭的语言,也正因为这样它才能在单片机的编程中有所作为 函数的参数传递 函数的参数可以带有默认值,默认值可以是常数,也可以是表达式. C++中的函数参数在一般情况下都是传值的(也就是复制),只有参数是引用(数组,指针)的时候才是传递的引用(数组,指针) 函数的原型与函数声明 C++语言的特点是可以先声明再定义,对于函数也一样,通常声明会放在头文件中,这部分内容会放在部分理解 在C++语言中函数的声明就是函数的原型,他的形式是: 返回变量类型 函数名(参数类型1,参数类型2); 入口函数与命令行参数输入 之前的例子中,我们接触的入口函数都是参数为空,返回为int这样的,这种形式常见于直接执行的程序,而典型命令行工具的比如像g++这样,它必然需要有一个输入参数,这种时候我们可以利用另一种形式的入口函数来实现: int main(int argc, char *argv[]){ 代码段 } argc 是入口参数的长度(几个参数) argv 则是由输入字符串组成的数组 例: 将之前的牛顿法求开根改为命令行工具,参数为第一位要开的数,第二位为开几次方根,精度规定为0.0000001,如果达不到,那允许最多迭代500次 牛顿法扩展都n次方根$ \\sqrt[k] a $的表达式为: $x_{n+1} = x_n - \\frac {x_n^k-a} {kx_n^{k-1}} = \\frac {k-1}{k} x_n + \\frac {a}{kx_n^{k-1}}$ %%writefile src/C5/Newton_method_sqrt.cpp #include #include #include const double EPS = 0.0000001; double newton_method(double a,int n){ double x=0,last_x=0; if (a>0){ x = a/n; for(int i = 0;i Overwriting src/C5/Newton_method_sqrt.cpp !g++-7 -o bin/Newton_method_sqrt src/C5/Newton_method_sqrt.cpp !bin/Newton_method_sqrt 参数错误,参数有0个,请传入要开方的数和开多少次方 !bin/Newton_method_sqrt 2 参数错误,参数有1个,请传入要开方的数和开多少次方 !bin/Newton_method_sqrt 3 3 3.000000的3次方根是1.442250 函数重载 C++中函数重载是在C++语言基础上的一大特色,不过有好也有坏.虽然C++的函数重载大大方便了编程人员,但是却有时候使用不当会引起问题,最典型的就是函数重载的二义性问题.首先我们知道C++函数重载的条件,以及C++中为什么可以函数重载,这样才可以避免C++函数重载中的二义性问题. C++函数重载的条件有三个: 函数必须位于同一作用域之中.(重载顾名思义是地位相同的两个函数,可以说两个函数是平等的,所以凭什么有的函数作用域大呢,那自然就是同一作用域) 函数名必须相同. 最重要的就是参数列表不同.参数列表不同又可以分为: 参数个数不同 参数类型不同 参数顺序不同 满足以上三条任意一条就可以 函数的返回值可以相同，也可以不同. 我们都知道,如果在c语言中定义一个或者多个同名的函数,哪怕是参数的类型,个数,顺序都不同可不可以进行重载. %%writefile src/C5/overloading_test.cpp #include #include using std::string; using std::cout; using std::endl; int My_add(int a, int b){ return (a + b); } string My_add(string a, string b){ return (a + b); } int main(){ auto m = 10; auto n = 20; auto ret = My_add(m, n); cout Overwriting src/C5/overloading_test.cpp !g++-7 -o bin/overloading_test src/C5/overloading_test.cpp !./bin/overloading_test 30 asdfgqwert 匿名函数[C++11] 在c++11中新增了对lambda函数的支持,C++11 的 lambda 表达式规范如下： [ capture ] ( params ) mutable exception attribute -> ret { body } 完整的 lambda 表达式形式 [ capture ] ( params ) -> ret { body } const类型的 lambda 表达式，该类型的表达式不能改捕获(\"capture\")列表中的值 [ capture ] ( params ) { body } 省略了返回值类型的lambda表达式，但是该lambda表达式的返回类型可以按照下列规则推演出来: 如果lambda代码块中包含了return语句，则该lambda表达式的返回类型由return语句的返回类型确定. 如果没有return语句，则类似void f(...)函数. [ capture ] { body } 省略了参数列表，类似于无参函数f(). mutable修饰符说明lambda表达式体内的代码可以修改被捕获的变量,并且可以访问被捕获对象的non-const方法 exception说明lambda表达式是否抛出异常(noexcept)，以及抛出何种异常，类似于void f() throw(X, Y) attribute用来声明属性。 另外,capture指定了在可见域范围内lambda表达式的代码内可见得外部变量的列表,具体解释如下： [a,&b] a变量以值的方式呗捕获，b以引用的方式被捕获. [this] 以值的方式捕获 this 指针. [&] 以引用的方式捕获所有的外部自动变量. [=] 以值的方式捕获所有的外部自动变量. [] 不捕获外部的任何变量. 此外params指定lambda表达式的参数。 %%writefile src/C5/lambda_test.cpp #include #include #include #include int main() { std::vector c { 1,2,3,4,5,6,7 }; int x = 5; c.erase(std::remove_if(c.begin(), c.end(), [x](int n){ return n func2 = [](int i) { return i+4; }; std::cout Overwriting src/C5/lambda_test.cpp !g++-7 -o bin/lambda_test src/C5/lambda_test.cpp !bin/lambda_test c: 5 6 7 func1: 10 func2: 10 Copyright © hsz 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-07-04 01:24:22 "},"C语言风格的Cpp编程/数组.html":{"url":"C语言风格的Cpp编程/数组.html","title":"数组","keywords":"","body":"数组 数组是一连串固定个数的同类型的数据,他们是一段连续的内存空间,数组是最高效也是最简单的数据结构,它的声明方式: 类型 变量名[元素个数]; 如果是多维数组,则可以是: 类型 变量名[元素个数][元素个数][元素个数]...; 数组可以通过下标访问内部元素,下标从0开始计数,c语言中数组的大小也是有限制的,尤其在函数内部定义的数组长度是很有限的.各个编译器不同,但一般还是够用的,但最好不要定义过大,以避免栈溢出 数组初始化 C++语言是比较原始的,声明的数组不会自动初始化,必须手动实现,以一个一维数组为例: int arrayA[5] = {0,0,0,0,0}; 而多维数组的初始化不过是将其中的元素替换为数组而已 int arrayA[5][2] = {{0,0},{0,0},{0,0},{0,0},{0,0}}; 如果不初始化而直接访问声明的数组,那么你会看到其中的元素是不知道啥玩意儿 访问数组元素 和python中的list,tuple类似,C++中访问数组的元素也是使用[i]的形式 字符串 字符串是特殊的数组,可以理解为他是由字符为元素组成的数组,处理方式和数组其实一样.定义字符串一般有这样几种方式: char str1[] = \"asdfg\"; char str2[10] = \"asdfg\"; char str3[10]; strcpy(str3,\"abcd\"); 需要注意的是字符串一旦定义就只能一个元素一个元素的修改内容了,这样很麻烦,因此一般赋值会用string.h中的strcpy函数 数组作为函数参数 一维数组作为函数参数可以不写长度 二维数组作为函数参数可以不写行数,但列数必须写 数组越界问题 C++语言算是比较原始的,数组的下标如果超过数组本身长度,编译器是可以编译的,也可以正常执行,就是结果会很诡异,因此需要避免. 用数组模拟矩阵 很多时候我们希望利用C++扩展python的矩阵运算性能,这种时候多维数组就是我们最常接触的工具了 例,计算矩阵$\\left(\\begin{matrix}1 & 2 &3\\4 & 5 & 6\\end{matrix}\\right)$中最大的元素 %%writefile src/C6/matrix_maxelem.cpp #include #include #include int main(void){ int max_elem = 0; int matrix[3][2] = {{1,4},{2,5},{3,6}}; for (int i = 0;i=max_elem) { max_elem = matrix[i][j]; } } } printf(\"max element is %d\\n\",max_elem); return 0; } Overwriting src/C6/matrix_maxelem.cpp !gcc-7 -o bin/matrix_maxelem src/C6/matrix_maxelem.cpp !bin/matrix_maxelem max element is 6 Copyright © hsz 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-07-04 00:21:08 "},"C语言风格的Cpp编程/自定义结构.html":{"url":"C语言风格的Cpp编程/自定义结构.html","title":"自定义结构","keywords":"","body":"自定义结构 枚举 枚举在python中并没有直接的实现,但C++中它是默认的一种自定义类型,它的声明关键字是enum 声明枚举类型: enum 枚举类型名 {枚举值1,枚举值2...} 定义枚举变量: 枚举类型名 变量名 = 枚举值; 需要注意的是枚举类型变量只能赋值为枚举类型声明时的枚举值,其他都会报错,而枚举值实际上是对应声明时位置对应的整形数. 看个例子: %%writefile src/C7/weekdays.cpp #include enum Weekday {MON,TUE,WED,THU,FRI,SAT,SUN}; int main(void) { enum Weekday firstday = TUE; printf(\"first day is %d\\n\",firstday ); return 0; } Overwriting src/C7/weekdays.cpp !g++-7 -o bin/weekdays src/C7/weekdays.cpp !bin/weekdays first day is 1 结构体 结构体可以理解为一组有意义的特殊成员变量的组合,比如对于小朋友,有性别,姓名,年龄身高,体重这几个维度,每个小朋友都会有这些属性.我们就可以将小朋友定义为一个结构体 结构体的定义方式为: struct 结构名{ 类型 成员变量名; 类型 成员变量名; 类型 成员变量名; }; 注意不要落了封号 我们来声明一个Child结构体 struct Child{ char name[10]; char sex[2]; int age; float weight; float height; }; 结构体变量的初始化 结构体是一种自定义类型,它和一般的类型如int呀char呀有相同的性质,不同之处是他是值是复合的,要非初始化上面的结构体结构体,只要这样: struct Child Tom = {{\"T\",\"o\",\"m\",\"\\0\"},{\"m\",\"\\0\"},8,48.5,1.5}; 也可以声明变量后再赋值 struct Child Sam; Sam.name = \"Sam\"; Sam.sex = \"m\"; Sam.age = 7; Sam.weight = 45.7; Sam.height = 1.57; 结构体变量的特性 结构体变量作为函数参数传递的时候需要注意是传值的,这和一般的类型是一样的. 如果我们的函数参数是结构体的指针变量(传引用),那么和一般的指针变量一样,需要注意. 共用体 在C语言中,还有另外一种和结构体非常类似的语法,叫做共用体(Union),它的定义格式为: union 共用体名{ 成员列表 }; 结构体和共用体的区别在于: 结构体的各个成员会占用不同的内存,互相之间没有影响; 共用体的所有成员占用同一段内存,修改一个成员会影响其余所有成员. 结构体占用的内存大于等于所有成员占用的内存的总和(成员之间可能会存在缝隙),共用体占用的内存等于最长的成员占用的内存.共用体使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来成员的值覆盖掉. %%writefile src/C7/uniontest.cpp #include union data{ int n; char ch; short m; }; int main(){ union data a; printf(\"%d, %d\\n\", sizeof(a), sizeof(union data) ); a.n = 0x40; printf(\"%X, %c, %hX\\n\", a.n, a.ch, a.m); a.ch = '9'; printf(\"%X, %c, %hX\\n\", a.n, a.ch, a.m); a.m = 0x2059; printf(\"%X, %c, %hX\\n\", a.n, a.ch, a.m); a.n = 0x3E25AD54; printf(\"%X, %c, %hX\\n\", a.n, a.ch, a.m); return 0; } Overwriting src/C7/uniontest.cpp !g++-7 -o bin/uniontest src/C7/uniontest.cpp !bin/uniontest 4, 4 40, @, 40 39, 9, 39 2059, Y, 2059 3E25AD54, T, AD54 自定义类型操作 我们可以使用typedef关键字将结构体或者枚举,或者其他任何的类型取个别名,这样可以更加方便使用 typedef 原类型 类型别名; 例子: %%writefile src/C7/child.cpp #include #include typedef struct{ char name[10]; char sex[2]; int age; float weight; float height; } Child; int main(void) { Child Tom = {\"Tom\",\"m\",8,48.5,1.5}; Child Sam; strcpy(Sam.name,\"Sam\"); strcpy(Sam.sex,\"m\"); Sam.age = 7; Sam.weight = 45.7; Sam.height = 1.57; printf(\"%s 身高%fm\\n\",Tom.name,Tom.height); printf(\"%s 体重%fkg\\n\",Sam.name,Sam.weight); return 0; } Overwriting src/C7/child.cpp !g++-7 -o bin/child src/C7/child.cpp !bin/child Tom 身高1.500000m Sam 体重45.700001kg Copyright © hsz 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-07-04 00:21:36 "},"C语言风格的Cpp编程/指针与引用.html":{"url":"C语言风格的Cpp编程/指针与引用.html","title":"指针与引用","keywords":"","body":"指针 什么是指针?这个在python中可没有. 上语文课的时候,老师最长说的话是不是\"请将课本翻到xxx页\"?在那一页上有课上的内容,我们要看的是内容,但却使用页码标记内容,这就是指针的核心思想了. 指针是变量的地址,与之对应的是内存空间的标记,一本有页码的笔记本,在某一页上可以写着日记,也可以画着画,它只是被标记的空间而已,内容取决于需要. 变量的三要素 一个变量必然有三样内容: 地址,内存空间的标记 值,存放的具体内容 变量名,在程序中用于标记变量的符号 在多数语言中还要加上一个类型,用以让编译器或者解释器知道该如何处理这个变量 取地址符&和指针运算符* 要取到变量的地址,只用在变量前使用&就可以得到了 如果我们想通过变量的地址获取它的值,那只要在地址前使用*就可以了 指针变量 存储变量地址的变量就是指针变量,他的声明形式很简单 类型* 变量名 这样变量中就是存的地址了,而要取出该地址中的值,同样的只要使用指针运算符即可 指针运算 指针也就是地址,在C++中表现为可以运算的正整数数值,因此,它和int,long之类一样,是可以运算的,所用的运算符也是通常的运算符. 指针与数组 数组变量实际上就是数组第一个元素的指针,因此要取第一个元素的值也可以使用指针运算符,其后面的元素也只要在数组变量的基础上加上长度后再做指针运算即可,不过最安全最直观的方式还是用下标 函数与指针 C++语言中的精髓之一就在于函数与指针互动了 指针作为参数 指针作为参数就可以理解为所谓的传引用,以地址作为参数,函数的操作会影响引用的内容,这样几百年函数的内存被回收,操作的结果也会生效 最典型的,交换两个变量的值 %%writefile src/C8/exchange.cpp #include void exchange(int* ptr_a,int* ptr_b){ int temp; temp = *ptr_a; *ptr_a = *ptr_b; *ptr_b = temp; return; } int main(void) { int a = 78,b = 28; printf(\"before exchange a=%d,b=%d\\n\",a,b); exchange(&a,&b); printf(\"after exchange a=%d,b=%d\\n\",a,b); return 0; } Overwriting src/C8/exchange.cpp !g++-7 -o bin/exchange src/C8/exchange.cpp !bin/exchange before exchange a=78,b=28 after exchange a=28,b=78 指针参数的保护 我们如果传递的是指针,那么就意味着内容是可变的,于是就又被篡改的危险,但如果我们希望不被篡改,那么最好的办法就是将这个指针引用的内容在函数中保护起来,这就用到了const参数了,这个被称作常量指针 %%writefile src/C8/safe_ptr.cpp #include int main(void) { const int a = 78,b = 28; int c = 18; const int* p = &a; printf(\"p:%d\\n\",*p); //*p = 58//报错,*p无法重新复制 p = &b;//可以给p重新复制, printf(\"p:%d\\n\",*p); return 0; } Overwriting src/C8/safe_ptr.cpp !g++-7 -o bin/safe_ptr src/C8/safe_ptr.cpp !bin/safe_ptr p:78 p:28 指针作为返回值(指针函数) 如果要一个函数返回指针,那么就像下面这么定义 int *f(int，int); 指针作为返回值就意味着可以返回复杂的数据结构以及数组了 函数指针 函数指针是指指向函数的指针,事实上函数一样也是一种储存在内存中的数据,如果要做一定的抽象,函数指针是必不可少的.定义一个函数指针如下: int (*f)(int,int); 形式上 指针函数和函数指针很像,也就是一对括号的不同而已,但差异非常大,指针函数是定义的函数,而函数指针是定义的指针 函数常量指针 C++中事实上并没有所谓常量函数,但我们确实可以指定指向函数的指针,或者函数的返回值指针,各种各样的指针为常数 int (*const func)(int) = some_func;//指向函数的常量指针,通常会接一个初始化 void const *(*func)(int);//指定返回值为常量指针 void const *(*const func)(int) = func;//指向函数的常量指针,并指定返回值为常量指针 模拟高阶函数 对于函数式编程而言,高阶函数是一切的基础,学过python的一定不会陌生,C++中如何实现高阶函数呢 函数作为参数 求a到b间整数的和 int sum_int(int a,int b){ return a>b ?0:a + sum_int((a+1),b); } 求a到b间的整数的立方和: int cube(int x){ return (int)pow(x,3); } int sum_func(int a,int b,int (*func)(int)){ return a>b ?0:(*func)(a) + sum_func((a+1),b,func); } 求: 11⋅3+15⋅7+19⋅11+⋯ \\frac {1}{1 \\cdot 3} + \\frac {1}{5 \\cdot 7} + \\frac {1}{9 \\cdot 11} +\\cdots​1⋅3​​1​​+​5⋅7​​1​​+​9⋅11​​1​​+⋯ 它会非常缓慢地收敛到π8\\frac {\\pi}{8}​8​​π​​ float sum_func_stp(int a,int b,float (*const func)(int) , int (*const step)(int)){ return a>b ?0:(*func)(a) + sum_func_stp((*step)(a),b,func,step); } float func(int x){ return 1.0/(x*(x+2)); } int stp(int x){ return x+4; } float sum_pi(int a,int b){ float (*const ptr_func)(int) = func; int (*const ptr_stp)(int) = stp; return sum_func_stp(a,b,ptr_func,ptr_stp); } 完整的高阶函数例子: %%writefile src/C8/high_order_func.cpp #include #include int sum_int(int a,int b){ return a>b ?0:a + sum_int((a+1),b); } int cube(int x){ return (int)pow(x,3); } int sum_func(int a,int b,int (*const func)(int)){ return a>b ?0:(*func)(a) + sum_func((a+1),b,func); } int sum_cube(int a,int b){ int (*const ptr_func)(int) = cube; return sum_func(a,b,ptr_func); } float sum_func_stp(int a,int b,float (*const func)(int) , int (*const step)(int)){ return a>b ?0:(*func)(a) + sum_func_stp((*step)(a),b,func,step); } float func(int x){ return 1.0/(x*(x+2)); } int stp(int x){ return x+4; } float sum_pi(int a,int b){ float (*const ptr_func)(int) = func; int (*const ptr_stp)(int) = stp; return sum_func_stp(a,b,ptr_func,ptr_stp); } int main(void) { int top = 5,bottom = 1; printf(\"range(%d,%d) = %d\\n\", bottom,top,sum_int(bottom,top)); printf(\"range(%d,%d)的立方和为%d\\n\", bottom,top,sum_cube(bottom,top)); printf(\"sum_pi(%d,%d)为%f\\n\", bottom,top,sum_pi(bottom,top)); } Overwriting src/C8/high_order_func.cpp !g++-7 -o bin/high_order_func src/C8/high_order_func.cpp !bin/high_order_func range(1,5) = 15 range(1,5)的立方和为225 sum_pi(1,5)为0.361905 闭包 标准C++中是不允许在函数体内定义函数的,不过g++和clang都有相应扩展,这边只讲标准C++,因此也就不多介绍了,有兴趣的可以自己百度. 空指针 C++中可以用NULL为任意指针变量赋值,他的意义是指针为空,或者说,指针变量没有指向任何地址 nullptr[C++11] nullptr是为了解决原来C++中NULL的二义性问题而引进的一种新的类型,因为NULL实际上代表的是0. %%writefile src/C8/nullptr_test.cpp #include using std::cout; using std::endl; void F(int a){ cout Overwriting src/C8/nullptr_test.cpp void指针 void指针很特殊,它有这样的性质: void指针可以指向任何数据类型,如果要将void指针赋给其他类型指针，则需要强制类型转换如：pint= (int *)pvoid 可以用任何类型的指针对void指针进行赋值和初始化 void指针无法进行指针操作 void* p就是一个典型的void指针,一般void指针用在内存操作, 因此void指针常用在: 内存操作 定义函数时,如果函数的参数可以是任意类型指针，那么应声明其参数为void* 作为指向函数的指针 引用(reference) 引用就是某一变量(目标)的一个别名,对引用的操作与对变量直接操作完全一样. 引用的声明方法: 类型标识符 &引用名=目标变量名； 如下,定义引用ra,它是变量a的引用,即别名: int a; int &ra=a; &在此不是求地址运算符,而是起标识作用. 类型标识符是指目标变量的类型. 声明引用时,必须同时对其进行初始化. 引用声明完毕后,相当于目标变量有两个名称即该目标原名称和引用名,且不能再把该引用名作为其他变量名的别名. 声明一个引用,不是新定义了一个变量,它只表示该引用名是目标变量名的一个别名,它本身不是一种数据类型,因此引用本身不占存储单元,系统也不给引用分配存储单元.故:对引用求地址,就是对目标变量求地址.&ra与&a相等. 不能建立数组的引用.因为数组是一个由若干个元素所组成的集合,所以无法建立一个数组的别名。 %%writefile src/C8/reference_test.cpp #include using std::cout; using std::endl; int main(){ int a=5; int &b=a; b=6; cout Overwriting src/C8/reference_test.cpp !g++-7 -o bin/reference_test src/C8/reference_test.cpp !./bin/reference_test a=6,b=6 a=7,b=7 Copyright © hsz 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-07-04 00:19:55 "},"C语言风格的Cpp编程/头文件与多文件编译.html":{"url":"C语言风格的Cpp编程/头文件与多文件编译.html","title":"头文件与多文件编译","keywords":"","body":"头文件与多文件编译 C++语言的模块化编程使用的是组合的方式.头文件用于定义和声明,源文件用于实现方法,一般来说头文件以.h作为扩展名,并且名字与源文件保持一致,比如我们有个头文件叫test.h,那么 为了避免重复引入,会在头文件中写上 #ifndef _TEST_H #define _TEST_H//一般是文件名的大写 头文件结尾写上一行 要引入的头文件 要定义的类型 要声明的函数 ... #endif 这样头文件就只会被导入一次了 而与之对应的源文件,我们只要#include \"test.h\"即可 我们举个例子,以二维向量计算作为要实现的功能,其中包括三个源文件: binary_vector.h 定义二元向量结构 unary_operator.cpp 一元运算,包括求向量的模 binary_operator.cpp 二元运算,包括求加和内积 以及一个测试文件 test.cpp %%writefile src/C9/binary_vector.h #ifndef BINARY_VECTOR_H #define BINARY_VECTOR_H//一般是文件名的大写 头文件结尾写上一行 typedef struct { float x; float y; } BINARY_VECTOR; #endif Overwriting src/C9/binary_vector.h %%writefile src/C9/unary_operator.h #ifndef UNARY_OPERATOR_H #define UNARY_OPERATOR_H//一般是文件名的大写 头文件结尾写上一行 #include \"binary_vector.h\" #include float mod(BINARY_VECTOR); #endif Overwriting src/C9/unary_operator.h %%writefile src/C9/unary_operator.cpp #include \"unary_operator.h\" float mod(BINARY_VECTOR a){ float result = sqrt(a.x*a.x+a.y*a.y); return result; } Overwriting src/C9/unary_operator.cpp %%writefile src/C9/binary_operator.h #ifndef BINARY_OPERATOR_H #define BINARY_OPERATOR_H//一般是文件名的大写 头文件结尾写上一行 #include \"binary_vector.h\" BINARY_VECTOR add(BINARY_VECTOR,BINARY_VECTOR); float mul(BINARY_VECTOR,BINARY_VECTOR); #endif Overwriting src/C9/binary_operator.h %%writefile src/C9/binary_operator.cpp #include \"binary_operator.h\" BINARY_VECTOR add(BINARY_VECTOR a,BINARY_VECTOR b){ BINARY_VECTOR result = {a.x+b.x,a.y+b.y}; return result; } float mul(BINARY_VECTOR a,BINARY_VECTOR b){ float result = a.x*b.x+a.y*b.y; return result; } Overwriting src/C9/binary_operator.cpp %%writefile src/C9/test.cpp #include #include \"binary_vector.h\" #include \"binary_operator.h\" #include \"unary_operator.h\" int main(void){ BINARY_VECTOR A = {1,2},B = {3,4}; printf(\"mod(A)=%f\\n\",mod(A)); printf(\"mod(B)=%f\\n\",mod(B)); printf(\"mul(A,B)=%f\\n\",mul(A,B)); BINARY_VECTOR result = add(A,B); printf(\"add(A,B)=\\n\",result.x,result.y); } Overwriting src/C9/test.cpp 预编译: !g++-7 -o bin/test src/C9/*.cpp !bin/test mod(A)=2.236068 mod(B)=5.000000 mul(A,B)=11.000000 add(A,B)= Copyright © hsz 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-07-04 00:19:08 "},"C语言风格的Cpp编程/静态连接库和动态链接库.html":{"url":"C语言风格的Cpp编程/静态连接库和动态链接库.html","title":"静态连接库和动态链接库","keywords":"","body":"静态连接库和动态链接库 静态链接库与动态链接库都是共享代码的方式,在linux中,动态链接库通常用.so为后缀，而静态链接库用.a为后缀。 静态链接库 当要使用静态链接库时，连接器会找出程序所需的函数，然后将它们拷贝到执行文件，由于这种拷贝是完整的，所以一旦连接成功，静态程序库也就不再需要了。 静态链接库的优点 代码装载速度快，执行速度略比动态链接库快； 只需保证在开发者的计算机中有正确的.LIB文件，在以二进制形式发布程序时不需考虑在用户的计算机上.LIB文件是否存在及版本问题，可避免DLL地狱等问题。 不足之处 使用静态链接生成的可执行文件体积较大，包含相同的公共代码，造成浪费 创建静态库 我们还是以之前的二维向量作为例子,代码请看'头文件与多文件编译'中的相关代码 创建链接文件 .o文件的意思是连接对象,他是编译静态库要用到的一个中间形态,使用gcc编译源文件成为连接对象文件 %%writefile src/C10/source/binary_operator.h #ifndef BINARY_OPERATOR_H #define BINARY_OPERATOR_H//一般是文件名的大写 头文件结尾写上一行 #include \"binary_vector.h\" BINARY_VECTOR add(BINARY_VECTOR,BINARY_VECTOR); float mul(BINARY_VECTOR,BINARY_VECTOR); #endif Overwriting src/C10/source/binary_operator.h %%writefile src/C10/source/binary_operator.cpp #include \"binary_operator.h\" BINARY_VECTOR add(BINARY_VECTOR a,BINARY_VECTOR b){ BINARY_VECTOR result = {a.x+b.x,a.y+b.y}; return result; } float mul(BINARY_VECTOR a,BINARY_VECTOR b){ float result = a.x*b.x+a.y*b.y; return result; } Overwriting src/C10/source/binary_operator.cpp !g++-7 -c src/C10/source/binary_operator.cpp -o lib/C10/binary_operator.o %%writefile src/C10/source/unary_operator.h #ifndef UNARY_OPERATOR_H #define UNARY_OPERATOR_H//一般是文件名的大写 头文件结尾写上一行 #include \"binary_vector.h\" #include float mod(BINARY_VECTOR); #endif Overwriting src/C10/source/unary_operator.h %%writefile src/C10/source/unary_operator.cpp #include \"unary_operator.h\" float mod(BINARY_VECTOR a){ float result = sqrt(a.x*a.x+a.y*a.y); return result; } Overwriting src/C10/source/unary_operator.cpp !g++-7 -c src/C10/source/unary_operator.cpp -o lib/C10/unary_operator.o 生成静态库文件.a 一般我们用ar（archive，归档的意思）把多个目标文件集合起来生成.a文件 !ar -r lib/C10/libbvector.a lib/C10/binary_operator.o lib/C10/unary_operator.o 调用静态库 我们需要为静态库编写一个头文件用以声明库中的内容 %%writefile src/C10/source/binary_vector.h #ifndef BINARY_VECTOR_H #define BINARY_VECTOR_H//一般是文件名的大写 头文件结尾写上一行 typedef struct { float x; float y; } BINARY_VECTOR; #endif Overwriting src/C10/source/binary_vector.h 然后编写一个测试文件(静态库动态库测试文件代码相同) %%writefile src/C10/sll/test.cpp #include #include \"bvector.h\" int main(void){ BINARY_VECTOR A = {1,2},B = {3,4}; printf(\"mod(A)=%f\\n\",mod(A)); printf(\"mod(B)=%f\\n\",mod(B)); printf(\"mul(A,B)=%f\\n\",mul(A,B)); BINARY_VECTOR result = add(A,B); printf(\"add(A,B)=\\n\",result.x,result.y); } Overwriting src/C10/sll/test.cpp 使用g++ 编译我们的测试文件 !g++-7 src/C10/sll/test.cpp -L lib/C10 -l bvector -I lib/C10 -o bin/slltest !bin/slltest mod(A)=2.236068 mod(B)=5.000000 mul(A,B)=11.000000 add(A,B)= -L 选项告诉编译器去哪里找需要的库文件 -l -lbvector告诉编译器要链接libbvector库 -I 选项告诉去哪个文件夹下找头文件 动态链接库 某个程序在运行中要调用某个动态链接库函数的时候，操作系统首先会查看所有正在运行的程序，看在内存里是否已有此库函数的拷贝了。如果有，则让其共享那一个拷贝；只有没有才链接载入。在程序运行的时候，被调用的动态链接库函数被安置在内存的某个地方，所有调用它的程序将指向这个代码段。因此，这些代码必须使用相对地址，而不是绝对地址。在编译的时候，我们需要告诉编译器，这些对象文件是用来做动态链接库的，所以要用地址不无关代码（Position Independent Code (PIC))。 注意：Linux下进行连接的缺省操作是首先连接动态库，也就是说，如果同时存在静态和动态库，不特别指定的话，将与动态库相连接。 动态链接库的优点 更加节省内存并减少页面交换； 动态链接文件与可执行文件独立，只要输出接口不变（即名称、参数、返回值类型和调用约定不变），更换动态链接文件不会对可执行文件造成任何影响，因而极大地提高了可维护性和可扩展性； 不同编程语言编写的程序只要按照函数调用约定就可以调用同一个动态函数； 适用于大规模的软件开发，使开发过程独立、耦合度小，便于不同开发者和开发组织之间进行开发和测试。 不足之处 使用动态链接库的应用程序不是自完备的，它依赖的动态模块也要存在，如果使用载入时动态链接，程序启动时发现动态模块不存在，系统将终止程序并给出错误信息。而使用运行时动态链接，系统不会终止，但由于动态库中的导出函数不可用，程序会加载失败 速度比静态链接慢。当某个模块更新后，如果新模块与旧的模块不兼容，那么那些需要该模块才能运行的软件，统统撕掉。 编译动态链接库 !g++-7 src/C10/source/binary_operator.cpp src/C10/source/unary_operator.cpp -fPIC -shared -o lib/C10/libbvct.so 使用g++编译我们的测试文件 %%writefile src/C10/dll/test.cpp #include #include \"bvector.h\" int main(void){ BINARY_VECTOR A = {1,2},B = {3,4}; printf(\"mod(A)=%f\\n\",mod(A)); printf(\"mod(B)=%f\\n\",mod(B)); printf(\"mul(A,B)=%f\\n\",mul(A,B)); BINARY_VECTOR result = add(A,B); printf(\"add(A,B)=\\n\",result.x,result.y); } Overwriting src/C10/dll/test.cpp !g++-7 src/C10/dll/test.cpp -L lib/C10 -l bvct -I lib/C10 -o bin/dlltest !bin/dlltest mod(A)=2.236068 mod(B)=5.000000 mul(A,B)=11.000000 add(A,B)= Copyright © hsz 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-07-04 00:23:14 "}}