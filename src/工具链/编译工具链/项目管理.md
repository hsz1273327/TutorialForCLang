# 项目管理

C/C++的项目管理可以称得上混乱,毕竟是两门相当古老的编程语言,可以说打从一开始就没考虑项目管理的问题,C/C++非常难以上手很大程度上也是拜这所赐.

我们可以将项目管理拆分为两个部分:

+ 包分发:即如何让别人可以找到你的包

+ 包调用:如何让程序可以使用找到的包.

## 包分发

包分发可以理解为3个方面的基本功能

+ 包的元数据管理,即发布者如何描述包的信息,让别人可以识别使用.以python为例在python中这个功能是由`setup.cfg/setup.py`完成的
+ 分发平台,即包发布后放在什么地方,以python为例在python中这个功能是由`pypi`平台或者自己搭建的pypi实例完成的.
+ 分发形式,即上传下载的内容如何编码解码,以python为例在python中这个功能是通常由zip包实现的(wheel和egg可以理解为带有元数据的zip包)

不用看C/C++在这三个方面都没有统一的方案.
传统c/c++的元数据管理就是依靠命名--C依靠所有函数和结构体等统一使用相同的前缀,C++则使用命名空间(本质上和c一样)而其他比如包的版本,说明等信息基本也就是靠说明文档和下载时的路径了;

传统c/c++包的分发平台通常就是操作系统发行版的包管理工具,比如ubuntu/debian的apt,alpine的apk等,他们安装好后会将包和头文件放在固定位置(/usr/lib,/usr/local/lib,/usr/include,/usr/local/include等).这些也是你在这些平台上安装编译工具后默认的依赖搜索路径.这种方式倒是很方便调用,但要管理依赖的版本或者要使用平台上没有的包又或者要控制包的分发范围(企业内部包管理)就比较尴尬了;

c/c++包的分发模式基本就两种:

+ 源码分发,这是golang的策略,C/C++的编译速度是很慢的,这条路因此相当难走
+ 二进制分发,就是apt,apkw这些包管理工具的默认分发形式,二进制分发对平台会有相当强的依赖,因此往往不能通用
+ 混合分发,像homebrew,它会先尝试下载二进制的分发版本,如果不行则会下载源码进行编译,多数非系统级分发方案都是这种模式

## 包调用

包调用则可以分为大致几个方面

1. 环境隔离,即让项目的依赖不会影响其他程序和项目,以python为例在python中这个功能是由python的标准库`venv`实现的
2. 包查询和包下载,即让使用者可以快速找到需要的包并下载下来作为依赖,,以python为例在python中这个功能是由`pip`实现的
3. 依赖管理,即让这个包移植的时候可以直接通过依赖管理工具快速部署依赖,这个功能是由`pip freeze`和`pip install -r`实现的

不用看C/C++在这三个方面也没有统一的方案.

使用apt,apk这样的操作系统相关的依赖管理系统可以在包查询和包下载上非常方便,但这必定是全局安装的,因此完全没有环境隔离一说,如果要环境隔离,那就得每个依赖的项目下载源码到本地现编译,然后使用gcc/g++连接.

在编译部分我们就已经介绍过了c/c++的包调用就2种方式

+ 源码方式
+ 库方式(动态链接库/静态链接库)

但我们前面两节也已经演示过如何引用已经存在的包,即便使用makefile来定制编译过程这个纯手动档的依赖管理也是极其繁琐的.

## 通用的解决方案

很遗憾没有!毕竟历史太长了,很多遗留代码可能早已没人维护,但一些成年老程序依然在用.对于C/C++这种老古董来说历史包袱和历史遗产都是不得不面对的问题.但也不是完全无解,一个相对没那么痛苦的方案是使用[cmake](https://cmake.org/)配合git服务来做项目管理.大体的思路是:

使用cmake描述项目和安装依赖,使用git服务保存项目源码.通用常用的依赖和工具依靠操作系统的包管理工具,而专用的希望做环境隔离的依赖则使用cmake从源码安装.

这个方案的好处是:

1. cmake相对是铺的比较广的工具,github上的c/c++项目几乎都由cmake支持
2. cmake是不少重要工具的指定编译辅助工具
3. cmake本身是个嫁接工具,它的后端可以是makefile,可以是nijia等
4. cmake提供了一定的跨平台能力和交叉编译能力

当然缺点也有:

1. cmake语法反人类,非常不直观
2. cmake的操作几乎都是黑盒,很难debug

但是没办法其他的方案相比而言还不如它因此本文也主讲这种方式

## 使用cmake管理项目

Cmake本质上也不提供流程化编译的功能,他其实是用来生成不同平台的不同编译工具的配置文件的,这些不同编译工具通常被称为其"后端",由于cmake只针对C/C++/Fortain/CUDA和汇编语言,所以会有一些额外的细化配置.

本文已最新版本的`cmake 3.20`为基准需要注意cmake的接口并不算稳定,因此本文的例子不保证向后兼容.

### cmake的安装

cmake目前只支持x86-64平台下的windows,linux,macos系统以及arm平台下的linux和macos系统,基本覆盖了主流平台.同时它也提供了源码可以尝试在其他平台下编译安装.

#### 在linux下

在linux下我们一般都需要额外安装cmake来使用,linux下可以直接从操作系统的包管理工具种安装

+ `debian/ubuntu`: `apt install -y --no-install-recommends cmake`(国内最好先使用`sed -i 's/deb.debian.org/mirrors.ustc.edu.cn/g' /etc/apt/sources.list`换源)
+ `alpine`: `apk add cmake`(国内最好先使用`sed -i 's/dl-cdn.alpinelinux.org/mirrors.ustc.edu.cn/g' /etc/apk/repositories`换源)

这种方式好处是方便快速,但坏处是一般版本较低,比如`debian buster`上版本为3.13,因此更多的我们还是选择下载安装

在[cmake的下载页](https://cmake.org/)直接下载对应平台的`.sh`文件,然后使用命令`./cmake-xxxx.sh --skip-license --prefix=/安装/目录`即可,安装好后会是一个包含`/bin`的文件夹,将这个文件夹加入环境变量`PATH`中即可.

#### 在windows下

windows下也是在上面的下载页,下载`.msi`后缀的文件,然后双击安装即可.安装完后同样将目录下的`/bin`的文件夹加入环境变量`PATH`

#### 在macos下

mac下比较推荐使用homebrew安装(`brew install cmake`)

### cmake的使用流程

cmake的使用流程有3步:

1. 定义`CmakeLists.txt`文件用于描述项目信息,编译流程等
2. 执行`cmake [options] .`为后端生成配置文件
3. 用后端编译项目

cmake默认的后端是makefile,但我们也可以通过`-G`设置后端,常用的后端还有[Ninja](https://github.com/ninja-build/ninja/releases)和`MinGW Makefiles`等.实际上一旦cmake写好后生成什么后端并不重要,生成了配置文件后只要执行它就可以了.

#### makefile作为后端

+ 编译

    ```bash
    make [VERBOSE=1]
    ```

+ 安装(如果`CmakeLists.txt`中有配置`install`命令的话)

    ```bash
    make install
    ```

+ 测试(如果`CmakeLists.txt`中有配置`add_test`命令的话)

    ```bash
    make test
    ```

+ 清除编译过程中的中间结果

    ```bash
    make clean
    ```

#### ninja作为后端

+ 编译

    ```bash
    ninja
    ```

+ 安装(如果`CmakeLists.txt`中有配置`install`命令的话)

    ```bash
    ninja install
    ```

+ 测试(如果`CmakeLists.txt`中有配置`add_test`命令的话)

    ```bash
    ninja test
    ```

## `CmakeLists.txt`配置语法

Cmake使用指令式的配置方式,基本形式就是`cmake_minimum_required (VERSION 2.8)`这样,`()`外面的是命令,里面的是内容.具体有哪些命令可以查看[官方文档](https://cmake.org/cmake/help/v3.20/command/project.html)

Cmake配置有两种风格:

+ 传统风格(directory风格),以大量设置变量的值为特征,基本属于过程式的配置风格
+ 现代风格(Modern Cmake),以Target为导向,有一定的面相对象特征

本文将只介绍现代风格的Cmake配置.

`CmakeLists.txt`是每个项目下的配置文件,它用于描述

+ 项目的元信息
+ 项目的依赖描述[可选]
+ 项目的编译配置
+ 项目的测试行为配置[可选]
+ 项目的安装行为配置[可选]

通常上面三部分是按顺序写的,依赖描述部分根据是否有依赖选择要不要有.

### 元信息设置

cmake中的元信息包括3部分

+ `cmake_minimum_required`：指定运行此配置文件所需的CMake的最低版本

+ `project(<PROJECT-NAME> [VERSION <version>] [DESCRIPTION <project-description-string>] [HOMEPAGE_URL <url-string>] [LANGUAGES <language-name>...] [])`：描述项目的基本信息.

+ 设置全局的平台信息和编译器信息,这些设置我们使用`SET(变量 值)`的形式进行改变,我们也可以通过`${变量}`直接获取想要知道的变量然后通过`message`指令打印出来,cmake自带一部分预定义变量,范围可以在[这个页面查看到说明](https://cmake.org/cmake/help/v3.20/manual/cmake-variables.7.html).

#### 变量

变量是cmake传统风格中最重要的部分,但在Modern Cmake中它的地位已经下降了,通常在Modern Cmake中变量只有如下4个用处:

+ 设置一些全局变量用于改变cmake编译行为,也就是上面介绍的部分,比较重要的设置项有:
    + `SET(CMAKE_C_COMPILER "/home/public/local/bin/gcc")`:指定c语言编译器
    + `SET(CMAKE_CXX_COMPILER "/home/public/local/bin/g++")`:指定c++语言编译器
    + `CMAKE_BUILD_TYPE`: 指定生成 debug 版和 release 版的后端配置
+ 获取一些全局变量,根据预设值结合`if`语句做分支处理.这部分基本是一些操作系统的元数据
    + `CMAKE_MAJOR_VERSION`,CMAKE 主版本号,比如 2.4.6 中的 2
    + `CMAKE_MINOR_VERSION`,CMAKE 次版本号,比如 2.4.6 中的 4
    + `CMAKE_PATCH_VERSION`,CMAKE 补丁等级,比如 2.4.6 中的 6
    + `CMAKE_SYSTEM`,系统名称,比如 Linux-2.6.22
    + `CMAKE_SYSTEM_NAME`,不包含版本的系统名,比如 Linux
    + `CMAKE_SYSTEM_VERSION`,系统版本,比如 2.6.22
    + `CMAKE_SYSTEM_PROCESSOR`,处理器名称,比如 i686.
    + `UNIX`,在所有的类 UNIX 平台为 TRUE,包括 OS X 和 cygwin
    + `WIN32`,在所有的 win32 平台为 TRUE,包括 cygwin

+ 使用全局变量和自定义变量通过字符串组合构造新的值,这部分常用的有如下几个:
    + `PROJECT_NAME`返回通过 PROJECT 指令定义的项目名称.
    + `CMAKE_BINARY_DIR`/`PROJECT_BINARY_DIR`/`<projectname>_BINARY_DIR`如果是`in-source`编译指的就是工程顶层目录;如果是`out-of-source`编译,指的是工程编译发生的目录.
    + `CMAKE_SOURCE_DIR`/`PROJECT_SOURCE_DIR`/`<projectname>_SOURCE_DIR`这三个变量指代的内容是一致的,不论采用何种编译方式,都是工程顶层目录
    + `CMAKE_CURRENT_SOURCE_DIR`指的是当前处理的文件夹路径
    + `CMAKE_CURRRENT_BINARY_DIR`如果是`in-source`编译,它跟`CMAKE_CURRENT_SOURCE_DIR`一致,如果是`out-of-source`编译,他指的是`target`编译目录
    + `CMAKE_CURRENT_LIST_DIR`,当前`CMakeLists.txt`所在的路径,注意它可以被`include`指令改变,通常我们都用它

+ 用于承接外部赋值的变量,我们可以使用`option`命令定义变量可以外部赋值,cmake也提供了几个变量可以直接从外部赋值
    + `CMAKE_BUILD_TYPE`: 指定生成 debug 版和 release 版的后端配置
    + `CMAKE_INSTALL_PREFIX`: 在cmake生成后端时通过设置它可以改变安装到的目标目录,不设置默认安装到`/usr/local/`下.

#### 环境变量

cmake也支持设置和获取系统的环境变量,设置使用`SET(ENV{变量名} 值)`,获取则使用`$ENV{NAME}`指令

#### 从外部赋值变量

cmake可以通过`option(<variable> "<help_text>" [value])`从外部赋值变量,也就是说构造简易的命令行工具.这个指令对已经定义了的变量无效.

从外部赋值了的变量可以正常使用,通常我们会在使用`option`时设置默认值防止变量为空.

#### 打印消息

`message`指令类似python中的logger,可以用于打印消息,其完整语法为:

```cmake
message([<mode>|<checkState>] "message text" ...)
```

`<mode>`的范围包括:

+ `FATAL_ERROR`error级别的log信息,同时抛出错误
+ `SEND_ERROR`error级别的log信息,但不抛出错误
+ `WARNING`警告级别log
+ `NOTICE`等同于不填直接写消息,相当于一般log工具中的info级别信息
+ `DEBUG`相当于一般log工具中的debug级别信息
+ `STATUS`用户可能会感兴趣的信息,一般表示特定状态,因此消息应该简短

`<checkState>`的含义则和上面不一样,它用于描述校验变量状态上下文的状态,`<checkState>`的取值只有三种:

+ `CHECK_START`描述校验上下文开始
+ `CHECK_PASS`描述校验通过
+ `CHECK_FAIL`描述校验不通过

> 是下面例子的一个规范化写法

```cmake
message(STATUS "Looking for someheader.h")
if(checkSuccess)
  message(STATUS "Looking for someheader.h - found")
else()
  message(STATUS "Looking for someheader.h - not found")
endif()
```

上面的例子可以写成

```cmake
message(CHECK_START "Looking for someheader.h")
if(checkSuccess)
  message(CHECK_PASS "Looking for someheader.h - found")
else()
  message(CHECK_FAIL "Looking for someheader.h - not found")
endif()
```

如果要还没有执行`CHECK_FAIL`或`CHECK_PASS`就要重置上下文,则可以使用`unset(missingComponents)`来实现

#### 条件分支

cmake使用`if`指令设置条件分支.其条件语句(谓词)语法可以看[这个页面](https://cmake.org/cmake/help/v3.20/command/if.html#command:if)

我们通常这样用:

+ 条件判断

    ```cmake
    IF(<condition>)
        # THEN section.
        COMMAND1(ARGS ...)
        COMMAND2(ARGS ...)
    ENDIF()
    ```

+ 双分支

    ```cmake
    IF(<condition>)
        # THEN section.
        COMMAND1(ARGS ...)
        COMMAND2(ARGS ...)
        ...
    ELSE()
        # ELSE section.
        COMMAND1(ARGS ...)
        COMMAND2(ARGS ...)
        ...
    ENDIF()
    ```

+ 多分支

    ```cmake
    IF(<condition1>)
        # THEN section.
        COMMAND1(ARGS ...)
        COMMAND2(ARGS ...)
        ...
    ELSEIF(<condition2>)
        # ELSE section.
        COMMAND1(ARGS ...)
        COMMAND2(ARGS ...)
        ...
    ELSEIF(<condition3>)
        # ELSE section.
        COMMAND1(ARGS ...)
        COMMAND2(ARGS ...)
        ...
    ELSE()
        # ELSE section.
        COMMAND1(ARGS ...)
        COMMAND2(ARGS ...)
        ...
    ENDIF()
    ```

#### 循环

cmake有两种循环:

+ WHILE指令,可用`break()`和`continue()`退出循环,其语义和一般编程语言中一致

    基本语法为:

    ```cmake
    WHILE(condition)
      COMMAND1(ARGS ...)
      COMMAND2(ARGS ...)
      ...
    ENDWHILE(condition)
    ```

+ FOREACH

    FOREACH 指令的使用方法有两种形式:

    1. 列表

        ```cmake
        FOREACH(loop_var arg1 arg2 ...)
        COMMAND1(ARGS ...)
        COMMAND2(ARGS ...)
        ...
        ENDFOREACH(loop_var)
        ```

    2. 范围(类似pythonz中的for xxx in range(x))

        ```cmake
        FOREACH(loop_var RANGE oop_var RANGE start stop [step])
        ENDFOREACH(loop_var)
        ```

### 项目的编译配置

每一个项目都必然有至少一个输出,通常我们会控制一个项目默认只有一个输出,输出的内容分为两大类:

+ 可执行文件[add_executable](https://cmake.org/cmake/help/v3.20/command/add_executable.html)
+ 包[add_library](https://cmake.org/cmake/help/v3.20/command/add_library.html),需要注意此处包的概念和链接库并不一致,包包含链接库

我们称要编译出来的内容为`Target`,cmake中配置一个目标的流程大致如下:

1. 申明目标(`add_executable`/`add_library`)
2. 为目标配置编译器选项([target_compile_options](https://cmake.org/cmake/help/v3.20/command/target_compile_options.html))
3. 为目标配置编译器特性([target_compile_features](https://cmake.org/cmake/help/v3.20/command/target_compile_features.html))
4. 为目标配置预编译宏([target_compile_definitions](https://cmake.org/cmake/help/v3.20/command/target_compile_definitions.html))
5. 为目标配置源码([target_sources](https://cmake.org/cmake/help/v3.20/command/target_sources.html))
6. 为目标配置搜索的头文件列表([target_include_directories](https://cmake.org/cmake/help/v3.20/command/target_include_directories.html))
7. 为目标添加要预编译的头文件列表[target_precompile_headers](https://cmake.org/cmake/help/v3.20/command/target_precompile_headers.html)
8. 为目标配置依赖的链接库([target_link_libraries](https://cmake.org/cmake/help/v3.20/command/target_link_libraries.html))
9. 为目标配置其他属性([set_target_properties](https://cmake.org/cmake/help/v3.20/command/set_target_properties.html)),所有支持的属性可以在[这个页面查到](https://cmake.org/cmake/help/v3.20/manual/cmake-properties.7.html),要查看当前目标的属性值可以使用`get_target_property(<VAR> target property)`

#### 输出为可执行文件的编译配置

可执行文件使用`add_executable`命令来声明target(目标),它并不是一定会编译这个目标的,在控制依赖的时候我们也用它来声明已经存在的包.当前我们只介绍声明为待编译的目标如何写.

其完整语法为

```cmake
add_executable(<name> [WIN32] [MACOSX_BUNDLE]
              [EXCLUDE_FROM_ALL]
              [source1] [source2 ...])
```

其中`[WIN32]`和`[MACOSX_BUNDLE]`为平台指定的选项,通常不需要加;`[EXCLUDE_FROM_ALL]`是表示默认不会编译这个目标,只有在执行生成的后端配置文件时指定这个目标才会编译.这个一般用于编译测试用的可执行文件.
`add_executable`可以指定源码文件,但通常不建议这样指定,我们最好还是通过`target_sources`指定源码以保持每条命令职责单一,便于维护.

在确定好target后我们就可以开始设置这个target

我们以之前的helloworld作为第一个例子,将它改造为使用cmake管理,在其根目录下放上`CmakeLists.txt`

```cmake
#项目编译环境
cmake_minimum_required (VERSION 3.17)
project (helloworld
    VERSION 0.0.0
    DESCRIPTION "简单测试"
    LANGUAGES C
)
# 创建文件夹存放可执行文件
file(MAKE_DIRECTORY ${CMAKE_CURRENT_LIST_DIR}/bin)
add_executable(${PROJECT_NAME})
# 设置源码位置
target_sources(${PROJECT_NAME} 
    PRIVATE ${CMAKE_CURRENT_LIST_DIR}/src/helloworld.c
)
# 设置可执行文件的存放位置
set_target_properties(${PROJECT_NAME} PROPERTIES 
    RUNTIME_OUTPUT_DIRECTORY ${CMAKE_CURRENT_LIST_DIR}/bin
)
```

上面这个例子有两个点是上面没有提到的

1. `file(MAKE_DIRECTORY ${CMAKE_CURRENT_LIST_DIR}/bin)`可以用于创建文件夹,如果已经存在也不会保存
2. 可以为target设置`RUNTIME_OUTPUT_DIRECTORY`属性,它会控制编译好后存放的位置

#### 输出为包的编译配置

包使用`add_library`命令来声明,和`add_executable`一样,它也可以用于声明已经存在的链接库或者计划要依赖的链接库,当前我们还是只介绍cmake中如何编译项目为包.

cmake支持两种类型的包输出

1. 链接库
2. object文件

##### 输出为链接库

其完整语法为:

```cmake
add_library(<name> [STATIC | SHARED | MODULE]
            [EXCLUDE_FROM_ALL]
            [<source>...])
```



##### 输出为object文件

其完整语法为:

```cmake
add_library(<name> OBJECT [<source>...])
```


### 项目的依赖描述

项目的依赖可以分为如下几种途径:

1. 系统级别安装的包,也就是使用apt,apk什么的安装的包,他们会放在系统的默认搜索路径里,因此一般不太需要管
2. 外部安装的包,通常这些包是用cmake不太好管理的,比如那些比较老的包很多只支持makefile不支持cmake,那么我们就可以先在外面将其编译好,然后安装到系统目录(通常都会支持)
3. 外部安装的包,通常这些包是用cmake不太好管理的,比如那些比较老的包很多只支持makefile不支持cmake,而且并没有提供安装到系统目录的make指令,那么我们就可以先在外面将其编译好,然后在cmake中指定他们
4. 支持cmake的包,但是网络环境不好只能下下载下来再导入
5. 支持cmake的包,且网络条件良好,我们就可以直接在cmake中设置指定.

其中第一个算是直接使用系统的包,第2,3种是外部源码安装,第4,5种则是使用cmake直接管理依赖.第1,2,3种实际上都不是cmake在直接管理依赖,而是我们在外面编译好后cmake只是负责找到它,算是间接的管理这些依赖

#### 使用`find_package`指令间接管理已经存在的依赖

这种方式对应1,2,3种途径,cmake做的事只是找到已有的包并记录在运行过程中.cmake提供了`find_package`命令专门用于查找已经存在的依赖

#### 使用

#### 使用外部源码安装的包


#### 使用cmake直接管理




+ `set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY \${CMAKE_BINARY_DIR}/Lib)`:设置静态连接文件输出目录

+ `set(CMAKE_LIBRARY_OUTPUT_DIRECTORY \${CMAKE_BINARY_DIR}/Lib)`:设置动态态连接文件输出目录

+ `set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \${CMAKE_BINARY_DIR}/Bin)`:设置可执行文件输出目录

+ `set_target_properties(<projectnam> PROPERTIES PUBLIC_HEADER "some.h;headers.h")` 将对外的接口头文件设置到编译目标上

+ `include_directories([AFTER|BEFORE] [SYSTEM] dir1 [dir2 ...])`:设置头文件目录

+ `link_directories(directory1 directory2 ...)`:设置连接库所在位置

+ `link_libraries(library1 <debug | optimized> library2 ...)`:添加需要链接的库文件路径

+ `target_link_libraries(<target> [item1 [item2 [...]]][[debug|optimized|general] <item>] ...)`:设置要链接的库文件的名称

+ `aux_source_directory(<dir> <variable>)`:指定源文件的所在目录,如`aux_source_directory(. DIR_SRCS)`这样就将所有文件夹下的文件名放到了`DIR_SRCS`变量中.`add_executable(Demo ${DIR_SRCS})`就指定好了所有文件.

+ `add_executable(<target> <sourcefiles...>)`： 将源文件编译成一个可执行文件,第一位是目标可执行文件名,后面则是源文件名.

+ `add_compile_options(-std=c++11)`:指定编译目标使用的额外参数,比如支持c++11

+ `target_compile_features(<target> <features...>)`:指定编译目标使用的额外参数

#### 链接编译设置

+ `add_library (<target> [STATIC | SHARED | MODULE]  [EXCLUDE_FROM_ALL] <sourcefiles...>)`:将源文件编译成一个链接库.
    + `SHARED`动态库
	+ `STATIC`静态库
	+ `MODULE`在使用dyld的系统有效,如果不支持dyld,则被当作SHARED对待.
	+ `EXCLUDE_FROM_ALL`这个库不会被默认构建,除非有其他的组件依赖或者手

#### 子目录设置

+ `add_subdirectory(math)`:添加子目录,子目录中需要有`CMakeLists.txt`文件,编译时会优先编译子目录.

#### 测试设置

可以用`make test`执行测试

+ `enable_testing()`:启动测试
+ `add_test(<测试名> <test_target> <args>)`:添加一个测试,需要先把测试代码编译了
+ `set_tests_properties (test_usage PROPERTIES PASS_REGULAR_EXPRESSION "Usage: .* base exponent")`设定测试的属性

##### 定义一个宏用来简化测试工作

```cmake
macro (do_test arg1 arg2 result)
  add_test (test_${arg1}_${arg2} Demo ${arg1} ${arg2})
  set_tests_properties (test_${arg1}_${arg2}
    PROPERTIES PASS_REGULAR_EXPRESSION ${result})
endmacro (do_test)
```

##### debug测试

```cmake
set(CMAKE_BUILD_TYPE "Debug")
set(CMAKE_CXX_FLAGS_DEBUG "$ENV{CXXFLAGS} -O0 -Wall -g -ggdb")
set(CMAKE_CXX_FLAGS_RELEASE "$ENV{CXXFLAGS} -O3 -Wall")
```

#### install功能

通常可以是这样的定义

```cmake
install([TARGETS <name>...(编译目标)|FILES <file>...(要移动的文件)]
    [LIBRARY(动态库)|ARCHIVE(静态库)|RUNTIME(可执行文件)] DESTINATION  <dir> ...
    [INCLUDES DESTINATION [<dir> ...]]
)  
```

#### 打印信息

`MESSAGE([SEND_ERROR | STATUS | FATAL_ERROR] "message to display"...)`,如:`MESSAGE(STATUS "This is BINARY dir " ${HELLO_BINARY_DIR}))`


#### Cmake的预定义变量

+ `CMAKE_BINARY_DIR/PROJECT_BINARY_DIR/<projectname>_BINARY_DIR`

    这三个变量指代的内容是一致的,如果是`in source`编译,指得就是工程顶层目录,如果是`out-of-source`编译,指的是工程编译发生的目录
    PROJECT_BINARY_DIR 跟其他指令稍有区别,但多数时候你可以理解为他们是一致的.

+ `CMAKE_SOURCE_DIR/PROJECT_SOURCE_DIR/<projectname>_SOURCE_DIR`

    这三个变量指代的内容是一致的,不论采用何种编译方式,都是工程顶层目录.也就是在`in source`编译时,他跟`CMAKE_BINARY_DIR`等变量一致.`PROJECT_SOURCE_DIR`跟其他指令稍有区别,但多数时候你可以理解为他们是一致的.

+ `CMAKE_CURRENT_SOURCE_DIR`

    指的是当前处理的`CMakeLists.txt`所在的路径

+ `CMAKE_CURRRENT_BINARY_DIR`

    如果是`in-source`编译,它跟`CMAKE_CURRENT_SOURCE_DIR`一致,如果是`out-of-source`编译,他指的是`target`编译目录.使用`ADD_SUBDIRECTORY(src bin)`可以更改这个变量的值.使用`SET(EXECUTABLE_OUTPUT_PATH <新路径>)`并不会对这个变量造成影响,它仅仅修改了最终目标文件存放的路径.

+ `CMAKE_CURRENT_LIST_FILE`

    输出调用这个变量的`CMakeLists.txt`的完整路径

+ `CMAKE_CURRENT_LIST_LINE`

    输出这个变量所在的行

+ CMAKE_MODULE_PATH

    这个变量用来定义自己的`cmake`模块所在的路径.如果你的工程比较复杂,有可能会自己编写一些`cmake`模块,这些`cmake`模块是随你的工程发布的,为了让 `cmake`在处理`CMakeLists.txt`时找到这些模块,你需要通过`SET`指令,将自己的`cmake`模块路径设置一下.比如`SET(CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/cmake)`.这时候你就可以通过 INCLUDE 指令来调用自己的模块了.

+ `EXECUTABLE_OUTPUT_PATH /LIBRARY_OUTPUT_PATH`

    分别用来重新定义最终结果的存放目录,前面我们已经提到了这两个变量。

+ `PROJECT_NAME`

    返回通过`PROJECT`指令定义的项目名称.

+ `CMAKE_MAJOR_VERSION,CMAKE`

    主版本号,比如 2.4.6 中的 2

+ `CMAKE_MINOR_VERSION,CMAKE`

    次版本号,比如 2.4.6 中的 4

+ `CMAKE_PATCH_VERSION,CMAKE`

    补丁等级,比如 2.4.6 中的 6

+ `CMAKE_SYSTEM`

    系统名称,比如 Linux-2.6.22

+ `CMAKE_SYSTEM_NAME`

    不包含版本的系统名,比如 Linux

+ `CMAKE_SYSTEM_VERSION`

    系统版本,比如 2.6.22

+ `CMAKE_SYSTEM_PROCESSOR`

    处理器名称,比如 i686.

+ `UNIX`

    在所有的类 UNIX 平台为 TRUE,包括 OS X 和 cygwin

+ `WIN32`

    在所有的 win32 平台为 TRUE,包括 cygwin

+ `CMAKE_INSTALL_PREFIX`

    在cmake生成makefile时使用`-D`指定的目录,用于指定安装目录,如果不指定且安装的地址是相对地址,就会默认安装到`/usr/local/`下.

### 使用cmake编译我们的二元向量

更多的用法可以看官方文档.本文不会叙述太多.针对我们的二元向量模块,我们需要写两个`CMakeLists.txt`,一个用于将src中的内容编译为静态库,一个用于编译测试文件.

我们先将S2中的代码复制到S3

+ `examples/工具链/编译配套工具/usemake/CMakeLists.txt`

    ```cmake

    #项目编译环境
    cmake_minimum_required (VERSION 2.8)
    project (binary_vector)
    include_directories(source/inc)
    # 编译动态链接库
    set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/build/lib)
    aux_source_directory(${CMAKE_BINARY_DIR}/source/src DIR_LIB_SRCS)
    add_library(vector SHARED ${DIR_LIB_SRCS})
    install(TARGETS   vector
        LIBRARY DESTINATION  CMAKE_LIBRARY_OUTPUT_DIRECTORY  
    )  
    # 编译连接生成demo
    set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/build/bin)
    link_directories(${CMAKE_BINARY_DIR}/build/lib)
    link_libraries(vector)
    aux_source_directory(test DIR_SRCS)
    add_executable(Demo ${DIR_SRCS})
    #测试
    enable_testing()
    add_test (DemoRuns ${CMAKE_BINARY_DIR}/build/bin/Demo)
    ```

+ 执行cmake

    ```bash
    cmake examples/工具链/编译配套工具/usemake/CMakeLists.txt
    ```

    cmake会为我们创建一个更好的makefile

    ```bash
    make -C examples/工具链/编译配套工具/usemake
    ```

    我们可以执行test命令来测试包

    ```bash
    make -C ./code/compiler/S3/ test
    ```
