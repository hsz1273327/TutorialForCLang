# 项目管理

C/C++的项目管理可以称得上混乱,毕竟是两门相当古老的编程语言,可以说打从一开始就没考虑项目管理的问题,C/C++非常难以上手很大程度上也是拜这所赐.

我们可以将项目管理拆分为两个部分:

+ 包分发:即如何让别人可以找到你的包

+ 包调用:如何让程序可以使用找到的包.

## 包分发

包分发可以理解为3个方面的基本功能

+ 包的元数据管理,即发布者如何描述包的信息,让别人可以识别使用.以python为例在python中这个功能是由`setup.cfg/setup.py`完成的
+ 分发平台,即包发布后放在什么地方,以python为例在python中这个功能是由`pypi`平台或者自己搭建的pypi实例完成的.
+ 分发形式,即上传下载的内容如何编码解码,以python为例在python中这个功能是通常由zip包实现的(wheel和egg可以理解为带有元数据的zip包)

不用看C/C++在这三个方面都没有统一的方案.
传统c/c++的元数据管理就是依靠命名--C依靠所有函数和结构体等统一使用相同的前缀,C++则使用命名空间(本质上和c一样)而其他比如包的版本,说明等信息基本也就是靠说明文档和下载时的路径了;

传统c/c++包的分发平台通常就是操作系统发行版的包管理工具,比如ubuntu/debian的apt,alpine的apk等,他们安装好后会将包和头文件放在固定位置(/usr/lib,/usr/local/lib,/usr/include,/usr/local/include等).这些也是你在这些平台上安装编译工具后默认的依赖搜索路径.这种方式倒是很方便调用,但要管理依赖的版本或者要使用平台上没有的包又或者要控制包的分发范围(企业内部包管理)就比较尴尬了;

c/c++包的分发模式基本就两种:

+ 源码分发,这是golang的策略,C/C++的编译速度是很慢的,这条路因此相当难走
+ 二进制分发,就是apt,apkw这些包管理工具的默认分发形式,二进制分发对平台会有相当强的依赖,因此往往不能通用
+ 混合分发,像homebrew,它会先尝试下载二进制的分发版本,如果不行则会下载源码进行编译,多数非系统级分发方案都是这种模式

## 包调用

包调用则可以分为大致几个方面

1. 环境隔离,即让项目的依赖不会影响其他程序和项目,以python为例在python中这个功能是由python的标准库`venv`实现的
2. 包查询和包下载,即让使用者可以快速找到需要的包并下载下来作为依赖,,以python为例在python中这个功能是由`pip`实现的
3. 依赖管理,即让这个包移植的时候可以直接通过依赖管理工具快速部署依赖,这个功能是由`pip freeze`和`pip install -r`实现的

不用看C/C++在这三个方面也没有统一的方案.

使用apt,apk这样的操作系统相关的依赖管理系统可以在包查询和包下载上非常方便,但这必定是全局安装的,因此完全没有环境隔离一说,如果要环境隔离,那就得每个依赖的项目下载源码到本地现编译,然后使用gcc/g++连接.

在编译部分我们就已经介绍过了c/c++的包调用就2种方式

+ 源码方式
+ 库方式(动态链接库/静态链接库)

但我们前面两节也已经演示过如何引用已经存在的包,即便使用makefile来定制编译过程这个纯手动档的依赖管理也是极其繁琐的.

## 通用的解决方案

很遗憾没有!毕竟历史太长了,很多遗留代码可能早已没人维护,但一些成年老程序依然在用.对于C/C++这种老古董来说历史包袱和历史遗产都是不得不面对的问题.但也不是完全无解,一个相对没那么痛苦的方案是使用[cmake](https://cmake.org/)配合git服务来做项目管理.大体的思路是:

使用cmake描述项目和安装依赖,使用git服务保存项目源码.通用常用的依赖和工具依靠操作系统的包管理工具,而专用的希望做环境隔离的依赖则使用cmake从源码安装.

这个方案的好处是:

1. cmake相对是铺的比较广的工具,github上的c/c++项目几乎都由cmake支持
2. cmake是不少重要工具的指定编译辅助工具
3. cmake本身是个嫁接工具,它的后端可以是makefile,可以是nijia等
4. cmake提供了一定的跨平台能力和交叉编译能力

当然缺点也有:

1. cmake语法反人类,非常不直观
2. cmake的操作几乎都是黑盒,很难debug

但是没办法其他的方案相比而言还不如它因此本文也主讲这种方式

## 使用cmake管理项目

Cmake本质上也不提供流程化编译的功能,他其实是用来生成不同平台的不同编译工具的配置文件的,这些不同编译工具通常被称为其"后端",由于cmake只针对C/C++/Fortain/CUDA和汇编语言,所以会有一些额外的细化配置.

## cmake的使用流程

cmake的使用流程有3步:

1. 定义`CmakeLists.txt`文件用于描述项目信息,编译流程等
2. 执行`cmake [options] .`为后端生成配置文件
3. 只用后端编译项目

cmake默认的后端是makefile,但我们也可以通过`-G`设置后端,常用的后端还有[Ninja](https://github.com/ninja-build/ninja/releases)和`MinGW Makefiles`等.为了通用性本文以Ninja为例子.实际上一旦cmake写好后生成什么后端并不重要,生成了配置文件后只要执行它就可以了:

+ makefile

```bash
make
```



在linux下我们一般都需要额外安装cmake来使用

+ `debian/ubuntu`: `apt install -y --no-install-recommends cmake`(国内最好先使用`sed -i 's/deb.debian.org/mirrors.ustc.edu.cn/g' /etc/apt/sources.list`换源)
+ `alpine`: `apk add cmake`(国内最好先使用`sed -i 's/dl-cdn.alpinelinux.org/mirrors.ustc.edu.cn/g' /etc/apk/repositories`换源)

Cmake通过配置文件`CMakeLists.txt`设定配置.再通过`cmake`生成不同平台下的makefile文件.

### Cmake语法

Cmake使用指令式的配置方式,基本形式就是`cmake_minimum_required (VERSION 2.8)`这样,`()`外面的是参数字段,里面的是内容.


#### 元信息设置

+ `cmake_minimum_required`：指定运行此配置文件所需的CMake的最低版本

+ `project(<projectname>)`：该命令指定项目的名称

#### 编译器设置

+ `SET(CMAKE_C_COMPILER "/home/public/local/bin/gcc")`:指定c语言编译器

+ `SET(CMAKE_CXX_COMPILER "/home/public/local/bin/g++")`:指定c++语言编译器

+ `set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY \${CMAKE_BINARY_DIR}/Lib)`:设置静态连接文件输出目录

+ `set(CMAKE_LIBRARY_OUTPUT_DIRECTORY \${CMAKE_BINARY_DIR}/Lib)`:设置动态态连接文件输出目录

+ `set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \${CMAKE_BINARY_DIR}/Bin)`:设置可执行文件输出目录

+ `set_target_properties(<projectnam> PROPERTIES PUBLIC_HEADER "some.h;headers.h")` 将对外的接口头文件设置到编译目标上

+ `include_directories([AFTER|BEFORE] [SYSTEM] dir1 [dir2 ...])`:设置头文件目录

+ `link_directories(directory1 directory2 ...)`:设置连接库所在位置

+ `link_libraries(library1 <debug | optimized> library2 ...)`:添加需要链接的库文件路径

+ `target_link_libraries(<target> [item1 [item2 [...]]][[debug|optimized|general] <item>] ...)`:设置要链接的库文件的名称

+ `aux_source_directory(<dir> <variable>)`:指定源文件的所在目录,如`aux_source_directory(. DIR_SRCS)`这样就将所有文件夹下的文件名放到了`DIR_SRCS`变量中.`add_executable(Demo ${DIR_SRCS})`就指定好了所有文件.

+ `add_executable(<target> <sourcefiles...>)`： 将源文件编译成一个可执行文件,第一位是目标可执行文件名,后面则是源文件名.

+ `add_compile_options(-std=c++11)`:指定编译目标使用的额外参数,比如支持c++11

+ `target_compile_features(<target> <features...>)`:指定编译目标使用的额外参数

#### 链接编译设置

+ `add_library (<target> [STATIC | SHARED | MODULE]  [EXCLUDE_FROM_ALL] <sourcefiles...>)`:将源文件编译成一个链接库.
    + `SHARED`动态库
	+ `STATIC`静态库
	+ `MODULE`在使用dyld的系统有效,如果不支持dyld,则被当作SHARED对待.
	+ `EXCLUDE_FROM_ALL`这个库不会被默认构建，除非有其他的组件依赖或者手

#### 子目录设置

+ `add_subdirectory(math)`:添加子目录,子目录中需要有`CMakeLists.txt`文件,编译时会优先编译子目录.

#### 测试设置

可以用`make test`执行测试

+ `enable_testing()`:启动测试
+ `add_test(<测试名> <test_target> <args>)`:添加一个测试,需要先把测试代码编译了
+ `set_tests_properties (test_usage PROPERTIES PASS_REGULAR_EXPRESSION "Usage: .* base exponent")`设定测试的属性

##### 定义一个宏用来简化测试工作

```cmake
macro (do_test arg1 arg2 result)
  add_test (test_${arg1}_${arg2} Demo ${arg1} ${arg2})
  set_tests_properties (test_${arg1}_${arg2}
    PROPERTIES PASS_REGULAR_EXPRESSION ${result})
endmacro (do_test)
```

##### debug测试

```cmake
set(CMAKE_BUILD_TYPE "Debug")
set(CMAKE_CXX_FLAGS_DEBUG "$ENV{CXXFLAGS} -O0 -Wall -g -ggdb")
set(CMAKE_CXX_FLAGS_RELEASE "$ENV{CXXFLAGS} -O3 -Wall")
```

#### install功能

通常可以是这样的定义

```cmake
install([TARGETS <name>...(编译目标)|FILES <file>...(要移动的文件)]
    [LIBRARY(动态库)|ARCHIVE(静态库)|RUNTIME(可执行文件)] DESTINATION  <dir> ...
    [INCLUDES DESTINATION [<dir> ...]]
)  
```

#### 打印信息

`MESSAGE([SEND_ERROR | STATUS | FATAL_ERROR] "message to display"...)`,如:`MESSAGE(STATUS "This is BINARY dir " ${HELLO_BINARY_DIR}))`

#### 变量

类似make,cmake也可以使用变量

+ 显式的设置自定义变量

使用`set(变量名 值)`的操作，如:`SET(HELLO_SRC main.SOURCE_PATHc)`

+ 变量引用的方式

    使用`${}`进行变量的引用

+ 设置环境变量

    `SET(ENV{变量名} 值)`

+ 调用环境变量

    使用`$ENV{NAME}`指令就可以调用系统的环境变量了

#### 条件分支

cmake使用`if`指令设置条件分支.其基本语法为:

```cmake
IF(expression_r_r)
    # THEN section.
    COMMAND1(ARGS ...)
    COMMAND2(ARGS ...)
    ...
ELSE(expression_r_r)
    # ELSE section.
    COMMAND1(ARGS ...)
    COMMAND2(ARGS ...)
    ...
ENDIF(expression_r_r)
```

#### 循环

cmake有两种循环:

+ WHILE指令

   基本语法为:

    ```cmake
    WHILE(condition)
      COMMAND1(ARGS ...)
      COMMAND2(ARGS ...)
      ...
    ENDWHILE(condition)
    ```

+ FOREACH

    FOREACH 指令的使用方法有两种形式:

    1. 列表

        ```cmake
        FOREACH(loop_var arg1 arg2 ...)
        COMMAND1(ARGS ...)
        COMMAND2(ARGS ...)
        ...
        ENDFOREACH(loop_var)
        ```

    2. 范围(类似pythonz中的for xxx in range(x))

        ```cmake
        FOREACH(loop_var RANGE oop_var RANGE start stop [step])
        ENDFOREACH(loop_var)
        ```

#### Cmake的预定义变量

+ `CMAKE_BINARY_DIR/PROJECT_BINARY_DIR/<projectname>_BINARY_DIR`

    这三个变量指代的内容是一致的,如果是`in source`编译,指得就是工程顶层目录,如果是`out-of-source`编译,指的是工程编译发生的目录
    PROJECT_BINARY_DIR 跟其他指令稍有区别,但多数时候你可以理解为他们是一致的.

+ `CMAKE_SOURCE_DIR/PROJECT_SOURCE_DIR/<projectname>_SOURCE_DIR`

    这三个变量指代的内容是一致的,不论采用何种编译方式,都是工程顶层目录.也就是在`in source`编译时,他跟`CMAKE_BINARY_DIR`等变量一致.`PROJECT_SOURCE_DIR`跟其他指令稍有区别,但多数时候你可以理解为他们是一致的.

+ `CMAKE_CURRENT_SOURCE_DIR`

    指的是当前处理的`CMakeLists.txt`所在的路径

+ `CMAKE_CURRRENT_BINARY_DIR`

    如果是`in-source`编译,它跟`CMAKE_CURRENT_SOURCE_DIR`一致,如果是`out-of-source`编译,他指的是`target`编译目录.使用`ADD_SUBDIRECTORY(src bin)`可以更改这个变量的值.使用`SET(EXECUTABLE_OUTPUT_PATH <新路径>)`并不会对这个变量造成影响,它仅仅修改了最终目标文件存放的路径.

+ `CMAKE_CURRENT_LIST_FILE`

    输出调用这个变量的`CMakeLists.txt`的完整路径

+ `CMAKE_CURRENT_LIST_LINE`

    输出这个变量所在的行

+ CMAKE_MODULE_PATH

    这个变量用来定义自己的`cmake`模块所在的路径.如果你的工程比较复杂,有可能会自己编写一些`cmake`模块,这些`cmake`模块是随你的工程发布的,为了让 `cmake`在处理`CMakeLists.txt`时找到这些模块,你需要通过`SET`指令,将自己的`cmake`模块路径设置一下.比如`SET(CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/cmake)`.这时候你就可以通过 INCLUDE 指令来调用自己的模块了.

+ `EXECUTABLE_OUTPUT_PATH /LIBRARY_OUTPUT_PATH`

    分别用来重新定义最终结果的存放目录,前面我们已经提到了这两个变量。

+ `PROJECT_NAME`

    返回通过`PROJECT`指令定义的项目名称.

+ `CMAKE_MAJOR_VERSION,CMAKE`

    主版本号,比如 2.4.6 中的 2

+ `CMAKE_MINOR_VERSION,CMAKE`

    次版本号,比如 2.4.6 中的 4

+ `CMAKE_PATCH_VERSION,CMAKE`

    补丁等级,比如 2.4.6 中的 6

+ `CMAKE_SYSTEM`

    系统名称,比如 Linux-2.6.22

+ `CMAKE_SYSTEM_NAME`

    不包含版本的系统名,比如 Linux

+ `CMAKE_SYSTEM_VERSION`

    系统版本,比如 2.6.22

+ `CMAKE_SYSTEM_PROCESSOR`

    处理器名称,比如 i686.

+ `UNIX`

    在所有的类 UNIX 平台为 TRUE,包括 OS X 和 cygwin

+ `WIN32`

    在所有的 win32 平台为 TRUE,包括 cygwin

+ `CMAKE_INSTALL_PREFIX`

    在cmake生成makefile时使用`-D`指定的目录,用于指定安装目录,如果不指定且安装的地址是相对地址,就会默认安装到`/usr/local/`下.

### 使用cmake编译我们的二元向量

更多的用法可以看官方文档.本文不会叙述太多.针对我们的二元向量模块,我们需要写两个`CMakeLists.txt`,一个用于将src中的内容编译为静态库,一个用于编译测试文件.

我们先将S2中的代码复制到S3

+ `examples/工具链/编译配套工具/usemake/CMakeLists.txt`

    ```cmake

    #项目编译环境
    cmake_minimum_required (VERSION 2.8)
    project (binary_vector)
    include_directories(source/inc)
    # 编译动态链接库
    set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/build/lib)
    aux_source_directory(${CMAKE_BINARY_DIR}/source/src DIR_LIB_SRCS)
    add_library(vector SHARED ${DIR_LIB_SRCS})
    install(TARGETS   vector
        LIBRARY DESTINATION  CMAKE_LIBRARY_OUTPUT_DIRECTORY  
    )  
    # 编译连接生成demo
    set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/build/bin)
    link_directories(${CMAKE_BINARY_DIR}/build/lib)
    link_libraries(vector)
    aux_source_directory(test DIR_SRCS)
    add_executable(Demo ${DIR_SRCS})
    #测试
    enable_testing()
    add_test (DemoRuns ${CMAKE_BINARY_DIR}/build/bin/Demo)
    ```

+ 执行cmake

    ```bash
    cmake examples/工具链/编译配套工具/usemake/CMakeLists.txt
    ```

    cmake会为我们创建一个更好的makefile

    ```bash
    make -C examples/工具链/编译配套工具/usemake
    ```

    我们可以执行test命令来测试包

    ```bash
    make -C ./code/compiler/S3/ test
    ```
