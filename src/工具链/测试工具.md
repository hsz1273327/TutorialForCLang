# 测试工具

一般针对某种编程语言的测试工具可以分为如下几种:

1. 单元测试,用于测试接口是否符合预期
2. 性能测试,一般用于测试代码的运行时效率,方便后续优化

C/C++作为以性能安生立命的编程语言可以说这两块都有充足的工具支撑.C/C++的单元测试框架非常多,此处我只介绍[Catch](https://github.com/catchorg/Catch2).这个库只有头文件,非常的轻量.而且完全开源,由社区维护,简单好用.

本文测试的例子是前面二元向量的c++版本,其主要代码如下.

+ `binary_vector.hpp`

    ```c++
    /* $Id$ */
    #ifndef BINARY_VECTOR_HPP
    #define BINARY_VECTOR_HPP//一般是文件名的大写 头文件结尾写上一行

    namespace vector{
        class BinaryVector{
        public:
            float x;
            float y;
            
            BinaryVector(float x,float y): x(x),y(y) {};
            float mod();
            BinaryVector add(const BinaryVector&);
            float mul(const BinaryVector&);
        };
    }

    #endif
    ```

+ `binary_vector.cc`

    ```c++
    #include "binary_vector.hpp"
    #include <cmath>


    namespace vector{
        float BinaryVector::mod(){
            auto result = std::sqrt(std::pow(this->x,2)+std::pow(this->y,2));
            return result;
        }
        BinaryVector BinaryVector::add(const BinaryVector& that){
            auto x = this->x + that.x;
            auto y = this->y + that.y;
            BinaryVector b(x,y);
            return b;
        }
        float BinaryVector::mul(const BinaryVector& that){
            float result = this->x * that.x + this->y * that.y;
            return result;
        }
    }
    ```

+ `CmakeLists.txt`

    ```cmake
    #项目编译环境
    cmake_minimum_required (VERSION 3.17)
    project (myvector
        VERSION 0.0.0
        DESCRIPTION "简单测试编译包"
        LANGUAGES CXX
    )

    # 设置源码位置
    file(GLOB SRC "${CMAKE_CURRENT_LIST_DIR}/src/*.cc")
    # 准备存放位置
    file(MAKE_DIRECTORY ${CMAKE_CURRENT_LIST_DIR}/dist/lib)
    # 编译为iobject对象减少重复编译
    add_library(objlib OBJECT ${SRC})
    target_include_directories(objlib
        PUBLIC ${CMAKE_CURRENT_LIST_DIR}/inc
    )
    set_target_properties(objlib PROPERTIES
        POSITION_INDEPENDENT_CODE 1
    )
    # 编译静态库
    add_library(${PROJECT_NAME} STATIC)
    add_library(${PROJECT_NAME}::${PROJECT_NAME} ALIAS ${PROJECT_NAME})
    target_sources(${PROJECT_NAME}
        PRIVATE $<TARGET_OBJECTS:objlib>
    )
    target_include_directories(${PROJECT_NAME}
        PUBLIC ${CMAKE_CURRENT_LIST_DIR}/inc
    )
    set_target_properties(${PROJECT_NAME} PROPERTIES 
        OUTPUT_NAME ${PROJECT_NAME}
        CLEAN_DIRECT_OUTPUT 1
        ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_CURRENT_LIST_DIR}/dist/lib
        PUBLIC_HEADER ${CMAKE_CURRENT_LIST_DIR}/inc/binary_vector.hpp
    )
    # 编译动态库
    option(WITHSHARE "build share lib also?" off)
    if(WITHSHARE)
        message("also build share library")
        # shared and static libraries built from the same object files
        add_library(${PROJECT_NAME}_shared SHARED)
        target_sources(${PROJECT_NAME}_shared
            PRIVATE $<TARGET_OBJECTS:objlib>
        )
        target_include_directories(${PROJECT_NAME}_shared
            PUBLIC ${CMAKE_CURRENT_LIST_DIR}/inc
        )
        set_target_properties(${PROJECT_NAME}_shared PROPERTIES 
            OUTPUT_NAME ${PROJECT_NAME}
            CLEAN_DIRECT_OUTPUT 1
            LIBRARY_OUTPUT_DIRECTORY ${CMAKE_CURRENT_LIST_DIR}/dist/lib
        )

        # 安装
        install(TARGETS ${PROJECT_NAME} ${PROJECT_NAME}_shared
            ARCHIVE
                DESTINATION ${CMAKE_INSTALL_LIBDIR}
            LIBRARY
                DESTINATION ${CMAKE_INSTALL_LIBDIR}
            PUBLIC_HEADER
                DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}
        )
    else()
        message("only build static library")
        # 安装
        install(TARGETS ${PROJECT_NAME}
            ARCHIVE
                DESTINATION ${CMAKE_INSTALL_LIBDIR}
            PUBLIC_HEADER
                DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}
        )
    endif()
    ```

下面我们来为它写测试

## 单元测试

单元测试的写法按风格来说可以大致分为`TDD-style`(测试驱动开发风格)和`BDD-style`(行为驱动开发风格),catch两种都支持,而且支持分项分组分标签(`section/case/tag`)的组织测试.基本上该有的功能都有,而且更关键的它就一个头文件.

### 使用`Catch`写单元测试

首先我们我们先来说下catch中的几个概念:

1. `断言`用于申明指定目标符合特定条件.可以认为断言是判断测试是否符号要求的最基本单元
2. `匹配器`,用于处理特定类型数据的工具帮助断言.
3. `数据生成器`,用于快速生成一组数据作为测试的目标进行测试.
4. `section`最小的测试项单位,每一个section就是一个测试项
5. `case`测试用例,多个section的组合,一般用于组织一组关联性很强的测试项,这些测试项会在同一个测试用例中被顺序执行
6. `tag`标签,标签是case的属性,一般相同标签的测试用例存在一些关联性,比如都是测同一个类型.他们是可以并行执行的

#### 断言

catch支持的断言类型有如下几种:

1. `REQUIRE(<expression>)`/`CHECK(<expression>)`断言条件是成立的
2. `REQUIRE_THAT(<expression>, <matcher expression>)`/`CHECK_THAT(<expression>, <matcher expression>)`表达式的结果满足指定的匹配器或者匹配器,注意1,2项中的`<expression>`一定是谓词,而且值得一提的是都可以使用`Approx(float/double)`来模糊匹配浮点数.浮点数因为精度问题不可能完全相等,所以要用这个来断言.`Approx`后面还可以接如下设置:
   1. `epsilon`精度系数
   2. `margin`边界
   3. `scale`用于更改近似值的大小
3. `REQUIRE_FALSE(<expression>)`/`CHECK_FALSE(<expression>)`断言条件是不成立的,注意`<expression>`一定是谓词
4. `REQUIRE_THROW(<expression>)`/`CHECK_THROW(<expression>)`断言执行的表达式会出错
5. `REQUIRE_NOTHROW(<expression>)`/`CHECK_NOTHROW(<expression>)`断言执行的表达式不会出错
6. `REQUIRE_THROWS_AS(<expression>,<exception_type>)`/`CHECK_THROWS_AS(<expression>,<exception_type>)`,断言执行表达式会报出指定类型的错误
7. `REQUIRE_THROWS_WITH(<expression>,<string or string matcher>)`/`CHECK_THROWS_WITH(<expression>,<string or string matcher>)`,断言执行表达式会报出错误信息为指定字符串或者字符串匹配的错误
8. `REQUIRE_THROWS_MATCHES(<expression>,<exception type or matcher for given exception type>)`/`CHECK_THROWS_MATCHES(<expression>,<exception type or matcher for given exception type>)`,断言执行表达式会报出错误类型为指定类型或者匹配的错误

#### 匹配器

匹配器是用来处理一些特殊类型数据的工具,匹配器可以使用与`&&`或`||`非`!`进行连接.

下面是常用的匹配器:

> `std::string`

+ `Catch::Matchers::StartsWith(string x)`以x开始
+ `Catch::Matchers::EndsWith(string x)` 以x结尾
+ `Catch::Matchers::Contains(string x)` 包含x
+ `Catch::Matchers::Equals(string x)` 于x相同
+ `Catch::Matchers::Matches(string x)` 满足x描述的正则表达式匹配

> `std::vector`

+ `Catch::Matchers::Contains(<vector>)`vector是其子集
+ `Catch::Matchers::VectorContains(<element>)`包含元素
+ `Catch::Matchers::Equals(s<vector>)`完全相同
+ `Catch::Matchers::UnorderedEquals(<vector>)`内容相同,可以顺序不同
+ `Catch::Matchers::Approx(<vector>)`顺序相同,各项值相似

> 浮点数(float,double),主要有关精度

+ `Catch::Matchers::WithinAbs(double/float target, double margin)`设置精度内匹配
+ `Catch::Matchers::WithinULP(double/float target, int64_t ULPs)`设置[最后一位上的单位值](https://zh.wikipedia.org/wiki/%E6%9C%80%E5%90%8E%E4%B8%80%E4%BD%8D%E4%B8%8A%E7%9A%84%E5%8D%95%E4%BD%8D%E5%80%BC)内精度匹配
+ `Catch::Matchers::WithinRel(double/float target, double margin)`根据公式`|lhs - rhs| <= epsilon * max(|lhs|, |rhs|)`匹配精度.epsilon为机器精度

#### 数据生成器

宏`GENERATE`可以用于生成数据,和python中的生成器类似,这里的生成器也是包含`next()`接口的东西,它的用法就是类似`auto i = GENERATE(1, 2);`这个形式,其中i就是第几次调用时给出的元素.

执行测试时如果有`GENERATE`他就会被遍历

#### TDD风格的测试项写法

所谓TDD风格的测试项可以理解为一项一项的测试,我们为我们的例子写一个TDD风格的测试用例

```c++
#define CATCH_CONFIG_MAIN  // This tells Catch to provide a main() - only do this in one cpp file
#include <catch2/catch.hpp>
#include "binary_vector.hpp"
using vector::BinaryVector;
using Catch::Matchers::WithinRel;
TEST_CASE( "Test_TDD", "[vector]" ) {
    BinaryVector A(1.0,2.0);
    BinaryVector B(3.0,4.0);
    SECTION( "check mod A" ) {
        REQUIRE_THAT(2.23607,WithinRel(A.mod()));
    }
    SECTION( "check mod B" ) {
        REQUIRE_THAT(5.000000,WithinRel( B.mod()));
    }
    SECTION( "check mul A B" ) {
        REQUIRE_THAT(11.000000,WithinRel( A.mul(B)));
    }
    SECTION( "check add A B" ) {
        auto C =  A.add(B);
        REQUIRE_THAT(4.000000,WithinRel(C.x));
        REQUIRE_THAT(6.000000,WithinRel(C.y));
    }
}
```

可以看到很直白的,tag是tag,case是case,section是section.

其中`TEST_CASE(<case_name>, "[tag]..." )`

#### BDD风格的测试项写法

### 在cmake中注册单元测试

+ `CmakeLists.txt`

```cmake

```

### 单元测试覆盖率

## 性能测试

