
# 函数

## 函数的定义

C++语言中的函数声明和定义必须带参数和返回值类型,他的形式是这样


```c
返回变量类型 函数名(参数类型 参数1,参数类型,参数2){
    语句组
    return 返回值;
}
```

在上一讲中我们计算开放已经使用了函数,需要注意的是C++中的函数并不像python中那么万能,它无法作为参数或者返回值,也没有匿名函数,它的作用只是写接口和一些简单抽象而已.

## 函数的类型

我们定义函数的类型就是它返回值的类型,别问为啥反正就是这样.

## 函数的调用

C++中的函数只在被调用时才会在内存中开辟出空间,当调用结束后,为函数开辟出的空间就会被回收,C++是一种非常节俭的语言,也正因为这样它才能在单片机的编程中有所作为

## 函数的参数传递

函数的参数可以带有默认值,默认值可以是常数,也可以是表达式.
C++中的函数参数在一般情况下都是传值的(也就是复制),只有参数是引用(数组,指针)的时候才是传递的引用(数组,指针)

## 函数的原型与函数声明

C++语言的特点是可以先声明再定义,对于函数也一样,通常声明会放在头文件中,这部分内容会放在<头文件与多文件编译>部分理解

在C++语言中函数的声明就是函数的原型,他的形式是:

```c
返回变量类型 函数名(参数类型1,参数类型2);
```

## 入口函数与命令行参数输入

之前的例子中,我们接触的入口函数都是参数为空,返回为int这样的,这种形式常见于直接执行的程序,而典型命令行工具的比如像g++这样,它必然需要有一个输入参数,这种时候我们可以利用另一种形式的入口函数来实现:

```c
int main(int argc, char *argv[]){
    代码段
}

```

+ argc 是入口参数的长度(几个参数)
+ argv 则是由输入字符串组成的数组

> 例:

将之前的牛顿法求开根改为命令行工具,参数为第一位要开的数,第二位为开几次方根,精度规定为0.0000001,如果达不到,那允许最多迭代500次

牛顿法扩展都n次方根$ \sqrt[k] a $的表达式为:

$x_{n+1} = x_n - \frac {x_n^k-a} {kx_n^{k-1}} = \frac {k-1}{k} x_n + \frac {a}{kx_n^{k-1}}$



```python
%%writefile src/C5/Newton_method_sqrt.cpp


#include <stdio.h>
#include <math.h>
#include <stdlib.h>
const double EPS  = 0.0000001;

double newton_method(double a,int n){
    double x=0,last_x=0;
    if (a>0){
        x = a/n;
        for(int i = 0;i < 500;i++){
            last_x = x;
            x = last_x - last_x*(1-a*pow(last_x,-n))/n;
            if(fabs(last_x - x) < EPS){
                break;
            }
        }
        return x;
    } else if (a == 0){
        return 0;
    } else if (a == 1){
        return 1;
    } else{
        return -1;
    }

}

int main(int argc, char *argv[]){
    if (argc != 3) {
        printf("参数错误,参数有%d个,请传入要开方的数和开多少次方\n",argc-1);
        return 0;
    }else{
        double a= atof(argv[1]),result = 0;
        int n = atoi(argv[2]);
        result = newton_method(a,n);
        if (result < 0){
            printf("%lf无法在实数范围内求开方\n",a);
            return 0;
        }else{
            printf("%lf的%d次方根是%lf\n",a,n,result);
            return 0;
        }
    }
}

```

    Overwriting src/C5/Newton_method_sqrt.cpp



```python
!g++-7 -o bin/Newton_method_sqrt src/C5/Newton_method_sqrt.cpp
```


```python
!bin/Newton_method_sqrt
```

    参数错误,参数有0个,请传入要开方的数和开多少次方



```python
!bin/Newton_method_sqrt 2
```

    参数错误,参数有1个,请传入要开方的数和开多少次方



```python
!bin/Newton_method_sqrt 3 3
```

    3.000000的3次方根是1.442250


# 函数重载

C++中函数重载是在C++语言基础上的一大特色,不过有好也有坏.虽然C++的函数重载大大方便了编程人员,但是却有时候使用不当会引起问题,最典型的就是函数重载的二义性问题.首先我们知道C++函数重载的条件,以及C++中为什么可以函数重载,这样才可以避免C++函数重载中的二义性问题.

C++函数重载的条件有三个:

1. 函数必须位于同一作用域之中.(重载顾名思义是地位相同的两个函数,可以说两个函数是平等的,所以凭什么有的函数作用域大呢,那自然就是同一作用域)
2. 函数名必须相同.
3. 最重要的就是参数列表不同.参数列表不同又可以分为:

    1. 参数个数不同 
    2. 参数类型不同 
    3. 参数顺序不同
    满足以上三条任意一条就可以
    
函数的返回值可以相同，也可以不同.

我们都知道,如果在c语言中定义一个或者多个同名的函数,哪怕是参数的类型,个数,顺序都不同可不可以进行重载.




```python
%%writefile src/C5/overloading_test.cpp
#include <iostream>
#include <string>

using std::string;
using std::cout;
using std::endl;
        
int My_add(int a, int b){  
    return (a + b);  
}  
  
string My_add(string a, string b){  
    return (a + b);  
}  
  
int main(){  
    auto m = 10;  
    auto n = 20;  
    auto ret = My_add(m, n);
    cout << ret << endl;
    string x = "asdfg";

    string y = "qwert";
    string re = My_add(x, y);
    cout << re << endl;
    return 0;  
}  

```

    Overwriting src/C5/overloading_test.cpp



```python
!g++-7 -o bin/overloading_test src/C5/overloading_test.cpp
```


```python
!./bin/overloading_test
```

    30
    asdfgqwert


# 匿名函数[C++11]

在c++11中新增了对lambda函数的支持,C++11 的 lambda 表达式规范如下：


+ `[ capture ] ( params ) mutable exception attribute -> ret { body }`

    完整的 lambda 表达式形式
    
    
+ `[ capture ] ( params ) -> ret { body }`

    `const`类型的 lambda 表达式，该类型的表达式不能改捕获("capture")列表中的值
    
    
+ `[ capture ] ( params ) { body }`

    省略了返回值类型的lambda表达式，但是该lambda表达式的返回类型可以按照下列规则推演出来:
    + 如果lambda代码块中包含了return语句，则该lambda表达式的返回类型由return语句的返回类型确定.
    + 如果没有return语句，则类似`void f(...)`函数.


+ `[ capture ] { body }`

    省略了参数列表，类似于无参函数`f()`.

    
`mutable`修饰符说明lambda表达式体内的代码可以修改被捕获的变量,并且可以访问被捕获对象的`non-const`方法

`exception`说明lambda表达式是否抛出异常(noexcept)，以及抛出何种异常，类似于`void f() throw(X, Y)`

`attribute`用来声明属性。

另外,`capture`指定了在可见域范围内lambda表达式的代码内可见得外部变量的列表,具体解释如下：

+ `[a,&b]` a变量以值的方式呗捕获，b以引用的方式被捕获.
+ `[this]` 以值的方式捕获 this 指针.
+ `[&]` 以引用的方式捕获所有的外部自动变量.
+ `[=]` 以值的方式捕获所有的外部自动变量.
+ `[]` 不捕获外部的任何变量.

此外`params`指定lambda表达式的参数。




```python
%%writefile src/C5/lambda_test.cpp
#include <vector>
#include <iostream>
#include <algorithm>
#include <functional>
 
int main()
{
    std::vector<int> c { 1,2,3,4,5,6,7 };
    int x = 5;
    c.erase(std::remove_if(c.begin(),
                           c.end(),
                           [x](int n){ return n < x; }
                          ),
            c.end());
 
    std::cout << "c: ";
    for (auto i: c) {
        std::cout << i << ' ';
    }
    std::cout << '\n';
 

    auto func1 = [](int i) { return i+4; };
    std::cout << "func1: " << func1(6) << '\n'; 
 

    std::function<int(int)> func2 = [](int i) { return i+4; };
    std::cout << "func2: " << func2(6) << '\n'; 
}
```

    Overwriting src/C5/lambda_test.cpp



```python
!g++-7 -o bin/lambda_test src/C5/lambda_test.cpp
```


```python
!bin/lambda_test
```

    c: 5 6 7 
    func1: 10
    func2: 10

