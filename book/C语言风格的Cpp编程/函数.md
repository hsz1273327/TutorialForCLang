
# 函数

## 函数的定义

C++语言中的函数声明和定义必须带参数和返回值类型,他的形式是这样


```c
返回变量类型 函数名(参数类型 参数1,参数类型,参数2){
    语句组
    return 返回值;
}
```

在上一讲中我们计算开放已经使用了函数,需要注意的是C++中的函数并不像python中那么万能,它无法作为参数或者返回值,也没有匿名函数,它的作用只是写接口和一些简单抽象而已.

## 函数的类型

我们定义函数的类型就是它返回值的类型,别问为啥反正就是这样.

## 函数的调用

C++中的函数只在被调用时才会在内存中开辟出空间,当调用结束后,为函数开辟出的空间就会被回收,C++是一种非常节俭的语言,也正因为这样它才能在单片机的编程中有所作为

## 函数的参数传递

函数的参数可以带有默认值,默认值可以是常数,也可以是表达式.
C++中的函数参数在一般情况下都是传值的(也就是复制),只有参数是引用(数组,指针)的时候才是传递的引用(数组,指针)

## 函数的原型与函数声明

C++语言的特点是可以先声明再定义,对于函数也一样,通常声明会放在头文件中,这部分内容会放在<头文件与多文件编译>部分理解

在C++语言中函数的声明就是函数的原型,他的形式是:

```c
返回变量类型 函数名(参数类型1,参数类型2);
```

## 入口函数与命令行参数输入

之前的例子中,我们接触的入口函数都是参数为空,返回为int这样的,这种形式常见于直接执行的程序,而典型命令行工具的比如像g++这样,它必然需要有一个输入参数,这种时候我们可以利用另一种形式的入口函数来实现:

```c
int main(int argc, char *argv[]){
    代码段
}

```

+ argc 是入口参数的长度(几个参数)
+ argv 则是由输入字符串组成的数组

> 例:

将之前的牛顿法求开根改为命令行工具,参数为第一位要开的数,第二位为开几次方根,精度规定为0.0000001,如果达不到,那允许最多迭代500次

牛顿法扩展都n次方根$ \sqrt[k] a $的表达式为:

$x_{n+1} = x_n - \frac {x_n^k-a} {kx_n^{k-1}} = \frac {k-1}{k} x_n + \frac {a}{kx_n^{k-1}}$



```python
%%writefile src/C5/Newton_method_sqrt.cpp


#include <stdio.h>
#include <math.h>
#include <stdlib.h>
const double EPS  = 0.0000001;

double newton_method(double a,int n){
    double x=0,last_x=0;
    if (a>0){
        x = a/n;
        for(int i = 0;i < 500;i++){
            last_x = x;
            x = last_x - last_x*(1-a*pow(last_x,-n))/n;
            if(fabs(last_x - x) < EPS){
                break;
            }
        }
        return x;
    } else if (a == 0){
        return 0;
    } else if (a == 1){
        return 1;
    } else{
        return -1;
    }

}

int main(int argc, char *argv[]){
    if (argc != 3) {
        printf("参数错误,参数有%d个,请传入要开方的数和开多少次方\n",argc-1);
        return 0;
    }else{
        double a= atof(argv[1]),result = 0;
        int n = atoi(argv[2]);
        result = newton_method(a,n);
        if (result < 0){
            printf("%lf无法在实数范围内求开方\n",a);
            return 0;
        }else{
            printf("%lf的%d次方根是%lf\n",a,n,result);
            return 0;
        }
    }
}

```

    Overwriting src/C5/Newton_method_sqrt.cpp



```python
!g++-7 -o bin/Newton_method_sqrt src/C5/Newton_method_sqrt.cpp
```


```python
!bin/Newton_method_sqrt
```

    参数错误,参数有0个,请传入要开方的数和开多少次方



```python
!bin/Newton_method_sqrt 2
```

    参数错误,参数有1个,请传入要开方的数和开多少次方



```python
!bin/Newton_method_sqrt 3 3
```

    3.000000的3次方根是1.442250


## 用C/C++构建命令行工具

C标准库提供了一个标准的头文件来便利的构建命令行工具`getopt`,他在`unistd.h`中

`getopt()`用来分析命令行参数.参数`argc`和`argv`是由`main()`传递的参数个数和内容.参数`optstring`则代表欲处理的选项字符串.此函数会返回在`argv`中下一个的选项字母,此字母会对应参数`optstring`中的字母.如果选项字符串里的字母后接着冒号":".则表示还有相关的参数,全域变量`optarg` 即会指向此额外参数.如果`getopt()`找不到符合的参数则会印出错信息,并将全域变量`optopt`设为"?"字符,如果不希望`getopt()`印出错信息,则只要将全域变量`opterr`设为0即可.

### 短参数的定义

`getopt()`使用`optstring`所指的字串作为短参数列表,像`"1ac:d::"`就是一个短参数列表.短参数的定义是一个`'-'`后面跟一个字母或数字,象`-a`, `-b`就是一个短参数.每个数字或字母定义一个参数.

其中短参数在`getopt`定义里分为三种：

+ 不带值的参数,它的定义即是参数本身
+ 必须带值的参数,它的定义是在参数本身后面再加一个冒号
+ 可选值的参数,它的定义是在参数本身后面加两个冒号

在这里拿上面的`"1ac:d::"`作为样例进行说明,其中的
+ `1`,`a`就是不带值的参数
+ `c`是必须带值的参数
+ `d`是可选值的参数

在实际调用中，`'-1 -a -c cvalue -d'`, `'-1 -a -c cvalue -ddvalue'`, `'-1a -ddvalue -c cvalue'`都是合法的.
这里需要注意三点:

+ 不带值的参数可以连写,像`1`和`a`是不带值的参数,它们可以`-1` `-a`分开写,也可以`-1a`或`-a1`连写.
+ 参数不分先后顺序,`'-1a -c cvalue -ddvalue'`和`'-d -c cvalue -a1'`的解析结果是一样的.
+ 要注意可选值的参数的值与参数之间不能有空格,必须写成`-ddvalue`这样的格式,如果写成`-d dvalue`这样的格式就会解析错误.

### 返回值

`getopt()`每次调用会逐次返回命令行传入的参数. 　 
+ 当没有参数的最后的一次调用时,`getopt()`将返回-1.　 
+ 当解析到一个不在`optstring`里面的参数，或者一个必选值参数不带值时,返回'?'.　 
+ 当`optstring`是以':'开头时,缺值参数的情况下会返回':',而不是'?'.


```python
%%writefile src/C5/sqrt_opt.cpp
#include <stdlib.h>
#include <unistd.h>
#include <iostream>
#include <string>
#include <math.h>
using std::string;
using std::cout;
using std::endl;

int main(int argc, char **argv)  {  
    int ch; 
    double result;
    opterr = 0;  
    string version = "0.1.0";
    while ((ch = getopt(argc,argv,"s:v\n"))!=-1){  
        switch(ch){  
            case 'v':  
                cout<<("option v: %s\n",version)<<endl;  
                break;  
            case 's':
                result = sqrt(atoi(optarg));
                cout<<("%f\n",result)<<endl;
                break;
            default:  
                cout<<"wrong args\n"<<endl;  
        }  
    }  
    return 0;
}  
```

    Overwriting src/C5/sqrt_opt.cpp



```python
!g++-7 -o bin/sqrt_opt src/C5/sqrt_opt.cpp
```


```python
!./bin/sqrt_opt -v
```

    0.1.0



```python
!./bin/sqrt_opt -s36
```

    6


# 函数重载

C++中函数重载是在C++语言基础上的一大特色,不过有好也有坏.虽然C++的函数重载大大方便了编程人员,但是却有时候使用不当会引起问题,最典型的就是函数重载的二义性问题.首先我们知道C++函数重载的条件,以及C++中为什么可以函数重载,这样才可以避免C++函数重载中的二义性问题.

C++函数重载的条件有三个:

1. 函数必须位于同一作用域之中.(重载顾名思义是地位相同的两个函数,可以说两个函数是平等的,所以凭什么有的函数作用域大呢,那自然就是同一作用域)
2. 函数名必须相同.
3. 最重要的就是参数列表不同.参数列表不同又可以分为:

    1. 参数个数不同 
    2. 参数类型不同 
    3. 参数顺序不同
    满足以上三条任意一条就可以
    
函数的返回值可以相同，也可以不同.

我们都知道,如果在c语言中定义一个或者多个同名的函数,哪怕是参数的类型,个数,顺序都不同可不可以进行重载.




```python
%%writefile src/C5/overloading_test.cpp
#include <iostream>
#include <string>

using std::string;
using std::cout;
using std::endl;
        
int My_add(int a, int b){  
    return (a + b);  
}  
  
string My_add(string a, string b){  
    return (a + b);  
}  
  
int main(){  
    auto m = 10;  
    auto n = 20;  
    auto ret = My_add(m, n);
    cout << ret << endl;
    string x = "asdfg";

    string y = "qwert";
    string re = My_add(x, y);
    cout << re << endl;
    return 0;  
}  

```

    Overwriting src/C5/overloading_test.cpp



```python
!g++-7 -o bin/overloading_test src/C5/overloading_test.cpp
```


```python
!./bin/overloading_test
```

    30
    asdfgqwert


# 内联函数

`inline`关键字可以指定函数为内联函数,内联函数没有多余的函数调用开销,是一种以空间换时间的技术

```C++
inline int min(int first, int secend) {/****/};
```

## 慎用内联

内联能提高函数的执行效率,为什么不把所有的函数都定义成内联函数?如果所有的函数都是内联函数,还用得着"内联"这个关键字吗?内联是以代码膨胀(复制)为代价,仅仅省去了函数调用的开销,从而提高函数的执行效率.如果执行函数体内代码的时间,相比于函数调用的开销较大,那么效率的收获会很少.另一方面,每一处内联函数的调用都要复制代码,将使程序的总代码量增大,消耗更多的内存空间.

以下情况不宜使用内联:

1. 如果函数体内的代码比较长，使用内联将导致内存消耗代价较高.
2. 如果函数体内出现循环,那么执行函数体内代码的时间要比函数调用的开销大.类的构造函数和析构函数容易让人误解成使用内联更有效.要当心构造函数和析构函数可能会隐藏一些行为,如"偷偷地"执行了基类或成员对象的构造函数和析构函数.所以不要随便地将构造函数和析构函数的定义体放在类声明中.一个好的编译器将会根据函数的定义体,自动地取消不值得的内联(这进一步说明了inline不应该出现在函数的声明中).



# 匿名函数[C++11]

在c++11中新增了对lambda函数的支持,C++11 的 lambda 表达式规范如下：


+ `[ capture ] ( params ) mutable exception attribute -> ret { body }`

    完整的 lambda 表达式形式
    
    
+ `[ capture ] ( params ) -> ret { body }`

    `const`类型的 lambda 表达式，该类型的表达式不能改捕获("capture")列表中的值
    
    
+ `[ capture ] ( params ) { body }`

    省略了返回值类型的lambda表达式，但是该lambda表达式的返回类型可以按照下列规则推演出来:
    + 如果lambda代码块中包含了return语句，则该lambda表达式的返回类型由return语句的返回类型确定.
    + 如果没有return语句，则类似`void f(...)`函数.


+ `[ capture ] { body }`

    省略了参数列表，类似于无参函数`f()`.

    
`mutable`修饰符说明lambda表达式体内的代码可以修改被捕获的变量,并且可以访问被捕获对象的`non-const`方法

`exception`说明lambda表达式是否抛出异常(noexcept)，以及抛出何种异常，类似于`void f() throw(X, Y)`

`attribute`用来声明属性。

另外,`capture`指定了在可见域范围内lambda表达式的代码内可见得外部变量的列表,具体解释如下：

+ `[a,&b]` a变量以值的方式呗捕获，b以引用的方式被捕获.
+ `[this]` 以值的方式捕获 this 指针.
+ `[&]` 以引用的方式捕获所有的外部自动变量.
+ `[=]` 以值的方式捕获所有的外部自动变量.
+ `[]` 不捕获外部的任何变量.

此外`params`指定lambda表达式的参数。




```python
%%writefile src/C5/lambda_test.cpp
#include <vector>
#include <iostream>
#include <algorithm>
#include <functional>
 
int main()
{
    std::vector<int> c { 1,2,3,4,5,6,7 };
    int x = 5;
    c.erase(std::remove_if(c.begin(),
                           c.end(),
                           [x](int n){ return n < x; }
                          ),
            c.end());
 
    std::cout << "c: ";
    for (auto i: c) {
        std::cout << i << ' ';
    }
    std::cout << '\n';
 

    auto func1 = [](int i) { return i+4; };
    std::cout << "func1: " << func1(6) << '\n'; 
 

    std::function<int(int)> func2 = [](int i) { return i+4; };
    std::cout << "func2: " << func2(6) << '\n'; 
}
```

    Overwriting src/C5/lambda_test.cpp



```python
!g++-7 -o bin/lambda_test src/C5/lambda_test.cpp
```


```python
!bin/lambda_test
```

    c: 5 6 7 
    func1: 10
    func2: 10

