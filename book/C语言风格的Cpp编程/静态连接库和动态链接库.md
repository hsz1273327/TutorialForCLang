
# 静态连接库和动态链接库

静态链接库与动态链接库都是共享代码的方式,在linux中,动态链接库通常用.so为后缀，而静态链接库用.a为后缀。

## 静态链接库

当要使用静态链接库时，连接器会找出程序所需的函数，然后将它们拷贝到执行文件，由于这种拷贝是完整的，所以一旦连接成功，静态程序库也就不再需要了。

### 静态链接库的优点 

+ 代码装载速度快，执行速度略比动态链接库快； 

+ 只需保证在开发者的计算机中有正确的.LIB文件，在以二进制形式发布程序时不需考虑在用户的计算机上.LIB文件是否存在及版本问题，可避免DLL地狱等问题。 
### 不足之处

+ 使用静态链接生成的可执行文件体积较大，包含相同的公共代码，造成浪费



## 创建静态库

我们还是以之前的二维向量作为例子,代码请看'头文件与多文件编译'中的相关代码

### 创建链接文件

`.o`文件的意思是连接对象,他是编译静态库要用到的一个中间形态,使用gcc编译源文件成为连接对象文件


```python
%%writefile src/C10/source/binary_operator.h
#ifndef BINARY_OPERATOR_H
    #define BINARY_OPERATOR_H//一般是文件名的大写 头文件结尾写上一行
    #include "binary_vector.h"
    BINARY_VECTOR add(BINARY_VECTOR,BINARY_VECTOR);
    float mul(BINARY_VECTOR,BINARY_VECTOR);
#endif

```

    Overwriting src/C10/source/binary_operator.h



```python
%%writefile src/C10/source/binary_operator.cpp

#include "binary_operator.h"
BINARY_VECTOR add(BINARY_VECTOR a,BINARY_VECTOR b){
    BINARY_VECTOR result = {a.x+b.x,a.y+b.y};
    return result;
}
float mul(BINARY_VECTOR a,BINARY_VECTOR b){
    float result = a.x*b.x+a.y*b.y;
    return result;
}
```

    Overwriting src/C10/source/binary_operator.cpp



```python
!g++-7 -c src/C10/source/binary_operator.cpp -o lib/C10/binary_operator.o
```


```python
%%writefile src/C10/source/unary_operator.h
#ifndef UNARY_OPERATOR_H
    #define UNARY_OPERATOR_H//一般是文件名的大写 头文件结尾写上一行
    #include "binary_vector.h"
    #include <math.h>
    float mod(BINARY_VECTOR);
#endif
```

    Overwriting src/C10/source/unary_operator.h



```python
%%writefile src/C10/source/unary_operator.cpp
#include "unary_operator.h"
float mod(BINARY_VECTOR a){
    float result = sqrt(a.x*a.x+a.y*a.y);
    return result;
}

```

    Overwriting src/C10/source/unary_operator.cpp



```python
!g++-7 -c src/C10/source/unary_operator.cpp -o lib/C10/unary_operator.o
```

### 生成静态库文件.a


一般我们用ar（archive，归档的意思）把多个目标文件集合起来生成.a文件


```python
!ar -r lib/C10/libbvector.a lib/C10/binary_operator.o lib/C10/unary_operator.o
```

### 调用静态库

我们需要为静态库编写一个头文件用以声明库中的内容


```python
%%writefile src/C10/source/binary_vector.h
#ifndef BINARY_VECTOR_H
#define BINARY_VECTOR_H//一般是文件名的大写 头文件结尾写上一行


typedef struct {
    float x;
    float y;
} BINARY_VECTOR;


#endif
```

    Overwriting src/C10/source/binary_vector.h


然后编写一个测试文件(静态库动态库测试文件代码相同)


```python
%%writefile src/C10/sll/test.cpp

#include <stdio.h>
#include "bvector.h"


int main(void){
    BINARY_VECTOR A = {1,2},B = {3,4};
    printf("mod(A)=%f\n",mod(A));
    printf("mod(B)=%f\n",mod(B));
    printf("mul(A,B)=%f\n",mul(A,B));
    BINARY_VECTOR result = add(A,B);
    printf("add(A,B)=<%f,%f>\n",result.x,result.y);
}
```

    Overwriting src/C10/sll/test.cpp


使用g++ 编译我们的测试文件


```python
!g++-7 src/C10/sll/test.cpp -L lib/C10 -l bvector -I lib/C10 -o bin/slltest 
```


```python
!bin/slltest
```

    mod(A)=2.236068
    mod(B)=5.000000
    mul(A,B)=11.000000
    add(A,B)=<4.000000,6.000000>


+ -L 选项告诉编译器去哪里找需要的库文件
+ -l -lbvector告诉编译器要链接libbvector库
+ -I 选项告诉去哪个文件夹下找头文件

## 动态链接库

某个程序在运行中要调用某个动态链接库函数的时候，操作系统首先会查看所有正在运行的程序，看在内存里是否已有此库函数的拷贝了。如果有，则让其共享那一个拷贝；只有没有才链接载入。在程序运行的时候，被调用的动态链接库函数被安置在内存的某个地方，所有调用它的程序将指向这个代码段。因此，这些代码必须使用相对地址，而不是绝对地址。在编译的时候，我们需要告诉编译器，这些对象文件是用来做动态链接库的，所以要用地址不无关代码（Position Independent Code (PIC))。

注意：Linux下进行连接的缺省操作是首先连接动态库，也就是说，如果同时存在静态和动态库，不特别指定的话，将与动态库相连接。


###  动态链接库的优点 

+ 更加节省内存并减少页面交换；

+ 动态链接文件与可执行文件独立，只要输出接口不变（即名称、参数、返回值类型和调用约定不变），更换动态链接文件不会对可执行文件造成任何影响，因而极大地提高了可维护性和可扩展性；

+ 不同编程语言编写的程序只要按照函数调用约定就可以调用同一个动态函数；

+ 适用于大规模的软件开发，使开发过程独立、耦合度小，便于不同开发者和开发组织之间进行开发和测试。

### 不足之处

+ 使用动态链接库的应用程序不是自完备的，它依赖的动态模块也要存在，如果使用载入时动态链接，程序启动时发现动态模块不存在，系统将终止程序并给出错误信息。而使用运行时动态链接，系统不会终止，但由于动态库中的导出函数不可用，程序会加载失败
+ 速度比静态链接慢。当某个模块更新后，如果新模块与旧的模块不兼容，那么那些需要该模块才能运行的软件，统统撕掉。

### 编译动态链接库


```python
!g++-7 src/C10/source/binary_operator.cpp src/C10/source/unary_operator.cpp  -fPIC -shared -o lib/C10/libbvct.so
```

使用g++编译我们的测试文件


```python
%%writefile src/C10/dll/test.cpp
#include <stdio.h>
#include "bvector.h"


int main(void){
    BINARY_VECTOR A = {1,2},B = {3,4};
    printf("mod(A)=%f\n",mod(A));
    printf("mod(B)=%f\n",mod(B));
    printf("mul(A,B)=%f\n",mul(A,B));
    BINARY_VECTOR result = add(A,B);
    printf("add(A,B)=<%f,%f>\n",result.x,result.y);
}
```

    Overwriting src/C10/dll/test.cpp



```python
!g++-7 src/C10/dll/test.cpp -L lib/C10 -l bvct -I lib/C10 -o bin/dlltest 
```


```python
!bin/dlltest 
```

    mod(A)=2.236068
    mod(B)=5.000000
    mul(A,B)=11.000000
    add(A,B)=<4.000000,6.000000>

