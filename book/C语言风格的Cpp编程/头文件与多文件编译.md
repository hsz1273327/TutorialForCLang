
# 头文件与多文件编译

C++语言的模块化编程使用的是组合的方式.头文件用于定义和声明,源文件用于实现方法,一般来说头文件以`.h`作为扩展名,并且名字与源文件保持一致,比如我们有个头文件叫test.h,那么
为了避免重复引入,会在头文件中写上
```c
#ifndef _TEST_H
#define _TEST_H//一般是文件名的大写 头文件结尾写上一行
    要引入的头文件
    要定义的类型
    要声明的函数

    ...

#endif
```

这样头文件就只会被导入一次了

而与之对应的源文件,我们只要`#include "test.h"`即可

我们举个例子,以二维向量计算作为要实现的功能,其中包括三个源文件:
+ binary_vector.h 定义二元向量结构
+ unary_operator.cpp 一元运算,包括求向量的模
+ binary_operator.cpp 二元运算,包括求加和内积

以及一个测试文件 test.cpp


```python
%%writefile src/C9/binary_vector.h

#ifndef BINARY_VECTOR_H
#define BINARY_VECTOR_H//一般是文件名的大写 头文件结尾写上一行

typedef struct {
    float x;
    float y;
} BINARY_VECTOR;


#endif

```

    Overwriting src/C9/binary_vector.h



```python
%%writefile src/C9/unary_operator.h

#ifndef UNARY_OPERATOR_H
    #define UNARY_OPERATOR_H//一般是文件名的大写 头文件结尾写上一行
    #include "binary_vector.h"
    #include <math.h>
    float mod(BINARY_VECTOR);
#endif
```

    Overwriting src/C9/unary_operator.h



```python
%%writefile src/C9/unary_operator.cpp

#include "unary_operator.h"
float mod(BINARY_VECTOR a){
    float result = sqrt(a.x*a.x+a.y*a.y);
    return result;
}
```

    Overwriting src/C9/unary_operator.cpp



```python
%%writefile src/C9/binary_operator.h


#ifndef BINARY_OPERATOR_H
    #define BINARY_OPERATOR_H//一般是文件名的大写 头文件结尾写上一行
    #include "binary_vector.h"
    BINARY_VECTOR add(BINARY_VECTOR,BINARY_VECTOR);
    float mul(BINARY_VECTOR,BINARY_VECTOR);
#endif

```

    Overwriting src/C9/binary_operator.h



```python
%%writefile src/C9/binary_operator.cpp

#include "binary_operator.h"
BINARY_VECTOR add(BINARY_VECTOR a,BINARY_VECTOR b){
    BINARY_VECTOR result = {a.x+b.x,a.y+b.y};
    return result;
}
float mul(BINARY_VECTOR a,BINARY_VECTOR b){
    float result = a.x*b.x+a.y*b.y;
    return result;
}

```

    Overwriting src/C9/binary_operator.cpp



```python
%%writefile src/C9/test.cpp

#include <stdio.h>
#include "binary_vector.h"
#include "binary_operator.h"
#include "unary_operator.h"

int main(void){
    BINARY_VECTOR A = {1,2},B = {3,4};
    printf("mod(A)=%f\n",mod(A));
    printf("mod(B)=%f\n",mod(B));
    printf("mul(A,B)=%f\n",mul(A,B));
    BINARY_VECTOR result = add(A,B);
    printf("add(A,B)=<%f,%f>\n",result.x,result.y);
}

```

    Overwriting src/C9/test.cpp


预编译:


```python
!g++-7 -o bin/test src/C9/*.cpp
```


```python
!bin/test
```

    mod(A)=2.236068
    mod(B)=5.000000
    mul(A,B)=11.000000
    add(A,B)=<4.000000,6.000000>


# 头文件使用建议


头文件并不是什么都申明的,事实上头文件的主要所用是暴露接口,别人导入头文件就可以使用其中对应的函数,类或者模板了.因此头文件的使用建议是:

+ 只写要暴露给外部使用的申明
+ 只写模板
+ 必须包含防止重复引入的宏
