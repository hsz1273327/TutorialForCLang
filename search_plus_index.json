{"./":{"url":"./","title":"Introduction","keywords":"","body":"TutorialFoCLang 本攻略是介绍C,不是语法书而是特定使用场景下的入门参考手册.本文针对的对象是已经熟练使用python的数据科学工作人员.分为3个主要应用场景: 使用C编写数学模型 封装用C编写的模型为python可调用的模块 在嵌入式设备上使用C语言 因为这个场景的限制,本书会涉及的内容只是C.而且许多针对大型程序的方法论以及语法将在这边不适用.本书基本不涉及设计模式,基本不涉及一些数据结构与算法的实现,这本书不适合计算机专业的人看,因为老实说计算机专业的人和数据科学专业的人对于程序,算法的理解有很大不同. 不过作为一本入门书,当然还是会带有语法,只是这些语法会结合例子使用. 这本数的结构大致会和讲python那本一致,内容也偏向实用,希望的是一本书看完就可以在与本书相同的场景下使用C.并且对整个C的基本原理有个大致了解. 本书的主要内容 本文的每一章都将以一个完整例子开始,这章的内容就是逐步的完善这个例子. 主要内容主要包括: 工具链 数据模型 基本语法 IO操作 宏与编译期操作 异常处理 多线程 Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-08 14:03:22 "},"工具链/":{"url":"工具链/","title":"工具链","keywords":"","body":"C的工具链 工欲善其事必先利其器,python,javascript这些相对现代的语言都有着成熟高效的众多工具链提高开发效率和方便代码管理.而像go,rust这样的新兴编程语言,代码风格检测,测试框架,包管理工具甚至直接作为语言的一部分存在.C作为一个历史悠久的编程语言当然也有这些工具,但同样由于历史悠久,这些工具都相当碎片化,但是C工具但往往各自为政.这点上有点像现在的node.js. 本篇讲工具链,很多工具去他们官网看会觉得特别有年代感(python也有很多这样的官网).其主要原因就是历史悠久成熟稳定. 一般说工具链主要是这样几个工具: 项目结构 编译与运行环境 编译配套工具 测试工具 编程风格 文档工具 python接口包装 另外就是额外的制作命令行工具了.本章除了C的工具链,同时也会讲怎么用c写命令行工具.因为C是编译型语言,测试也是需要编译出来才可以运行的.而测试往往需要通过命令行来作为输入. 本章的代码在tutorialforclang/c-tool-chain这个项目中 Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-05 01:04:20 "},"工具链/项目结构.html":{"url":"工具链/项目结构.html","title":"项目结构","keywords":"","body":"项目结构 c语言是系统级的静态语言,需要编译为可执行文件才可以执行.而且比较原始,在语言设计之初就没有考虑什么依赖管理,项目管理这类的问题,因此在开始C语言学习前我们先来约定下项目的结构. 而且去github上可以发现各个项目的文件组织结构都不尽相同,按我的习惯通常简单的项目我们会把源代码放在一起,使用的第三方依赖的内容放在一起,而编译好的结果放在一起.比如: build文件夹 存放编译的结果 bin 存放可执行文件 lib 存放编译好的动态库或者静态库 inc 存放编译好的库的头文件 test文件夹 存放测试文件 虽然C语言是静态语言,但测试驱动编程依然是一个好的方法论.编译好的测试用可执行文件可以放在build/bin里面,同时文件名应该包含test字样 source文件夹 存放源码和一些依赖 inc 编译需要用到的头文件 lib 编译需要用到的库文件 obj 编译过程中产生的object文件,如果有必要的话 src 编译用到的源文件 python文件夹 存放项目的python的C包装,如果需要的话才会有,由于大多数语言都可以使用ABI对接C语言,这种针对某种特定语言的包装器就放在以语言名命名的文件夹中. _wrapper.c和py.py c写的包装源码配合python写的包装,一般用于将函数封装成类 py.pyx和 py.pyd cython写的包装(如果使用cython的话) test 测试文件夹,用于测试包装效果 setup.py python模块安装文件 一般来说,个人认为以C为主的项目最好不要把包放到pypi,以防止安装出问题.这种项目的python接口还是强制源码安装比较靠谱. document 项目文档文件夹 CMakeLists.txt/makefile cmake/make项目设置文件 Doxyfile doxygen项目设置文件 Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-04 15:44:59 "},"工具链/编译与运行环境.html":{"url":"工具链/编译与运行环境.html","title":"编译与运行环境","keywords":"","body":"编译与运行环境 C是静态语言,需要编译后才能执行.而编译的工具就是编译器.最常见的C编译器有: GNU C开源大佬,linux上编译器的的代名词,在osx上也可以使用homebrew安装,windows上则有MinGW作为其移植版. llvm+Clang苹果资助的编译器,也是osx下默认的编译器.有不少黑科技,比如C++的repl,jit技术等,一点不像保守的苹果资助的东西. MSVC微软家的御用编译器,vs内置的编译器.只能在windows下使用,要在命令行中使用需要将其加入环境变量Path GNUC GNU C是标准C的一个实现,当然在满足标准C规范的前提下他还有一些其他扩展,比如支持函数内嵌套定义函数,本文使用的就是GNU C.GNU C使用的编译器叫做gcc,一般来说linux下的C编译器就是gcc,但在其他平台上也并不是没有gcc的实现: mac osx上可以使用homebrew安装gcc,安装好后,由于osx固定的将gcc命令链接到clang.要使用的话只能使用gcc-7形式的命令,其中7是指gcc的大版本. windows上则可以安装mingw来获取gnu的环境,可以通过anaconda安装它,需要注意的是mingw的安装可能会在你为python安装需要用C编译的包时带来一些错误.所以谨慎使用. gcc工具的版本更新是很快的,一般来书并不需要追求新版本,像windows上使用anaconda安装的话默认版本是4.7版本,其实我们完全可以就使用这个版本的gcc.它足够稳定可靠. C语言与编译 对于C来说,编译其本质就是将源文件转化为二进制库文件或者可执行文件的过程,我们以一个小程序来作为例子,使用gnu gcc工具来演示整个编译过程: %%writefile ./code/compiler/S1/source/src/helloworld.c #include int main(){ printf(\"hello world\"); return 0; } Overwriting ./code/compiler/S1/source/src/helloworld.c 一般来说编译器并不是铁板一块,而是模块化设计 前面几个步骤是用于检测代码是否有语法错误的.而实际编译代码可以分为如下步骤: 解析代码文件生成待编译代码 将代码转译为汇编语言 汇编代码生成对象 将对象与其他依赖的对象进行连接 步骤一:解读头文件,结合源文件,组合生成真正的待编译代码 这一步可以使用-E指令实现.这个过程只激活预处理,不生成文件,而是输出到标准输出.因此你需要把它重定向到一个输出文件里.,一般来说我们用后缀.i保存这个文件. 这一步实际上做这些事儿: 宏的替换 注释的消除 还有找到相关的库文件 执行模板,将模板翻译成源码的实现 将#include文件的全部内容插入.若用<>括起文件则在系统的INCLUDE目录中寻找文件,若用\" \"括起文件则在当前目录中寻找文件. gcc -E ./code/compiler/S1/source/src/helloworld.c 步骤二:将代码转译成汇编语言 这一步可以使用-S指令实现.这个过程就是将上一步的这串字符转译成汇编代码.汇编代码说白了就是二进制代码中操作与资源的的替代而已.因此说C/C++和汇编其实也就一步之遥.这也是为什么很多时候嵌入式设备使用C语言编写的原因. 生成helloworld.s文件,.s文件表示是汇编文件，用编辑器打开就都是汇编指令了 !gcc -o ./code/compiler/S1/source/src/helloworld.s \\ -S ./code/compiler/S1/source/src/helloworld.c cat ./code/compiler/S1/source/src/helloworld.s 步骤三:将汇编语言的代码再编译为二进制代码 这一步使用-c指令,将汇编代码编译位二进制代码.注意这依然不是可执行文件,因为其中使用的函数很可能并不包含在二进制文件中. !gcc -o ./code/compiler/S1/source/obj/helloworld.o \\ -c ./code/compiler/S1/source/src/helloworld.c cat ./code/compiler/S1/source/obj/helloworld.o 步骤四: 链接相关的二进制代码生成可执行文件 这一步就是将与文件相关的函数库引入以生成最终的可执行文件. !gcc -o ./code/compiler/S1/build/bin/helloworld \\ ./code/compiler/S1/source/obj/helloworld.o !./code/compiler/S1/build/bin/helloworld hello world 接口与实现 C语言可以接口与实现分离,也就是说同样一份接口,后面实际使用的实现形式可以是千差万别的,可以是 动态/静态库 单一源文件 多个源文件组合 而接口和实现也不是绑定的,这样就带来了灵活性.一般来说一个模块含有一个接口文件,它的后面可能按功能等分成多个实现用的源文件,而编译好后又是一个动态/静态库.而要用这个库的时候我们再为它写带main函数的源文件. 下面是一个例子 %%writefile ./code/compiler/S2/source/inc/binary_vector.h /* $Id$ */ #ifndef BINARY_VECTOR_H #define BINARY_VECTOR_H//一般是文件名的大写 头文件结尾写上一行 struct BINARY_VECTOR { float x; float y; }; typedef struct BINARY_VECTOR *BINARY_VECTOR_P; BINARY_VECTOR_P VEC_new(void); BINARY_VECTOR_P VEC_init(float x,float y); void VEC_del(BINARY_VECTOR_P); float VEC_mod(BINARY_VECTOR_P); BINARY_VECTOR_P VEC_add(BINARY_VECTOR_P,BINARY_VECTOR_P); float VEC_mul(BINARY_VECTOR_P ,BINARY_VECTOR_P); #endif Overwriting ./code/compiler/S2/source/inc/binary_vector.h %%writefile ./code/compiler/S2/source/src/struct_operator.c #include \"binary_vector.h\" #include #define T BINARY_VECTOR_P T VEC_new(void){ T ptr; ptr = (T) malloc(((long)sizeof *(ptr))); ptr->x = 0.0; ptr->y = 0.0; return ptr; } T VEC_init(float x,float y){ T ptr; ptr = (T) malloc(((long)sizeof *(ptr))); ptr->x = x; ptr->y = y; return ptr; } void VEC_del(T ptr){ if (ptr) free(ptr); } #undef T Overwriting ./code/compiler/S2/source/src/struct_operator.c %%writefile ./code/compiler/S2/source/src/unary_operator.c #include \"binary_vector.h\" #include #define T BINARY_VECTOR_P float VEC_mod(T a){ float result = sqrt(a->x*a->x+a->y*a->y); return result; } #undef T Overwriting ./code/compiler/S2/source/src/unary_operator.c %%writefile ./code/compiler/S2/source/src/binary_operator.c #include \"binary_vector.h\" #define T BINARY_VECTOR_P T VEC_add(T a, T b) { float x = a->x + b->x; float y = a->y + b->y; T result; result = VEC_new(); result->x = x; result->y = y; return result; } float VEC_mul(T a, T b) { float result = a->x * b->x + a->y * b->y; return result; } #undef T Overwriting ./code/compiler/S2/source/src/binary_operator.c %%writefile ./code/compiler/S2/test/test.c #include #include \"binary_vector.h\" int main(void){ struct BINARY_VECTOR A = {1,2},B = {3,4}; printf(\"mod(A)=%f\\n\",VEC_mod(&A)); printf(\"mod(B)=%f\\n\",VEC_mod(&B)); printf(\"mul(A,B)=%f\\n\",VEC_mul(&A,&B)); BINARY_VECTOR_P result = VEC_add(&A,&B); printf(\"add(A,B)=\\n\",result->x,result->y); } Overwriting ./code/compiler/S2/test/test.c !gcc -o ./code/compiler/S2/build/bin/test \\ -I ./code/compiler/S2/source/inc \\ ./code/compiler/S2/source/src/*.c \\ ./code/compiler/S2/test/test.c !./code/compiler/S2/build/bin/test mod(A)=2.236068 mod(B)=5.000000 mul(A,B)=11.000000 add(A,B)= C的特点之一就是申明与实现分离,这也决定了其开发方式和python截然相反,python一般是想到哪里写到哪里,比较适合敏捷开发,而C明显更适合先整体构思好了再动手写.因此才说python适合原型开发快速迭代,而C适合写(接口明确稳定的)业务. 链接库 Java当初以跨平台作为重要的卖点,号称一次编译随处运行.其实C/C++当初也是这么宣传的,只不过对于C来说跨平台指的是写好源码,头文件后可以在各个平台编译运行(系统资源接口的调用除外).但是显然这种跨平台很不彻底. 实际上还有另外一种复用的方式,就是将代码编译成链接库.再在步骤四的时候链接到最终的代码中.链接库分为静态链接库和动态链接库两种. 静态链接库与动态链接库都是共享代码的方式 链接库是由第三步的.o文件组合而成,各个系统平台使用不同的规范实现,具体是什么规范这边不细说.总之不同平台编译出来的链接库是不能兼容的.但其实问题也不太大,完全可以编译好后共享出去. 链接库的使用方法 无论静态链接库还是动态链接库,命名规则都是libxxx+后缀,但编译的时候指定的名字就是xxx.而调用方法都是用#include导入后就可以直接使用. 很多时候我们为了隐藏代码实现,在共享的时候可以指定好平台操作系统,之后只共享出链接库和头文件.这种方式不仅可以防止代码被人篡改或者侵权,更可以精简接口. 静态连接库 在linux中,而静态链接库用.a为后缀.windows中以.lib为后缀.osx中也以.a或.framework为后缀.当要使用静态链接库时,连接器会找出程序所需的函数,然后将它们拷贝到执行文件,由于这种拷贝是完整的,所以一旦连接成功,静态程序库也就不再需要了. 静态链接库的优点 代码装载速度快，执行速度略比动态链接库快； 只需保证在开发者的计算机中有正确的动态库文件,在以二进制形式发布程序时不需考虑在用户的计算机上的库文件是否存在及版本问题.这种方式依赖少,非常适合分发. 不足之处 使用静态链接生成的可执行文件体积较大,包含相同的公共代码,造成浪费 构建静态链接库 我们还是以之前的二维向量作为例子,一般我们用ar(archive,归档的意思)把多个目标文件集合起来生成静态链接库文件. !gcc -c \\ -o ./code/compiler/S2/source/obj/struct_operator.o \\ -I ./code/compiler/S2/source/inc \\ ./code/compiler/S2/source/src/struct_operator.c !gcc -c \\ -o ./code/compiler/S2/source/obj/binary_operator.o \\ -I ./code/compiler/S2/source/inc \\ ./code/compiler/S2/source/src/binary_operator.c !gcc -c \\ -o ./code/compiler/S2/source/obj/unary_operator.o \\ -I ./code/compiler/S2/source/inc \\ ./code/compiler/S2/source/src/unary_operator.c !ar crv ./code/compiler/S2/build/lib/libvector.a \\ ./code/compiler/S2/source/obj/*.o r - ./code/compiler/S2/source/obj/binary_operator.o r - ./code/compiler/S2/source/obj/unary_operator.o a - ./code/compiler/S2/source/obj/struct_operator.o !cp ./code/compiler/S2/source/inc/binary_vector.h ./code/compiler/S2/build/inc/binary_vector.h 使用静态链接库 要调用静态库我们依然需要头文件,我们需要一个头文件来描述这个静态库中的接口.我们可以使用之前的头文件vector.hpp.要使用静态链接库我们需要用-L来指定静态库所在的地址,再使用-l来指定静态库的名字.注意静态库的名字. !gcc \\ -o ./code/compiler/S2/build/bin/test_a \\ -I ./code/compiler/S2/build/inc \\ -L ./code/compiler/S2/build/lib \\ ./code/compiler/S2/test/test.c \\ -l vector !./code/compiler/S2/build/bin/test_a mod(A)=2.236068 mod(B)=5.000000 mul(A,B)=11.000000 add(A,B)= 需要注意,使用静态库的时候是要注意文件顺序的,通常我们要习惯将-l的内容放在编译命令的最后面.因为如果相同的命名在不同的库中有不同的定义,那么顺序不同结果就不同了. 动态连接库 在linux中,动态链接库通常用.so为后缀.在windows中,动态链接库通常用.dll为后缀.在osx中,动态链接库通常用.dylib为后缀. 某个程序在运行中要调用某个动态链接库函数的时候,操作系统首先会查看所有正在运行的程序,看在内存里是否已有此库函数的拷贝了.如果有,则让其共享那一个拷贝;只有没有才链接载入.在程序运行的时候,被调用的动态链接库函数被安置在内存的某个地方,所有调用它的程序将指向这个代码段.因此,这些代码必须使用相对地址,而不是绝对地址.在编译的时候,我们需要告诉编译器,这些对象文件是用来做动态链接库的,所以要用地址不无关代码(Position Independent Code (PIC)). 注意:Linux下进行连接的缺省操作是首先连接动态库,也就是说,如果同时存在静态和动态库,不特别指定的话,将与动态库相连接. 动态链接库的优点 更加节省内存并减少页面交换; 动态链接文件与可执行文件独立,只要输出接口不变(即名称、参数、返回值类型和调用约定不变),更换动态链接文件不会对可执行文件造成任何影响,因而极大地提高了可维护性和可扩展性; 不同编程语言编写的程序只要按照函数调用约定就可以调用同一个动态函数; 适用于大规模的软件开发，使开发过程独立、耦合度小,便于不同开发者和开发组织之间进行开发和测试. 不足之处 使用动态链接库的应用程序不是自完备的,它依赖的动态模块也要存在,如果使用载入时动态链接,程序启动时发现动态模块不存在,系统将终止程序并给出错误信息.而使用运行时动态链接,系统不会终止,但由于动态库中的导出函数不可用,程序会加载失败 速度比静态链接慢.当某个模块更新后,如果新模块与旧的模块不兼容,那么那些需要该模块才能运行的软件,统统撕掉. 编译动态链接库 动态链接库可以直接使用gcc编译.需要使用-fPIC指定编译成的是位置无关的共享库,-shared指定连接方式是共享型 !gcc \\ -o ./code/compiler/S2/build/lib/libvector_b.so \\ -fPIC \\ -shared \\ -I ./code/compiler/S2/source/inc \\ ./code/compiler/S2/source/src/* 使用动态库 !gcc \\ -o ./code/compiler/S2/build/bin/test_b \\ -I ./code/compiler/S2/build/inc \\ -L ./code/compiler/S2/build/lib \\ ./code/compiler/S2/test/test.c \\ -l vector_b !./code/compiler/S2/build/bin/test_b mod(A)=2.236068 mod(B)=5.000000 mul(A,B)=11.000000 add(A,B)= 使用宏实现跨平台 我们说过C/C++的跨平台是源码级别的跨平台,但实际上因为操作系统功能的实现有区别,接口也有些区别,因此很多时候我们还是得考虑跨平台问题.其实这个问题python中也有,比如到3.6版本为止windows的ctrl+c操作都无法直接用于协程程序的中断. 在C/C++编程时我们可以像上面定义C接口时一样用宏语句判断是否需要特殊化处理.一般情况下会出问题的也就是windows,下面是特殊化处理的宏片段: #ifdef _MSC_VER #pragma warning(disable:4996) #include #include #else #include #include #include #define CRITICAL_SECTION pthread_mutex_t #define _vsnprintf vsnprintf #endif 当然了更加方便的方式是无视windows. 总结 gcc的常用参数 -o 指定输出的文件 -E 预编译 -S 编译为汇编代码 -c 编译位二进制文件 -L 选项告诉编译器去哪里找需要的库文件 -l -lbvector告诉编译器要链接libbvector库 -I 选项告诉去哪个文件夹下找头文件 -i 指定使用的头文件 -static 链接方式禁止使用动态库。 优点：程序运行不依赖于其他库 缺点：文件比较大 -shared (-G) 此链接方式尽量使用动态库，为默认选项(共享型) 优点：生成文件比较小 缺点：运行时需要系统提供动态库 -symbolic 此链接方式将在建立共享目标文件的时候,把引用绑定到全局符号上. -fpic 编译器就生成位置无关目标码.适用于共享库(shared library).通常能产生更快更小的代码,但有平台限制.编译出的代码将通过全局偏移表(Global Offset Table)中的常数地址访存，动态装载器将在程序开始执行时解析GOT表项. -fPIC 编译器就输出位置无关目标码.适用于动态连接(dynamic linking),即使分支需要大范围转移.该选项会针对某些特殊机型做了特殊处理,比如适合动态链接并能避免超出GOT大小限制之类的错误.而Open64仅仅支持不会导致GOT表溢出的PIC编译. -lstdc++ 放在编译代码最后防止因为C++语法而报错 ar命令常用参数 指令参数 -d 　删除库文件中的成员文件。 -m 　变更成员文件在库文件中的次序。 -p 　显示库文件中的成员文件内容。 -q 　将问家附加在库文件末端。 -r 　将文件插入库文件中。 -t 　显示库文件中所包含的文件。 -x 　自库文件中取出成员文件。 选项参数 a 　将文件插入库文件中指定的成员文件之后。 b 　将文件插入库文件中指定的成员文件之前。 c 　建立库文件。 f 　为避免过长的文件名不兼容于其他系统的ar指令指令，因此可利用此参数，截掉要放入库文件中过长的成员文件名称。 i 　将问家插入库文件中指定的成员文件之前。 o 　保留库文件中文件的日期。 s 　若库文件中包含了对象模式，可利用此参数建立备存文件的符号表。 S 　不产生符号表。 u 　只将日期较新文件插入库文件中。 v 　程序执行时显示详细的信息。 V 　显示版本信息。 ar用来管理一种文档。这种文档中可以包含多个其他任意类别的文件。这些被包含的文件叫做这个文档的成员。ar用来向这种文档中添加、删除、解出成员。成员的原有属性（权限、属主、日期等）不会丢失。 实际上通常只有在开发中的目标静态连接库是这种格式的，所以尽管不是，我们基本可以认为ar是用来操作这种目标链接库（.a文件）的。 常见操作 创建库文件 通常人们使用ar crvu liba.a a.o这样的命令来创建一个库并把a.o添加进去.c关键字告诉ar需要创建一个新库文件,如果没有指定这个标志则ar会创建一个文件,同时会给出一个提示信息,u用来告诉ar如果a.o比库中的同名成员要新,则用新的a.o替换原来的.实际上用ar -r liba.a a.o通常就够 加入新成员 使用ar -r liba.a b.o即可以将b.o加入到liba.a中.默认的加入方式为append，即加在库的末尾.r关键字可以有三个修饰符a, b和i \"a\"表示after,即将新成员加在指定成员之后.例如ar -ra a.c liba.a b.c表示将b.c加入liba.a并放在已有成员a.c之后； \"b\"表示before,即将新成员加在指定成员之前.例如ar -rb a.c liba.a b.c; \"i\"表示insert,跟\"b\"作用相同 列出库中已有成员 ar -t liba.a即可。如果加上\"v\"修饰符则会一并列出成员的日期等属性。 删除库中成员 ar -d liba.a a.c表示从库中删除a.c成员.如果库中没有这个成员ar也不会给出提示.如果需要列出被删除的成员或者成员不存在的信息,就加上\"v\"修饰符. 从库中解出成员 ar -x liba.a b.c 调整库中成员的顺序 使用\"m\"关键字。与\"r\"关键字一样，它也有3个修饰符\"a\",\"b\", \"i\"。如果要将b.c移动到a.c之前，则使用ar -mb a.c liba.a b.c Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-08 15:09:34 "},"工具链/编译配套工具.html":{"url":"工具链/编译配套工具.html","title":"编译配套工具","keywords":"","body":"编译配套工具 之前的代码我们直接使用gcc来手工编译,这没问题,不过我们也看到了每次编译的命令都比python的helloworld都长了.像很多复杂的程序用到很多外部依赖的情况下编译都快赶上写业务逻辑了. 在js中我们用glup来流程化编译,在c中的流程化编译工具就太多了,各自适用于不同的平台有着不同的规范,这边介绍的是makefile和cmake工具. makefile是类unix系统下一个古老的工具,至今活跃在编程届. cmake是一个高层次的流程化编译工具,它可以用来自动生成makefile,关键是他跨平台. makefile与自动化编译 make是一个linux/osx下可以替你运行编译命令的工具.make会检查源文件和目标文件的时间戳,如果目标文件过期,make就会重新编译它. 在windows下,只有安装了mingw才会安装make工具,它的名字叫做mingw32-make.exe.为了方便起见可以将其改名为make 但是做到所有这些事情前,需要告诉make源代码的一些情况.make需要知道文件之间的依赖关系,同时还需要告诉它你具体想如何构建代码.严格意义上讲,make不仅仅可以用来编译文件.目标可以是任何用其他文件生成的文件,也就是说目标可以是一批文件压缩而成的压缩文档. 对每个目标,make需要知道两件事: 依赖项 生成目标需要用哪些文件 生成方法 生成该文件时要用哪些指令 依赖项和生成方法合在一起构成了一条规则.有了规则,make就知道如何生成目标. 用makefile向make描述代码 所有目标,依赖项和生成方法的细节信息需要保存在一个叫makefile或Makefile的文件中, makefile语法 makefile规则很简单,基本的规则: 规则形式 target: require1 require2 require3 process 注意process前面必须是tab 定义环境变量 export FLASK_ENV=dev 定义变量 DIR=xxx 使用环境变量/变量 $(pwd) 注意,要获取标准输出的内容需要使用$(shell xxx) 为了弄明白它是怎么工作的,下面我们还是以binary_vector为例为它写个makefile用以实现编译静态链接库和测试文件的功能: %%writefile ./code/compiler/S2/makefile DIR = $(shell pwd) INCLUDE_DIR = $(DIR)/source/inc SRC_DIR = $(DIR)/source/src OBJECT_DIR = $(DIR)/source/obj LIB_DIR = $(DIR)/build/lib BIN_DIR = $(DIR)/build/bin TEST_DIR = $(DIR)/test objects = $(addprefix $(OBJECT_DIR)/,binary_operator.o unary_operator.o struct_operator.o) all: $(LIB_DIR)/libvector.a echo \"done!\" $(OBJECT_DIR)/struct_operator.o: $(INCLUDE_DIR)/binary_vector.h gcc -c \\ -o $(OBJECT_DIR)/struct_operator.o \\ -I $(INCLUDE_DIR) \\ $(SRC_DIR)/struct_operator.c $(OBJECT_DIR)/binary_operator.o: $(INCLUDE_DIR)/binary_vector.h gcc -c \\ -o $(OBJECT_DIR)/binary_operator.o \\ -I $(INCLUDE_DIR) \\ $(SRC_DIR)/binary_operator.c $(OBJECT_DIR)/unary_operator.o: $(INCLUDE_DIR)/binary_vector.h gcc -c \\ -o $(OBJECT_DIR)/unary_operator.o \\ -I $(INCLUDE_DIR) \\ $(SRC_DIR)/unary_operator.c $(LIB_DIR)/libvector.a: $(objects) ar crv $(LIB_DIR)/libvector.a \\ $(objects) $(BIN_DIR)/vectorTest: $(LIB_DIR)/libvector.a $(INCLUDE_DIR)/binary_vector.h $(TEST_DIR)/test.c gcc \\ -o $(BIN_DIR)/vectorTest \\ -I $(INCLUDE_DIR) \\ -L $(LIB_DIR) \\ -l vector \\ $(TEST_DIR)/test.c test: $(BIN_DIR)/vectorTest $(BIN_DIR)/vectorTest clean: $(BIN_DIR)/vectorTest $(objects) $(LIB_DIR)/libvector.a rm $(BIN_DIR)/vectorTest $(objects) $(LIB_DIR)/libvector.a Overwriting ./code/compiler/S2/makefile 需要注意的是每条命令部分只能用/tab而不是空格 使用make命令 make命令使用-C指定操作目录, 后面接makefile中的target执行定义的过程和依赖.如果不指定target则会知名第一条target !make -C ./code/compiler/S2/ clean gcc \\ -o /Users/huangsizhe/Workspace/Documents/TutorialForCLang/c-tool-chain/code/compiler/S2/build/bin/vectorTest \\ -I /Users/huangsizhe/Workspace/Documents/TutorialForCLang/c-tool-chain/code/compiler/S2/source/inc \\ -L /Users/huangsizhe/Workspace/Documents/TutorialForCLang/c-tool-chain/code/compiler/S2/build/lib \\ -l vector \\ /Users/huangsizhe/Workspace/Documents/TutorialForCLang/c-tool-chain/code/compiler/S2/test/test.c rm /Users/huangsizhe/Workspace/Documents/TutorialForCLang/c-tool-chain/code/compiler/S2/build/bin/vectorTest /Users/huangsizhe/Workspace/Documents/TutorialForCLang/c-tool-chain/code/compiler/S2/source/obj/binary_operator.o /Users/huangsizhe/Workspace/Documents/TutorialForCLang/c-tool-chain/code/compiler/S2/source/obj/unary_operator.o /Users/huangsizhe/Workspace/Documents/TutorialForCLang/c-tool-chain/code/compiler/S2/source/obj/struct_operator.o /Users/huangsizhe/Workspace/Documents/TutorialForCLang/c-tool-chain/code/compiler/S2/build/lib/libvector.a !make -C ./code/compiler/S2/ gcc -c \\ -o /Users/huangsizhe/Workspace/Documents/TutorialForCLang/c-tool-chain/code/compiler/S2/source/obj/binary_operator.o \\ -I /Users/huangsizhe/Workspace/Documents/TutorialForCLang/c-tool-chain/code/compiler/S2/source/inc \\ /Users/huangsizhe/Workspace/Documents/TutorialForCLang/c-tool-chain/code/compiler/S2/source/src/binary_operator.c gcc -c \\ -o /Users/huangsizhe/Workspace/Documents/TutorialForCLang/c-tool-chain/code/compiler/S2/source/obj/unary_operator.o \\ -I /Users/huangsizhe/Workspace/Documents/TutorialForCLang/c-tool-chain/code/compiler/S2/source/inc \\ /Users/huangsizhe/Workspace/Documents/TutorialForCLang/c-tool-chain/code/compiler/S2/source/src/unary_operator.c gcc -c \\ -o /Users/huangsizhe/Workspace/Documents/TutorialForCLang/c-tool-chain/code/compiler/S2/source/obj/struct_operator.o \\ -I /Users/huangsizhe/Workspace/Documents/TutorialForCLang/c-tool-chain/code/compiler/S2/source/inc \\ /Users/huangsizhe/Workspace/Documents/TutorialForCLang/c-tool-chain/code/compiler/S2/source/src/struct_operator.c ar crv /Users/huangsizhe/Workspace/Documents/TutorialForCLang/c-tool-chain/code/compiler/S2/build/lib/libvector.a \\ /Users/huangsizhe/Workspace/Documents/TutorialForCLang/c-tool-chain/code/compiler/S2/source/obj/binary_operator.o /Users/huangsizhe/Workspace/Documents/TutorialForCLang/c-tool-chain/code/compiler/S2/source/obj/unary_operator.o /Users/huangsizhe/Workspace/Documents/TutorialForCLang/c-tool-chain/code/compiler/S2/source/obj/struct_operator.o a - /Users/huangsizhe/Workspace/Documents/TutorialForCLang/c-tool-chain/code/compiler/S2/source/obj/binary_operator.o a - /Users/huangsizhe/Workspace/Documents/TutorialForCLang/c-tool-chain/code/compiler/S2/source/obj/unary_operator.o a - /Users/huangsizhe/Workspace/Documents/TutorialForCLang/c-tool-chain/code/compiler/S2/source/obj/struct_operator.o echo \"done!\" done! !make -C ./code/compiler/S2/ test gcc \\ -o /Users/huangsizhe/Workspace/Documents/TutorialForCLang/c-tool-chain/code/compiler/S2/build/bin/vectorTest \\ -I /Users/huangsizhe/Workspace/Documents/TutorialForCLang/c-tool-chain/code/compiler/S2/source/inc \\ -L /Users/huangsizhe/Workspace/Documents/TutorialForCLang/c-tool-chain/code/compiler/S2/build/lib \\ -l vector \\ /Users/huangsizhe/Workspace/Documents/TutorialForCLang/c-tool-chain/code/compiler/S2/test/test.c /Users/huangsizhe/Workspace/Documents/TutorialForCLang/c-tool-chain/code/compiler/S2/build/bin/vectorTest mod(A)=2.236068 mod(B)=5.000000 mul(A,B)=11.000000 add(A,B)= 使用cmake流程化编译 Cmake本质上也不提供流程化编译的功能,他其实是用来生成不同平台make文件的,在linux,mac osx上就是makefile,正真编译使用make命令,在windows上就是nmake当然windows下也可以使用mingw来编译,自带的mingwXX-make来编译makefile.不过这需要在cmake的时候加上额外参数-G \"MinGW Makefiles\"指定 Cmake基本用法 Cmake是指令式的配置方式,基本形式就是cmake_minimum_required (VERSION 2.8)这样,()外面的是参数字段,里面的是内容. 常用的字段有: 元信息设置 cmake_minimum_required：指定运行此配置文件所需的 CMake 的最低版本 project()：参数值是 Demo1，该命令指定项目的名称 编译器设置 set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/Lib):设置静态连接文件输出目录 set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/Lib):设置动态态连接文件输出目录 set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/Bin):设置可执行文件输出目录 set_target_properties( PROPERTIES PUBLIC_HEADER \"some.h;headers.h\") 将对外的接口头文件设置到编译目标上 include_directories([AFTER|BEFORE] [SYSTEM] dir1 [dir2 ...]):设置头文件目录 link_directories(directory1 directory2 ...):设置连接库所在位置 link_libraries(library1 library2 ...):添加需要链接的库文件路径 target_link_libraries( [item1 [item2 [...]]][[debug|optimized|general] ] ...):设置要链接的库文件的名称 aux_source_directory( ): 指定源文件的所在目录,如aux_source_directory(. DIR_SRCS)这样就将所有文件夹下的文件名放到了DIR_SRCS变量中.add_executable(Demo ${DIR_SRCS})就指定好了所有文件. add_executable( )： 将源文件编译成一个可执行文件,第一位是目标可执行文件名,后面则是源文件名. add_compile_options(-std=c++11):指定编译目标使用的额外参数,比如支持c++11 target_compile_features( )指定编译目标使用的额外参数 链接编译设置 add_library ( [type]):将源文件编译成一个链接库. 子目录设置 add_subdirectory(math):添加子目录,子目录中需要有CMakeLists.txt文件,编译时会优先编译子目录. 测试设置 可以用make test执行测试 enable_testing():启动测试 add_test( ):添加一个测试,需要先把测试代码编译了 set_tests_properties (test_usage PROPERTIES PASS_REGULAR_EXPRESSION \"Usage: .* base exponent\")设定测试的属性 定义一个宏，用来简化测试工作 macro (do_test arg1 arg2 result) add_test (test_${arg1}_${arg2} Demo ${arg1} ${arg2}) set_tests_properties (test_${arg1}_${arg2} PROPERTIES PASS_REGULAR_EXPRESSION ${result}) endmacro (do_test) debug测试 set(CMAKE_BUILD_TYPE \"Debug\") set(CMAKE_CXX_FLAGS_DEBUG \"$ENV{CXXFLAGS} -O0 -Wall -g -ggdb\") set(CMAKE_CXX_FLAGS_RELEASE \"$ENV{CXXFLAGS} -O3 -Wall\") install功能 通常可以是这样的定义 install([TARGETS ...(编译目标)|FILES ...(要移动的文件)] [LIBRARY(动态库)|ARCHIVE(静态库)|RUNTIME(可执行文件)] DESTINATION ... [INCLUDES DESTINATION [ ...]] ) cmake 的语法有: 打印信息 MESSAGE([SEND_ERROR | STATUS | FATAL_ERROR] \"message to display\"...),如:MESSAGE(STATUS \"This is BINARY dir \" ${HELLO_BINARY_DIR})) 指定编译器: SET(CMAKE_C_COMPILER \"/home/public/local/bin/gcc\") SET(CMAKE_CXX_COMPILER \"/home/public/local/bin/g++\") 显式的设置自定义变量 使用set(变量名 值)的操作，如:SET(HELLO_SRC main.SOURCE_PATHc) 变量引用的方式 使用${}进行变量的引用 设置环境变量 SET(ENV{变量名} 值) 调用环境变量 使用$ENV{NAME}指令就可以调用系统的环境变量了 IF 指令 基本语法为: IF(expression_r_r) # THEN section. COMMAND1(ARGS ...) COMMAND2(ARGS ...) ... ELSE(expression_r_r) # ELSE section. COMMAND1(ARGS ...) COMMAND2(ARGS ...) ... ENDIF(expression_r_r) WHILE指令 基本语法为: WHILE(condition) COMMAND1(ARGS ...) COMMAND2(ARGS ...) ... ENDWHILE(condition) 其真假判断条件可以参考 IF 指令。 FOREACH FOREACH 指令的使用方法有两种形式: 列表FOREACH(loop_var arg1 arg2 ...) COMMAND1(ARGS ...) COMMAND2(ARGS ...) ... ENDFOREACH(loop_var) 范围(类似pythonz中的for xxx in range(x))FOREACH(loop_var RANGE oop_var RANGE start stop [step]) ENDFOREACH(loop_var) Cmake的预定义变量有: CMAKE_BINARY_DIR/PROJECT_BINARY_DIR/_BINARY_DIR 这三个变量指代的内容是一致的,如果是in source编译,指得就是工程顶层目录,如果是out-of-source编译,指的是工程编译发生的目录 PROJECT_BINARY_DIR 跟其他指令稍有区别,但多数时候你可以理解为他们是一致的. CMAKE_SOURCE_DIR/PROJECT_SOURCE_DIR/_SOURCE_DIR 这三个变量指代的内容是一致的,不论采用何种编译方式,都是工程顶层目录.也就是在in source编译时,他跟CMAKE_BINARY_DIR等变量一致.PROJECT_SOURCE_DIR跟其他指令稍有区别,但多数时候你可以理解为他们是一致的. CMAKE_CURRENT_SOURCE_DIR 指的是当前处理的CMakeLists.txt所在的路径 CMAKE_CURRRENT_BINARY_DIR 如果是in-source编译,它跟CMAKE_CURRENT_SOURCE_DIR一致,如果是out-of-source编译,他指的是target编译目录.使用ADD_SUBDIRECTORY(src bin)可以更改这个变量的值.使用SET(EXECUTABLE_OUTPUT_PATH )并不会对这个变量造成影响,它仅仅修改了最终目标文件存放的路径. CMAKE_CURRENT_LIST_FILE 输出调用这个变量的CMakeLists.txt的完整路径 CMAKE_CURRENT_LIST_LINE 输出这个变量所在的行 CMAKE_MODULE_PATH 这个变量用来定义自己的cmake模块所在的路径.如果你的工程比较复杂,有可能会自己编写一些cmake模块,这些cmake模块是随你的工程发布的,为了让 cmake在处理CMakeLists.txt时找到这些模块,你需要通过SET指令,将自己的cmake模块路径设置一下.比如SET(CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/cmake).这时候你就可以通过 INCLUDE 指令来调用自己的模块了. EXECUTABLE_OUTPUT_PATH /LIBRARY_OUTPUT_PATH 分别用来重新定义最终结果的存放目录,前面我们已经提到了这两个变量。 PROJECT_NAME 返回通过PROJECT指令定义的项目名称. CMAKE_MAJOR_VERSION,CMAKE 主版本号,比如 2.4.6 中的 2 CMAKE_MINOR_VERSION,CMAKE 次版本号,比如 2.4.6 中的 4 CMAKE_PATCH_VERSION,CMAKE 补丁等级,比如 2.4.6 中的 6 CMAKE_SYSTEM 系统名称,比如 Linux-2.6.22 CMAKE_SYSTEM_NAME 不包含版本的系统名,比如 Linux CMAKE_SYSTEM_VERSION 系统版本,比如 2.6.22 CMAKE_SYSTEM_PROCESSOR 处理器名称,比如 i686. UNIX 在所有的类 UNIX 平台为 TRUE,包括 OS X 和 cygwin WIN32 在所有的 win32 平台为 TRUE,包括 cygwin CMAKE_INSTALL_PREFIX 在cmake生成makefile时使用-D指定的目录,用于指定安装目录,如果不指定且安装的地址是相对地址,就会默认安装到/usr/local/下. 使用cmake编译我们的二元向量 更多的用法可以看官方文档.本文不会叙述太多.针对我们的二元向量模块,我们需要写两个CMakeLists.txt,一个用于将src中的内容编译为静态库,一个用于编译测试文件. 我们先将S2中的代码复制到S3 %%writefile ./code/compiler/S3/CMakeLists.txt #项目编译环境 cmake_minimum_required (VERSION 2.8) project (binary_vector) include_directories(source/inc) # 编译动态链接库 set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/build/lib) aux_source_directory(${CMAKE_BINARY_DIR}/source/src DIR_LIB_SRCS) add_library(vector SHARED ${DIR_LIB_SRCS}) install(TARGETS vector LIBRARY DESTINATION CMAKE_LIBRARY_OUTPUT_DIRECTORY ) # 编译连接生成demo set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/build/bin) link_directories(${CMAKE_BINARY_DIR}/build/lib) link_libraries(vector) aux_source_directory(test DIR_SRCS) add_executable(Demo ${DIR_SRCS}) #测试 enable_testing() add_test (DemoRuns ${CMAKE_BINARY_DIR}/build/bin/Demo) Overwriting ./code/compiler/S3/CMakeLists.txt !cmake ./code/compiler/S3/CMakeLists.txt -- Configuring done CMake Warning (dev): Policy CMP0042 is not set: MACOSX_RPATH is enabled by default. Run \"cmake --help-policy CMP0042\" for policy details. Use the cmake_policy command to set the policy and suppress this warning. MACOSX_RPATH is not specified for the following targets: vector This warning is for project developers. Use -Wno-dev to suppress it. -- Generating done -- Build files have been written to: /Users/huangsizhe/Workspace/Documents/TutorialForCLang/c-tool-chain/code/compiler/S3 cmake会为我们创建一个更好的makefile !make -C ./code/compiler/S3/ [ 66%] Built target vector [ 83%] \u001b[32mBuilding C object CMakeFiles/Demo.dir/test/test.c.o\u001b[0m [100%] \u001b[32m\u001b[1mLinking C executable build/bin/Demo\u001b[0m [100%] Built target Demo !make -C ./code/compiler/S3/ test \u001b[36mRunning tests...\u001b[0m Test project /Users/huangsizhe/Workspace/Documents/TutorialForCLang/c-tool-chain/code/compiler/S3 Start 1: DemoRuns 1/1 Test #1: DemoRuns ......................... Passed 0.01 sec \u001b[0;32m100% tests passed\u001b[0;0m, 0 tests failed\u001b[0;0m out of 1 Total Test time (real) = 0.02 sec Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-05 00:15:48 "},"工具链/测试工具.html":{"url":"工具链/测试工具.html","title":"测试工具","keywords":"","body":"测试工具 C语言的单元测试比较简单,可以使用一个叫minunit的工具.它是专门针对C语言单元测试用的,没有侵入性.只有一个头文件.只要在下载下来就能直接用. 这个工具一般用于测试模块且单独使用,我们将compiler/C3的代码复制到test_tool下,并将minunit下载到test_tool/test/: %%writefile ./code/test_tool/test/test.c #include \"minunit.h\" #include \"binary_vector.h\" struct BINARY_VECTOR A = {1.0,2.0},B = {3.0,4.0}; MU_TEST(test_check_modA) { mu_check(VEC_mod(&A) == 2.236068); } MU_TEST(test_check_modB) { mu_check(VEC_mod(&B) == 5.000000); } MU_TEST(test_check_mulA_B) { mu_check(VEC_mul(&A,&B) == 11.000000); } MU_TEST(test_check_addA_B) { BINARY_VECTOR_P result = VEC_add(&A,&B); mu_check(result->x == 4.000000); mu_check(result->y == 6.000000); } MU_TEST_SUITE(test_suite) { MU_RUN_TEST(test_check_modA); MU_RUN_TEST(test_check_modB); MU_RUN_TEST(test_check_mulA_B); MU_RUN_TEST(test_check_addA_B); } int main(int argc, char *argv[]) { MU_RUN_SUITE(test_suite); MU_REPORT(); return 0; } Overwriting ./code/test_tool/test/test.c %%writefile ./code/test_tool/CMakeLists.txt #项目编译环境 cmake_minimum_required (VERSION 2.8) project (binary_vector) include_directories(source/inc) # 编译动态链接库 set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/build/lib) aux_source_directory(${CMAKE_BINARY_DIR}/source/src DIR_LIB_SRCS) add_library(vector SHARED ${DIR_LIB_SRCS}) install(TARGETS vector LIBRARY DESTINATION CMAKE_LIBRARY_OUTPUT_DIRECTORY ) # 编译连接生成demo set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/build/bin) link_directories(${CMAKE_BINARY_DIR}/build/lib) link_libraries(vector) aux_source_directory(test DIR_SRCS) add_executable(Demo_Test ${DIR_SRCS}) #测试 enable_testing() add_test (TestRuns ${CMAKE_BINARY_DIR}/build/bin/Demo_Test) Overwriting ./code/test_tool/CMakeLists.txt !cmake ./code/test_tool/CMakeLists.txt -- Configuring done CMake Warning (dev): Policy CMP0042 is not set: MACOSX_RPATH is enabled by default. Run \"cmake --help-policy CMP0042\" for policy details. Use the cmake_policy command to set the policy and suppress this warning. MACOSX_RPATH is not specified for the following targets: vector This warning is for project developers. Use -Wno-dev to suppress it. -- Generating done -- Build files have been written to: /Users/huangsizhe/Workspace/Documents/TutorialForCLang/c-tool-chain/code/test_tool !make -C ./code/test_tool/ [ 66%] Built target vector \u001b[35m\u001b[1mScanning dependencies of target Demo_Test\u001b[0m [ 83%] \u001b[32mBuilding C object CMakeFiles/Demo_Test.dir/test/test.c.o\u001b[0m [100%] \u001b[32m\u001b[1mLinking C executable build/bin/Demo_Test\u001b[0m [100%] Built target Demo_Test !make -C ./code/test_tool/ test \u001b[36mRunning tests...\u001b[0m Test project /Users/huangsizhe/Workspace/Documents/TutorialForCLang/c-tool-chain/code/test_tool Start 1: TestRuns 1/1 Test #1: TestRuns ......................... Passed 0.01 sec \u001b[0;32m100% tests passed\u001b[0;0m, 0 tests failed\u001b[0;0m out of 1 Total Test time (real) = 0.01 sec !./code/test_tool/build/bin/Demo_Test F test_check_modA failed: /Users/huangsizhe/Workspace/Documents/TutorialForCLang/c-tool-chain/code/test_tool/test/test.c:7: VEC_mod(&A) == 2.236068 .... 4 tests, 5 assertions, 1 failures Finished in 0.00013472 seconds (real) 0.00006700 seconds (proc) Cmake的ctest工具 一般来说用Cmake都会用ctest作为测试工具,不过我并不推荐将它用在编写模块的时候,因为太重了,不过如果是用来测试一些比较复杂的命令行工具,他还是很不错的 Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-05 00:44:42 "},"工具链/制作命令行工具并测试.html":{"url":"工具链/制作命令行工具并测试.html","title":"制作命令行工具并测试","keywords":"","body":"制作命令行工具并测试 C语言是和系统最近的编程语言之一,而很多系统工具也是C写的. 制作小工具 在linux的世界里,很多工作都是由小工具完成的,它恐怕是现如今流行的微服务架构最早的实践了. 所谓小工具有这样的特点: 从标准输入读取数据 在标准输出显示数据 处理文本数据，而不是难以阅读的二进制格式 只做一件简单的事 通过标准输入输出可以方便的做重定向,而文本数据除了机器好读,人也好读. 所谓重新定向是指使用>,>>作为输出,使用,作为输入 比较让人熟知的就是grep小工具了,它的作用是过滤掉文本中不含关键字的行.而一般我们都是拿他和其他工具配合使用的,比如我希望查看之前使用过的带python的历史记录,那就可以这样写: history | grep python 当然了其他语言比如python也可以制作小工具,而且由于语法更加简单,抽象层次更高,实际上写起来会更加简单,但在这边用c/c++来做小工具有其合理的一面 不用依赖环境 c/c++不依赖于运行环境,只要编译通过了就可以运行二进制代码.而带有vm的语言比如java,python,脱离了vm就无法运行了 高效 多数情况下,,相同的逻辑,C/C++制作的工具有最高的运行效率 小巧 像go语言,也是编译成二进制后执行的语言,但由于其抽象层次更高(虽然也没高多少)而且有个运行时,生成的代码比使用c/c++写的大得多,而c++如果使用模板的话也会比C写的大得多 从一个例子开始 我们来写一个gps数据格式转换工具,使用它我们可以将gps数据转化为符合规定的json格式,gps数据是形如: 42.363400,-71.098465,Speed = 21 42.363400,-71.097588,Speed = 23 42.363400,-71.098465,Speed = 27 . . . 的csv数据 而地图应用需要的格式则形如: data = [ {latitude: 42.363400, longitude: -71.098465, info: 'Speed = 21'}, . . . ] 的json数据 好,开始我们的小程序: %%writefile ./code/create_cmdline_tool/geo2json/source/src/geo2json.c #include int main(){ float latitude; float longitude; char info[80]; int started = 0; puts(\"data=[\"); while (scanf(\"%f,%f,%79[^\\n]\",&latitude,&longitude,&info) == 3){ if (started){ printf(\",\\n\"); } else { started = 1; } printf(\"{latitude: %f, longitude: %f, info: '%s'}\",latitude,longitude,info); } puts(\"\\n]\"); return 0; } Overwriting ./code/create_cmdline_tool/geo2json/source/src/geo2json.c %%writefile ./code/create_cmdline_tool/geo2json/CMakeLists.txt #项目编译环境 cmake_minimum_required (VERSION 2.8) project (geo2json) # 编译连接生成demo set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/build/bin) aux_source_directory(${CMAKE_BINARY_DIR}/source/src DIR_SRCS) add_executable(geo2json ${DIR_SRCS}) Writing ./code/create_cmdline_tool/geo2json/CMakeLists.txt !cmake ./code/create_cmdline_tool/geo2json/CMakeLists.txt -- The C compiler identification is AppleClang 10.0.0.10001044 -- The CXX compiler identification is AppleClang 10.0.0.10001044 -- Check for working C compiler: /Library/Developer/CommandLineTools/usr/bin/cc -- Check for working C compiler: /Library/Developer/CommandLineTools/usr/bin/cc -- works -- Detecting C compiler ABI info -- Detecting C compiler ABI info - done -- Detecting C compile features -- Detecting C compile features - done -- Check for working CXX compiler: /Library/Developer/CommandLineTools/usr/bin/c++ -- Check for working CXX compiler: /Library/Developer/CommandLineTools/usr/bin/c++ -- works -- Detecting CXX compiler ABI info -- Detecting CXX compiler ABI info - done -- Detecting CXX compile features -- Detecting CXX compile features - done -- Configuring done -- Generating done -- Build files have been written to: /Users/huangsizhe/Workspace/Documents/TutorialForCLang/c-tool-chain/code/create_cmdline_tool/geo2json !make -C ./code/create_cmdline_tool/geo2json/ \u001b[35m\u001b[1mScanning dependencies of target geo2json\u001b[0m [ 50%] \u001b[32mBuilding C object CMakeFiles/geo2json.dir/source/src/geo2json.c.o\u001b[0m \u001b[1m/Users/huangsizhe/Workspace/Documents/TutorialForCLang/c-tool-chain/code/create_cmdline_tool/geo2json/source/src/geo2json.c:9:56: \u001b[0m\u001b[0;1;35mwarning: \u001b[0m\u001b[1m format specifies type 'char *' but the argument has type 'char (*)[80]' [-Wformat]\u001b[0m while (scanf(\"%f,%f,%79[^\\n]\",&latitude,&longitude,&info) == 3){ \u001b[0;1;32m ~~~~~~ ^~~~~ \u001b[0m1 warning generated. [100%] \u001b[32m\u001b[1mLinking C executable build/bin/geo2json\u001b[0m [100%] Built target geo2json !./code/create_cmdline_tool/geo2json/build/bin/geo2json \\ ./code/create_cmdline_tool/geo2json/out/gpsdata.json !cat ./code/create_cmdline_tool/geo2json/out/gpsdata.json data=[ {latitude: 42.363400, longitude: -71.098465, info: 'Speed = 21'}, {latitude: 42.363327, longitude: -71.097588, info: 'Speed = 23'}, {latitude: 42.363255, longitude: -71.096710, info: 'Speed = 17'}, {latitude: 42.363182, longitude: -71.095833, info: 'Speed = 22'}, {latitude: 42.363110, longitude: -71.094955, info: 'Speed = 14'}, {latitude: 42.363037, longitude: -71.094078, info: 'Speed = 16'}, {latitude: 42.362965, longitude: -71.093201, info: 'Speed = 18'}, {latitude: 42.362892, longitude: -71.092323, info: 'Speed = 22'}, {latitude: 42.362820, longitude: -71.091446, info: 'Speed = 17'}, {latitude: 42.362747, longitude: -71.090569, info: 'Speed = 23'}, {latitude: 42.362675, longitude: -71.089691, info: 'Speed = 14'}, {latitude: 42.362602, longitude: -71.088814, info: 'Speed = 19'}, {latitude: 42.362530, longitude: -71.087936, info: 'Speed = 16'}, {latitude: 42.362457, longitude: -71.087059, info: 'Speed = 16'}, {latitude: 423.623840, longitude: -71.086182, info: 'Speed = 21'} ] 数据验证 不难发现,输入数据中有错误数据,我们的程序要加入一些验证逻辑来进行错误检验,当然了,错误信息应该输出在stderr里 %%writefile ./code/create_cmdline_tool/geo2json/source/src/geo2json.c #include int main(){ float latitude; float longitude; char info[80]; int started = 0; puts(\"data=[\"); while (scanf(\"%f,%f,%79[^\\n]\",&latitude,&longitude,&info) == 3){ if (started){ printf(\",\\n\"); } else { started = 1; } if ((latitude 90.0)) { fprintf(stderr,\"Invalid latitude: %f\\n\", latitude); continue; } if ((longitude 180.0)) { fprintf(stderr, \"Invalid longitude: %f\\n\", longitude); continue; } printf(\"{latitude: %f, longitude: %f, info: '%s'}\",latitude,longitude,info); } puts(\"\\n]\"); return 0; } Overwriting ./code/create_cmdline_tool/geo2json/source/src/geo2json.c !make -C ./code/create_cmdline_tool/geo2json/ \u001b[35m\u001b[1mScanning dependencies of target geo2json\u001b[0m [ 50%] \u001b[32mBuilding C object CMakeFiles/geo2json.dir/source/src/geo2json.c.o\u001b[0m \u001b[1m/Users/huangsizhe/Workspace/Documents/TutorialForCLang/c-tool-chain/code/create_cmdline_tool/geo2json/source/src/geo2json.c:9:56: \u001b[0m\u001b[0;1;35mwarning: \u001b[0m\u001b[1m format specifies type 'char *' but the argument has type 'char (*)[80]' [-Wformat]\u001b[0m while (scanf(\"%f,%f,%79[^\\n]\",&latitude,&longitude,&info) == 3){ \u001b[0;1;32m ~~~~~~ ^~~~~ \u001b[0m1 warning generated. [100%] \u001b[32m\u001b[1mLinking C executable build/bin/geo2json\u001b[0m [100%] Built target geo2json !./code/create_cmdline_tool/geo2json/build/bin/geo2json \\ ./code/create_cmdline_tool/geo2json/out/gpsdata.json Invalid latitude: 423.623840 !cat ./code/create_cmdline_tool/geo2json/out/gpsdata.json data=[ {latitude: 42.363400, longitude: -71.098465, info: 'Speed = 21'}, {latitude: 42.363327, longitude: -71.097588, info: 'Speed = 23'}, {latitude: 42.363255, longitude: -71.096710, info: 'Speed = 17'}, {latitude: 42.363182, longitude: -71.095833, info: 'Speed = 22'}, {latitude: 42.363110, longitude: -71.094955, info: 'Speed = 14'}, {latitude: 42.363037, longitude: -71.094078, info: 'Speed = 16'}, {latitude: 42.362965, longitude: -71.093201, info: 'Speed = 18'}, {latitude: 42.362892, longitude: -71.092323, info: 'Speed = 22'}, {latitude: 42.362820, longitude: -71.091446, info: 'Speed = 17'}, {latitude: 42.362747, longitude: -71.090569, info: 'Speed = 23'}, {latitude: 42.362675, longitude: -71.089691, info: 'Speed = 14'}, {latitude: 42.362602, longitude: -71.088814, info: 'Speed = 19'}, {latitude: 42.362530, longitude: -71.087936, info: 'Speed = 16'}, {latitude: 42.362457, longitude: -71.087059, info: 'Speed = 16'}, ] 用C构建带参数的命令行工具 unistd.h是C语言的一个准标准库,它是linux,mac osx等类unix系统的自带的库,但windows并不支持.要在windows下使用需要自己写一个头文件,如下: /** This file is part of the Mingw32 package. * unistd.h maps (roughly) to io.h */ #ifndef _UNISTD_H #define _UNISTD_H #include #include #endif /* _UNISTD_H */ 使用它便利的构建命令行工具getopt getopt()用来分析命令行参数.参数argc和argv是由main()传递的参数个数和内容.参数optstring则代表欲处理的选项字符串.此函数会返回在argv中下一个的选项字母,此字母会对应参数optstring中的字母.如果选项字符串里的字母后接着冒号\":\".则表示还有相关的参数,全域变量optarg 即会指向此额外参数.如果getopt()找不到符合的参数则会印出错信息,并将全域变量optopt设为\"?\"字符,如果不希望getopt()印出错信息,则只要将全域变量opterr设为0即可. 短参数的定义 getopt()使用optstring所指的字串作为短参数列表,像\"1ac:d::\"就是一个短参数列表.短参数的定义是一个'-'后面跟一个字母或数字,象-a, -b就是一个短参数.每个数字或字母定义一个参数. 其中短参数在getopt定义里分为三种： 不带值的参数,它的定义即是参数本身 必须带值的参数,它的定义是在参数本身后面再加一个冒号 可选值的参数,它的定义是在参数本身后面加两个冒号 在这里拿上面的\"1ac:d::\"作为样例进行说明,其中的 1,a就是不带值的参数 c是必须带值的参数 d是可选值的参数 在实际调用中，'-1 -a -c cvalue -d', '-1 -a -c cvalue -ddvalue', '-1a -ddvalue -c cvalue'都是合法的. 这里需要注意三点: 不带值的参数可以连写,像1和a是不带值的参数,它们可以-1 -a分开写,也可以-1a或-a1连写. 参数不分先后顺序,'-1a -c cvalue -ddvalue'和'-d -c cvalue -a1'的解析结果是一样的. 要注意可选值的参数的值与参数之间不能有空格,必须写成-ddvalue这样的格式,如果写成-d dvalue这样的格式就会解析错误. 返回值 getopt()每次调用会逐次返回命令行传入的参数. 　 当没有参数的最后的一次调用时,getopt()将返回-1.　 当解析到一个不在optstring里面的参数，或者一个必选值参数不带值时,返回'?'.　 当optstring是以':'开头时,缺值参数的情况下会返回':',而不是'?'. %%writefile ./code/create_cmdline_tool/sqrt_opt/source/src/sqrt_opt.c #include #include #include #include const char * version = \"0.1.0\"; int main(int argc, char **argv) { int ch; double result; opterr = 0; while ((ch = getopt(argc,argv,\"s:v\\n\"))!=-1){ switch(ch){ case 'v': printf(\"option v: %s\\n\",version); break; case 's': result = sqrt(atoi(optarg)); printf(\"%f\\n\",result); break; default: printf(\"wrong args\\n\"); } } return 0; } Writing ./code/create_cmdline_tool/sqrt_opt/source/src/sqrt_opt.c %%writefile ./code/create_cmdline_tool/sqrt_opt/CMakeLists.txt #项目编译环境 cmake_minimum_required (VERSION 2.8) project (sqrt_opt) # 编译连接生成demo set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/build/bin) aux_source_directory(${CMAKE_BINARY_DIR}/source/src DIR_SRCS) add_executable(sqrt_opt ${DIR_SRCS}) Overwriting ./code/create_cmdline_tool/sqrt_opt/CMakeLists.txt !cmake ./code/create_cmdline_tool/sqrt_opt/CMakeLists.txt -- Configuring done -- Generating done -- Build files have been written to: /Users/huangsizhe/Workspace/Documents/TutorialForCLang/c-tool-chain/code/create_cmdline_tool/sqrt_opt !make -C ./code/create_cmdline_tool/sqrt_opt/ \u001b[35m\u001b[1mScanning dependencies of target sqrt_opt\u001b[0m [ 50%] \u001b[32mBuilding C object CMakeFiles/sqrt_opt.dir/source/src/sqrt_opt.c.o\u001b[0m [100%] \u001b[32m\u001b[1mLinking C executable build/bin/sqrt_opt\u001b[0m [100%] Built target sqrt_opt !./code/create_cmdline_tool/sqrt_opt/build/bin/sqrt_opt -v option v: 0.1.0 !./code/create_cmdline_tool/sqrt_opt/build/bin/sqrt_opt -s36 6.000000 使用cmake test 测试命令行工具 cmake自带一个可以测试命令行工具的方案,我们来修改我们的CMakeLists.txt,测试的形式: add_test ( ${CMAKE_BINARY_DIR}/build/bin/sqrt_opt -s36) set_tests_properties ( PROPERTIES PASS_REGULAR_EXPRESSION \"6.0\") add_test用于增加一条测试,set_tests_properties用于验证测试是否符合预期.使用PASS_REGULAR_EXPRESSION利用正则匹配来验证是否结果符合预期. %%writefile ./code/create_cmdline_tool/sqrt_opt/CMakeLists.txt #项目编译环境 cmake_minimum_required (VERSION 2.8) project (sqrt_opt) # 编译连接生成demo set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/build/bin) aux_source_directory(${CMAKE_BINARY_DIR}/source/src DIR_SRCS) add_executable(sqrt_opt ${DIR_SRCS}) #测试 enable_testing() add_test (TEST_VERSION ${CMAKE_BINARY_DIR}/build/bin/sqrt_opt -v) set_tests_properties (TEST_VERSION PROPERTIES PASS_REGULAR_EXPRESSION \"v: 0.1.0\") add_test (TEST_36 ${CMAKE_BINARY_DIR}/build/bin/sqrt_opt -s36) set_tests_properties (TEST_36 PROPERTIES PASS_REGULAR_EXPRESSION \"6.0\") add_test (TEST_2 ${CMAKE_BINARY_DIR}/build/bin/sqrt_opt -s2) set_tests_properties (TEST_2 PROPERTIES PASS_REGULAR_EXPRESSION \"1.41\") Overwriting ./code/create_cmdline_tool/sqrt_opt/CMakeLists.txt !cmake ./code/create_cmdline_tool/sqrt_opt/CMakeLists.txt -- Configuring done -- Generating done -- Build files have been written to: /Users/huangsizhe/Workspace/Documents/TutorialForCLang/c-tool-chain/code/create_cmdline_tool/sqrt_opt !make -C ./code/create_cmdline_tool/sqrt_opt/ [100%] Built target sqrt_opt !make -C ./code/create_cmdline_tool/sqrt_opt/ test \u001b[36mRunning tests...\u001b[0m Test project /Users/huangsizhe/Workspace/Documents/TutorialForCLang/c-tool-chain/code/create_cmdline_tool/sqrt_opt Start 1: TEST_VERSION 1/3 Test #1: TEST_VERSION ..................... Passed 0.01 sec Start 2: TEST_36 2/3 Test #2: TEST_36 .......................... Passed 0.01 sec Start 3: TEST_2 3/3 Test #3: TEST_2 ........................... Passed 0.01 sec \u001b[0;32m100% tests passed\u001b[0;0m, 0 tests failed\u001b[0;0m out of 3 Total Test time (real) = 0.03 sec Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-04 23:05:37 "},"工具链/编程风格.html":{"url":"工具链/编程风格.html","title":"编程风格","keywords":"","body":"编程风格 任何语言的编程风格都是一个很个性化的东西,但明确风格又非常有意义. 深入讨论之前，首先要明确编程风格的意义所在，基本的有： 美观 方便阅读 易于理解 方便修改和维护 方便审查 方便测试 程序效率 代码质量 方便编写 就如同艺术流派的多样性一样,编码风格没有特定的统一规范,不同的软件项目或者企业有不同的艺术风格,比如说我一般使用vscode写程序,而其中可以在C_Cpp.clang_format_fallbackStyle中设置使用 Visual Studio LLVM Google Chromium Mozilla WebKit 这么几种预设风格之一,我一般喜欢使用Google风格,同时可以设置 \"C_Cpp.clang_format_style\": \"{ BasedOnStyle: Google, IndentWidth: 4 }\" 这样就可以让缩进为4个空格,以和python的风格一致. 头文件结构 头文件用于定义接口,接口的设计准则大致可以归纳为以下几点: 单一职责 C语言语法简单,可执行结构也只有函数,我们的函数应该功能单一 接口与实现分离 接口的设计应该尽量与实现分离,以防止给不同的实现制造麻烦 合理的\"面向对象\" 我们可以参考Go语言,以一个头文件来描述一个对象,用结构体描述属性,相关函数模拟成员函数.但面向对象最好仅限于此 没有特殊情况的话,头文件应该按顺序是这样的形式: 防止重复引用的宏 #ifndef XXX_H #define XXX_H//一般是文件名的大写 头文件结尾写上一行 #endif 定义结构体 定义typedef 定义函数 定义宏 关于结构体的使用 我们一般会使用typedef将结构体定义为类型,但通常结构体操作多是指针操作,因此实际中我们在头文件中一般这样定义: struct xxx; typedef xxx * yyy 这样的好处是yyy可以直接指代结构体的指针,我们完全可以把它当作类似python中的类型来使用,只是取成员的时候要注意使用->符号. 同时,struct不在头文件中实现,这样便于不同的实现使用不同的结构从而带来更多的灵活性. Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-04 19:51:10 "},"工具链/文档工具.html":{"url":"工具链/文档工具.html","title":"文档工具","keywords":"","body":"文档工具 c语言使用doxygen来从代码注释中提取文档,同时其支持markdown格式 doxygen支持多种格式,下面给出一个相对比价好上手的格式作为标准: 文件注释，放于文件的开头 文件注释主要是使用@xxx标识的变量 /** * @file filename * @brief This is a brief description. * @details This is the detail description. * @author author * @date date * @version A001 * @par Copyright (c): * XXX公司 * @par History: * version: author, date, desc\\n */ 函数注释，放于函数声明前 函数注释主要是使用@xxx标识的变量 /** * This is a brief description. * This is a detail description. * @param[in] inArgName input argument description. * @param[out] outArgName output argument description. * @retval OK 成功 * @retval ERROR 错误 * @par 标识符 * 保留 * @par 其它 * 无 * @par 修改日志 * XXX于201X-XX-XX创建 */ 数据结构注释，放于数据结构定义前 /** * The brief description. * The detail description. */ typedef struct { int var1;/// 宏定义注释，放于宏定义上方或者右侧 /** Description of the macro */ #define XXXX_XXX_XX 0 或者 #define XXXX_XXX_XX 0 /// 全局和静态变量注释 /** Description of global variable */ int g_xxx = 0; static int s_xxx = 0; /// 一般来说文档工具是为自动生成接口文档设计的,因此一般来说这个工具只要对头文件使用即可. 例子:为BINARY_VECTOR写注释 %%writefile ./code/doc_tools/build/inc/binary_vector.h /* $Id$ */ /** * @file binary_vector.h * @brief binary_vector接口文件 * @author author * @date 2018-1-8 * @version dev * @par Copyright (c): * XXX公司 * @par History: * version: author, date, desc\\n */ #ifndef BINARY_VECTOR_H #define BINARY_VECTOR_H//一般是文件名的大写 头文件结尾写上一行 /** * @struct BINARY_VECTOR * @brief vector结构 */ struct BINARY_VECTOR { float x; float y; }; typedef struct BINARY_VECTOR *BINARY_VECTOR_P; /** * @fn BINARY_VECTOR_P VEC_new(void) * @brief 实例化一个BINARY_VECTOR结构体 * @return BINARY_VECTOR_P 新结构体对象的指针 * @par 修改日志 * XXX于201X-XX-XX创建 */ BINARY_VECTOR_P VEC_new(void); /** * @fn BINARY_VECTOR_P VEC_init(float,float) * @brief 带初始化的实例化一个BINARY_VECTOR结构体 * @param[x] x值 * @param[y] y值 * @return BINARY_VECTOR_P 新结构体对象的指针 * @par 修改日志 * XXX于201X-XX-XX创建 */ BINARY_VECTOR_P VEC_init(float x,float y); /** * @fn void VEC_del(BINARY_VECTOR_P) * @brief 释放一个结构体对象 * @param[vector] 要释放的结构体对象 * @par 修改日志 * XXX于201X-XX-XX创建 */ void VEC_del(BINARY_VECTOR_P); /** * @fn float VEC_mod(BINARY_VECTOR_P) * @brief 求模 * @param[vector] 要求模的向量 * @return float 模的值 * @par 修改日志 * XXX于201X-XX-XX创建 */ float VEC_mod(BINARY_VECTOR_P); /** * @fn BINARY_VECTOR_P VEC_add(BINARY_VECTOR_P,BINARY_VECTOR_P) * @brief 求两个向量的和 * @param[vector] 求和的第一个向量 * @param[vector] 求和的第二个向量 * @return BINARY_VECTOR 相加后的向量 * @par 修改日志 * XXX于201X-XX-XX创建 */ BINARY_VECTOR_P VEC_add(BINARY_VECTOR_P,BINARY_VECTOR_P); /** * @fn float VEC_mul(BINARY_VECTOR_P ,BINARY_VECTOR_P) * @brief 求积 * @param[vector] 求积的第一个向量 * @param[vector] 求积的第二个向量 * @return float 内积的值 * @par 修改日志 * XXX于201X-XX-XX创建 */ float VEC_mul(BINARY_VECTOR_P ,BINARY_VECTOR_P); #endif Overwriting ./code/doc_tools/build/inc/binary_vector.h 使用doxygen生成文档 在有了注释以后,还需要使用doxygen工具生成所需的文档形式.使用命令行工具doxygen.其步骤为: doxygen -g生成一份配置模板 修改配置模板中的参数,中要的有: 项目名称 PROJECT_NAME = \"MyProject\" 对C项目优化 OPTIMIZE_OUTPUT_FOR_C = YES 源文件路径 INPUT = /home/tom/project/include 源文件编码 INPUT_ENCODEING = UTF-8 生成XML GENERATE_XML = YES 如果要使用breathe扩展，所以必须生成xml XML输出目录 XML_OUTPUT = my_xml 是否需要生成html GENERATE_HTML = NO 是否需要生成latex GENERATE_LATEX = NO 是否显示包含文件 SHOW_INCLUDE_FILES = NO 一般来说如果要单独使用doxygen则需要设置 GENERATE_HTML = Yes,如果要配合breathe则需要设置GENERATE_XML = YES,其他GENERATE_xxx改为NO 运行doxygen [Doxyfile]生成目标文档 使用breathe将doxygen与sphinx结合 作为python用户,文档工具的首选肯定是sphinx,要让这两个结合需要使用breathe 它可以直接pip安装. 其后续步骤为: (单独项目的话)使用sphinx-quickstart创建sphinx项目 配置conf.py,以支持breathe扩展.前提是这一扩展已经安装. 加入扩展: extensions = ['breathe'] 在conf.py中配置breathe: breathe_projects = { \"myproject\": \"./my_xml\" } breathe_default_project = \"myproject\" breathe_domain_by_extension = {\"h\" : \"c\"} 在需要的.rst文件中加入以下代码引入接口 按breathe扩展语法编写rst文件,比如: My API ========== binary_vector.h ----------------- .. doxygenfile:: binary_vector.h 运行 make html 生成html即可. 在这些步骤中，需要先调用doxygen生成xml，再调用sphinx-build(make html时自动调用)生成最终文档，如果想一步完成，可以在Makefile中加入doxygen调用: html: doxygen Doxyfile $(SPHINXBUILD) -b html $(ALLSPHINXOPTS) $(BUILDDIR)/html @echo @echo \"Build finished. The HTML pages are in $(BUILDDIR)/html.\" Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-05 00:28:04 "},"工具链/cython接口包装.html":{"url":"工具链/cython接口包装.html","title":"python接口包装","keywords":"","body":"python接口包装 我们一般用C的一个主要目的就是为python提供扩展,在python攻略中已经介绍了使用cython为python写扩展的方式,但这种方式一般是以python为主体的,而如果以C为主体,那么通常就和这种的方式有所区别,具体在:使用cython的包装模式,通过pyd文件声明接口,再使用pyx模块将项目包装为面向对象的python模块.这种方式 使用cython包装模式 为什么使用这种方式呢?主要是目前来看cython的包装模式是几个主流python实现都支持的方式,而且相对简单.接着我们还以binary vector为例进行包装 %%writefile ./code/cython_wrapper/python/pybinaryvector.pyx #cython: language_level=3 # distutils: language = c cdef extern from \"binary_vector.h\": struct BINARY_VECTOR: float x float y ctypedef BINARY_VECTOR *BINARY_VECTOR_P BINARY_VECTOR_P VEC_init(float,float) void VEC_del(BINARY_VECTOR_P) float VEC_mod(BINARY_VECTOR_P) BINARY_VECTOR_P VEC_add(BINARY_VECTOR_P,BINARY_VECTOR_P) float VEC_mul(BINARY_VECTOR_P,BINARY_VECTOR_P) cdef class BinaryVector: cdef BINARY_VECTOR_P _vec def __cinit__(self,float x,float y): self._vec = VEC_init(x,y) if self._vec is NULL: raise MemoryError def __dealloc__(self): if self._vec is not NULL: VEC_del(self._vec) property x: def __get__(self): return self._vec.x def __set__(self,new_x): self._vec.x = new_x property y: def __get__(self): return self._vec.y def __set__(self,new_y): self._vec.y = new_y cpdef mul(self,BinaryVector that): return VEC_mul(self._vec,that._vec) def __mul__(self,BinaryVector that): return self.mul(that) def add(self,BinaryVector that): cdef BINARY_VECTOR_P ptr ptr = VEC_add(self._vec,that._vec) result = BinaryVector(ptr.x,ptr.y) if ptr is not NULL: VEC_del(ptr) return result def __add__(self,BinaryVector that): return self.add(that) def mod(self): return VEC_mod(self._vec) Overwriting ./code/cython_wrapper/python/pybinaryvector.pyx %%writefile ./code/cython_wrapper/python/setup.py from distutils.core import setup from pathlib import Path from distutils.extension import Extension from Cython.Build import cythonize from Cython.Distutils import build_ext self_path = Path(__file__).resolve() self_dir = self_path.parent project_dir = self_dir.parent lib_dir = project_dir.joinpath(\"build/lib\") inc_dir = project_dir.joinpath(\"build/inc\") source_dir = project_dir.joinpath(\"python\") extension = Extension( \"pybinaryvector\", sources=[str(source_dir.joinpath(\"pybinaryvector.pyx\"))], include_dirs=[str(inc_dir)], libraries = [\"vector\"], library_dirs = [str(lib_dir)] ) setup( cmdclass={'build_ext': build_ext}, ext_modules=cythonize(extension), ) Overwriting ./code/cython_wrapper/python/setup.py 在项目根目录下先用cmake编译静态库,之后再进入python文件夹使用python setup.py build_ext --inplace编译动态库让python可以调用 !python ./code/cython_wrapper/python/setup.py build_ext --inplace running build_ext building 'pybinaryvector' extension gcc -Wno-unused-result -Wsign-compare -Wunreachable-code -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes -I/Users/huangsizhe/Lib/conda/anaconda3/include -arch x86_64 -I/Users/huangsizhe/Lib/conda/anaconda3/include -arch x86_64 -I/Users/huangsizhe/Workspace/Documents/TutorialForCLang/c-tool-chain/code/cython_wrapper/build/inc -I/Users/huangsizhe/Lib/conda/anaconda3/include/python3.7m -c /Users/huangsizhe/Workspace/Documents/TutorialForCLang/c-tool-chain/code/cython_wrapper/python/pybinaryvector.c -o build/temp.macosx-10.7-x86_64-3.7/Users/huangsizhe/Workspace/Documents/TutorialForCLang/c-tool-chain/code/cython_wrapper/python/pybinaryvector.o gcc -bundle -undefined dynamic_lookup -L/Users/huangsizhe/Lib/conda/anaconda3/lib -arch x86_64 -L/Users/huangsizhe/Lib/conda/anaconda3/lib -arch x86_64 -arch x86_64 build/temp.macosx-10.7-x86_64-3.7/Users/huangsizhe/Workspace/Documents/TutorialForCLang/c-tool-chain/code/cython_wrapper/python/pybinaryvector.o -L/Users/huangsizhe/Workspace/Documents/TutorialForCLang/c-tool-chain/code/cython_wrapper/build/lib -lvector -o /Users/huangsizhe/Workspace/Documents/TutorialForCLang/c-tool-chain/pybinaryvector.cpython-37m-darwin.so Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-05 00:56:41 "},"数据模型/":{"url":"数据模型/","title":"数据模型","keywords":"","body":"C语言的数据模型 说python的数据模型核心就是协议,那C语言的数据模型是什么呢?可以说C的数据模型就是指针和内存. 本章内容主要包括: 系统堆栈和C语言内存模型 类型系统 自定义结构 指针 本文使用jupyter notebook写成,使用jupyter-c-kernel在notebook中执行C语言代码,项目的notebook可以在tutorialforclang/c-data-module项目中找到. Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-05 03:53:33 "},"数据模型/系统堆栈和C语言内存模型.html":{"url":"数据模型/系统堆栈和C语言内存模型.html","title":"系统堆栈和C语言内存模型","keywords":"","body":"系统堆栈和C语言内存模型 C语言前文也已经分析过实际上也只是对汇编语言的一层封装.说到C的语言基础,我们不得不提到计算机的构成. 计算机大家都知道是由各种元件组成的,负责逻辑计算的cpu,负责暂存数据的内存.负责图像显示计算的显卡,负责发出声音的声卡,负责联通网络的网卡,以及一众输入输出设备.其实这些硬件的操作其实都是在系统启动时存在内存中,通过访问指定地址来实现的.汇编可以直接访问地址,而C可以通过指针来访问这些地址. 系统中的内存:栈与堆 计算机中的内存就是内存,但系统中的内存就不再是内存了,而是被系统抽象成了堆,栈以及一些其他分段,数据,函数都存在其中,由其他逻辑调度. 每个进程启动都会自动划出一块内存来划分成上面的结构. 栈空间又系统管理,很小,空间大小,对象创建回收由系统分配调度,不同的系统默认分配不同的大小. 堆空间则是手动档,可以非常大,大到上G,堆上的空间需要手动申请,用完了也得手动释放,要访问本质上也只能通过指针来访问. 全局量存放全局变量 常量段存放常量,像字符串也是常量 代码段存放代码逻辑.函数什么都也就放那边. 在这其中常量段和代码段就是所谓的文本段,而全局量就是数据段 而如何找到这些段中对应的内容呢,这就需要记录存储器单元的地址.比如如下这段代码: int y = 1; int main(){ int x = 4; return 0; } y就存放在数据段,x就存放在栈中,假设y的存储器地址为100000,那就是说1000000地址的存储器其中存放的是int类型的一个值为1的内容. 而这个地址的编号也就是使用取地址符&取出来的东西了.而所谓的指针也就是存放这个地址的空间了. 而我们需要知道这段地址中的内容是什么类型,这样程序才知道要如何处理,所以指针也需要类型. 如果我们使用库进行链接,那么内存的分配还会稍微复杂一些 堆中内存的分配和回收 C语言标准库提供了4个操作内存的接口: malloc void *malloc(size_t size);在堆上开辟一个指定长度的空间,函数的返回值为该区域的首地址用于标识这块内存 calloc void *calloc(size_t nmemb, size_t size)用于在堆上向开辟n个,每个占size个字节的内存空间,并把分配的内存全都初始化为零值.函数的返回值为该区域的首地址用于标识这块内存 realloc void *realloc(void *ptr, size_t size)给一个已经分配了地址的指针重新分配空间,参数ptr为原有的空间地址,size是重新申请的地址空间大小,函数的返回值为该区域的首地址用于标识这块内存 free void free(void *ptr)释放指针指向的这块内存 我们应该养成良好的习惯,有创建就有回收,避免内存溢出. Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-05 03:52:29 "},"数据模型/类型系统与变量常量.html":{"url":"数据模型/类型系统与变量常量.html","title":"类型系统与变量常量","keywords":"","body":"类型系统与变量常量 C中的数据类型 C语言中的数据类型很少,但很繁琐,讲起来很容易乱套,这边有一张图很好的总结了C中的数据类型,除了bool型外的数据类型都可以在其中找到对应 short、int、long、char、float、double这6种被称为基本类型,他们除了意义不同精度不同,更加关键的是他们所占用的内存大小不同. 在32 位的系统上: short 在32位的系统上占用2个byte； int 在32位的系统上占用4 个byte； long 在32位的系统上占用4 个byte；64位系统 8个byte float 在32位的系统上占用4 个byte； double 在32位的系统上占用8 个byte； char 在32位的系统上占用1 个byte。 针对int,long,short,char,还有一个修饰关键词unsigned可以放在他们前面,表示无符号. 另外处理大数可以使用longlong数据类型,表示一个8byte的数 C可以像python中一样自定义类型.具体的自定义类型的方式我们在后面的面向对象基本用法中会有说明. 基本类型转换 C语言的类型转换，可以分为两种： 自动类型转换（隐式类型转换，有编译器帮你去完成） 对于自动类型转换，最常见的就是混合运算以及赋值运算，还有一种就是函数值的类型转换 赋值运算： 自动把“＝”右边的表达式的类型转换成“＝”右边的变量的类型，例如 int a=4.5; a的值实际是4！ 混合运算： 就是一个运算表达式当中包含了多个类型，这时候就需要有类型转换。当运算符两边的操作数类型不同时，其中一个操作数就要经过类型转换以和另一个操作数的类型相一致，然后才能进行运算。 变换操作数采取就高不就低的原则，即级别低的操作数先被转换成和级别高的操作数具有同一类型, 然后再进行运算，结果的数据类型和级别高的操作数相同。 高 double ←← float ↑ ↑ ↑ long ↑ ↑ ↑ unsigned ↑ ↑ 低 int ←← char,short 自动转换顺序表 函数返回值的类型转换： int f1(){ return 36.8;} 强制类型转换(你知道自己想要什么,所以才转换). C语言中可以使用强制类型转换运算符,可以利用强制类型转换运算符将一个表达式转换成所需类型: 例如： (double)a (将a转换成double类型) (int)(x+y) (将x+y的值转换成整型) (float)(5%3) (将5%3的值转换成float型) 注意，表达式应该用括号括起来。如果写成(int)x+y 则只将x转换成整型，然后与y相加。 变量 和python中类似,C中也有变量,变量的定义方式如下: int a,b,c...; 也就是 (存储说明符 )数据类型 变量名1,变量名2...; 变量的三要素 一个变量必然有三样内容: 地址,内存空间的标记 值,存放的具体内容 变量名,在程序中用于标记变量的符号 在多数语言(包括C语言)中还要加上一个类型,用以让编译器或者解释器知道该如何处理这个变量 变量声明 C语言和python不同的是python的变量不需要事先声明,而C语言必须事先声明,习惯上变量会在一起声明,而不是东一块西一块的,这样也有助于debug. 存储说明符则是对变量/函数特性的声明,常见的存储说明符有: static 静态局部变量,有时希望函数中的局部变量的值在函数调用结束后不消失而保留原值，这时就应该指定局部变量为\"静态局部变量\".它具有以下特点: 静态局部变量在函数内定义，但不象自动变量那样，当调用时就存在，退出函数时就消失。静态局部变量始终存在着，也就是说它的生存期为整个源程序。 静态局部变量的生存期虽然为整个源程序，但是其作用域仍与自动变量相同，即只能在定义该变量的函数内使用该变量。退出该函数后， 尽管该变量还继续存在，但不能使用它。 register 寄存器变量,为了提高效率，C语言允许将局部变量得值放在CPU中的寄存器中，这种变量叫\"寄存器变量\" extern 外部变量（即全局变量）是在函数的外部定义的，它的作用域为从变量定义处开始，到本程序文件的末尾。如果外部变量不在文件的开头定义，其有效的作用范围只限于定义处到文件终了。如果在定义点之前的函数想引用该外部变量，则应该在引用之前用关键字 extern对该变量作“外部变量声明”。表示该变量是一个已经定义的外部变量。有了此声明，就可以从“声明”处起，合法地使用该外部变量。 总结： 从作用域来划分分为: 局部变量 静态局部变量static(离开函数，值还保留) 寄存器局部变量register(离开函数，值消失) 形式参数可以定义为自动变量或者register变量 全局变量 静态外部变量(作用域只能在该文件中，文件作用域) 外部变量(非静态外部变量,全局变量，可以被其它文件使用) 从变量的生存周期来分： 动态存储 寄存器变量register 形式参数 静态存储 静态局部变量 静态外部变量 外部变量(全局变量) 从变量值存放的位置： 内存中的静态存储区(全局数据区) 静态局部变量 静态外部变量 外部变量(全局变量) 内存中的动态存储区(栈) 形式参数 CPU中的寄存器 寄存器变量register 注意:当局部变量与全局变量重名的时候,和python一样,以局部变量为准,屏蔽全局变量 符号重载引起的混淆 我们知道C语言中关键字很少,这很简洁,但带来的问题就是符号重载,同样的关键字在不同的上下文中有不同的含义,其他还好,最容易混淆的就是用在声明中的两个关键字: static 在函数内部表示该变量的值在各个调用间一直保持延续性 在函数这一级,表示该函数只对本文件可见 extern 用于函数定义,表示全局可见(属于冗余,不用这个装饰也全局可见) 用于变量,表示它在其他地方定义 常量 常量是指值不可变的变量,C语言中的常量其实一直以来都被误解,记得我学C的时候常量定义是这样的: #define Pi 3.14 这才是真正的常量,因为这个数值使用了所谓的宏,利用宏把3.14替换了Pi,是写在代码里的不是被赋值的. 而容易混淆的是const关键字,这个字可能更适合叫readonly,他并不是表示常量,而是表示后面的变量是只读的, const double Pi = 3.14; Python中没有常量一说,我们就写一个例子来理解下什么是常量 #include const float Pi = 3.1415; int main(void){ int r; float s; r = 2; s = Pi*r*r; printf(\"半径2m圆的面积为:%f\\n\",s); Pi = 3.14; printf(\"Pi=%f\\n\",Pi); return 0; } /var/folders/2w/71b83qh117q3sjhm8xgnr7w00000gn/T/tmpiouolrs1.c:12:8: error: cannot assign to variable 'Pi' with const-qualified type 'const float' Pi = 3.14; ~~ ^ /var/folders/2w/71b83qh117q3sjhm8xgnr7w00000gn/T/tmpiouolrs1.c:3:13: note: variable 'Pi' declared const here const float Pi = 3.1415; ~~~~~~~~~~~~^~~~~~~~~~~ 1 error generated. [C kernel] GCC exited with code 1, the executable will not be executed 常数赋值后就无法再次赋值,将这句注释掉 #include const float Pi = 3.1415; int main(void){ int r; float s; r = 2; s = Pi*r*r; printf(\"半径2m圆的面积为:%f\\n\",s); //Pi = 3.14; printf(\"Pi=%f\\n\",Pi); return 0; } 半径2m圆的面积为:12.566000 Pi=3.141500 Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-05 01:47:49 "},"数据模型/自定义结构和类型.html":{"url":"数据模型/自定义结构和类型.html","title":"自定义结构和类型","keywords":"","body":"自定义结构和类型 C语言允许使用关键字typedef来为各种类型设置别名,但问题在于其语法相当混乱,用法大约是这么几种: 为原生类型赋予别名 typedef int count; int类型就有了别名count 为函数取别名 typedef int (*intfunc)(int); 原型为int (*)(int)的函数指针就有了别名intfunc,这通常用于指定函数的回调函数参数的类型. 用的时候就是 intfunc intmap(x); 为数组取别名 typedef int intarr[5]; 表示将int类型的长度为10的数组取别名为intarr 用的时候 intarr a = {1,2,3,4,5}; 为函数数组取别名 typedef int (*intfunc_arr[10])(int); 表示将存放int (*)(int)类型函数指针的数组取别名为intfunc_arr 为结构体取别名 typedef struct { int x; } x_struct; 表示这个结构体别名叫x_struct. C中的特殊结构 C中提供了3种特殊的结构,用于描述复杂的结构化数据,分别是 结构体 联合体 枚举 结构体 结构体可以理解为一组有意义的特殊成员变量的组合,比如对于小朋友,有性别,姓名,年龄身高,体重这几个维度,每个小朋友都会有这些属性.我们就可以将小朋友定义为一个结构体 结构体的定义方式为: struct 结构标签{ 类型 成员变量名; 类型 成员变量名; 类型 成员变量名; }; 注意不要落了封号 我们来声明一个Child结构体: struct Child{ const char *name; const char *sex; int age; float weight; float height; }; ps:在结构体中字符串使用const char *来保存你不想修改的字符串,也就是字符串字面值,这种方式只保存了字符串的指针,只有把字符串定义成字符数组如char name[20]这样才能将字符串保存在结构体中,但一般我们不这么用,原因在于C语言中字符串常量本来就存放在代码段,没有必要到处保存 结构体变量的初始化 结构体是一种自定义类型,它和一般的类型如int呀char呀有相同的性质,不同之处是他是值是复合的,要非初始化上面的结构体结构体,只要这样: struct Child Tom = {\"Tom\",\"m\",8,48.5,1.5}; 也可以声明变量后再赋值 struct Child Sam; Sam.name = \"Sam\"; Sam.sex = \"m\"; Sam.age = 7; Sam.weight = 45.7; Sam.height = 1.57; 结构体变量的特性 结构体变量作为函数参数传递的时候需要注意是传值的,这和一般的类型是一样的. 如果我们的函数参数是结构体的指针变量(传引用),那么和一般的指针变量一样,需要注意. 访问结构体变量中的字段 对于一个结构体变量,比如上文的Sam,访问方式就和第二种初始化方式一样,使用.符号即可,特殊的地方在于如果是如下这种情况: struct Child *Tom = {\"Tom\",\"m\",8,48.5,1.5}; 那么就比较尴尬了,需要记住*Tom.name访问的其实是*(Tom.name),正确的写法应该是(*Tom).name.为了避免用错括号的情况,c语言中在结构体变量的指针要访问其内部字段时使用->代替. Tom->name 自定义类型操作 我们可以使用typedef关键字将结构体或者枚举,或者其他任何的类型取个别名,这样可以更加方便使用 typedef 原类型 类型别名; 基本上这也是结构体的正常使用方式,毕竟每次申明都要带上struct关键字实在是太罗嗦了 例子: #include #include typedef struct{ char name[10]; char sex[2]; int age; float weight; float height; } Child; int main(void) { Child Tom = {\"Tom\",\"m\",8,48.5,1.5}; Child Sam; strcpy(Sam.name,\"Sam\"); strcpy(Sam.sex,\"m\"); Sam.age = 7; Sam.weight = 45.7; Sam.height = 1.57; printf(\"%s 身高%fm\\n\",Tom.name,Tom.height); printf(\"%s 体重%fkg\\n\",Sam.name,Sam.weight); return 0; } Tom 身高1.500000m Sam 体重45.700001kg 为什么要有结构体 设想下有这样一个场景: 我们有若干个函数用于处理水族馆中的各种水产 /* 打印目录项 */ void catalog(const char *name, const char *species, int age){ printf(\"%s 是一种的 %s.这只%s已经%i岁了\\n\", name,species,name,age); } /* 打印贴在水缸上的标签 */ void label(const char *name,const char *species, int age){ printf(\"名字: %s\\n种类: %s\\n%i 岁.\\n\", name,species,age); } int main(){ catalog(\"皮皮虾\",\"节肢动物\",2); label(\"皮皮虾\",\"节肢动物\",2); return 0; } 我们用来描述水产的参数现在有3个,这个数量还在可控范围内,但如果再多几个,那这个函数将变得非常不可读,同时,如果这些描述一旦有变化,修改这些函数将成为一件非常棘手的事儿, 结构体最大的作用就在这里,使用结构体将这些参数归类到一起,这样就不需要一次传入大量的参数了 #include #include #include /* 定义 */ typedef struct { const wchar_t *name; const wchar_t *species; int age; } Aquatic; /* 打印目录项 */ void catalog(Aquatic *aquatic){ wprintf(L\"%ls 是一种的 %ls.这只%ls已经%i岁了\\n\", aquatic->name,aquatic->species,aquatic->name,aquatic->age); } /* 打印贴在水缸上的标签 */ void label(Aquatic *aquatic){ wprintf(L\"名字: %ls\\n种类: %ls\\n%i 岁.\\n\", aquatic->name,aquatic->species,aquatic->age); } int main(){ setlocale(LC_ALL, \"zh_CN.UTF-8\"); Aquatic mantis_shrimp = {L\"皮皮虾\",L\"节肢动物\",2}; catalog(&mantis_shrimp); label(&mantis_shrimp); return 0; } 皮皮虾 是一种的 节肢动物.这只皮皮虾已经2岁了 名字: 皮皮虾 种类: 节肢动物 2 岁. typedef是结构体的好朋友 上面介绍了如何用typedef为结构体取别名,但我们看别人代码一般都不这么用,下面介绍几种常见的用法和其利弊: 结构体标签与别名一致 typedef struct T{ int x; } *T; 或者 struct T{ int x; }; typedef struct T *T; 这种方式如果要使用结构体的指针就直接使用T,如果使用结构体本身可以使用struct T,这样的好处是相当简洁,但不好的地方在T和struct T很容易混淆. 为结构体和其指针分别取不同的别名 typedef struct{ int x; } T,*T_p; 这种方式用结构体指针就使用T_p,使用结构体本身则可以使用T这种方式的好处是结构体本身和指针都分开用不同的名字,不好的地方在结构体本身因为没有struct关键字所以当代码很长的时候很容易语义上混淆. 更加推荐的做法, struct T{ int x; }; typedef struct T *T_p; 这种方式最老实,但也最清晰的,结构体指针就使用T_p,使用结构体本身则可以使用struct T. 共用体 在C语言中,还有另外一种和结构体非常类似的语法,叫做共用体(Union),它的定义格式为: union 共用体名{ 成员列表 }; 结构体和共用体的区别在于: 结构体的各个成员会占用不同的内存,互相之间没有影响; 共用体的所有成员占用同一段内存,修改一个成员会影响其余所有成员. Union的作用就在于当成员间 结构体占用的内存大于等于所有成员占用的内存的总和(成员之间可能会存在缝隙),共用体占用的内存等于最长的成员占用的内存.共用体使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来成员的值覆盖掉. #include union data{ int n; char ch; short m; }; int main(){ union data a; printf(\"%ld, %ld\\n\", sizeof(a), sizeof(union data) ); a.n = 0x40; printf(\"%X, %c, %hX\\n\", a.n, a.ch, a.m); a.ch = '9'; printf(\"%X, %c, %hX\\n\", a.n, a.ch, a.m); a.m = 0x2059; printf(\"%X, %c, %hX\\n\", a.n, a.ch, a.m); a.n = 0x3E25AD54; printf(\"%X, %c, %hX\\n\", a.n, a.ch, a.m); return 0; } 4, 4 40, @, 40 39, 9, 39 2059, Y, 2059 3E25AD54, T, AD54 枚举 枚举在python中并没有直接的实现,但C++中它是默认的一种自定义类型,它的声明关键字是enum 声明枚举类型: enum 枚举类型名 {枚举值1,枚举值2...} 定义枚举变量: 枚举类型名 变量名 = 枚举值; 需要注意的是枚举类型变量只能赋值为枚举类型声明时的枚举值,其他都会报错,而枚举值实际上是对应声明时位置对应的整形数. 看个例子: #include enum Weekday {MON,TUE,WED,THU,FRI,SAT,SUN}; int main(void) { enum Weekday firstday = TUE; printf(\"first day is %d\\n\",firstday); return 0; } first day is 1 枚举值转枚举字面量 一个常见的用处是通过枚举值或者int型的数转成对应的字面量字符串.这个实现需要通过宏中#操作.#表示字符串化操作符,它把其后的串变成用双引号包围的串 可以参考下面的代码. #include #define ENUM_CHIP_TYPE_CASE(x) case x: return(#x); enum cvmx_chip_types_enum { CVMX_CHIP_TYPE_NULL, CVMX_CHIP_TYPE_DEPRECATED, CVMX_CHIP_TYPE_OCTEON_SAMPLE, CVMX_CHIP_TYPE_MAX }; static inline const char *cvmx_chip_type_to_string(enum cvmx_chip_types_enum type) { switch (type) { ENUM_CHIP_TYPE_CASE(CVMX_CHIP_TYPE_NULL) ENUM_CHIP_TYPE_CASE(CVMX_CHIP_TYPE_DEPRECATED) ENUM_CHIP_TYPE_CASE(CVMX_CHIP_TYPE_OCTEON_SAMPLE) ENUM_CHIP_TYPE_CASE(CVMX_CHIP_TYPE_MAX) } return \"Unsupported Chip\"; } int main() { enum cvmx_chip_types_enum a; printf(\"the result:%s \\n\",cvmx_chip_type_to_string(CVMX_CHIP_TYPE_OCTEON_SAMPLE)); printf(\"the result:%s \\n\",cvmx_chip_type_to_string(2)); return 0; } the result:CVMX_CHIP_TYPE_OCTEON_SAMPLE the result:CVMX_CHIP_TYPE_OCTEON_SAMPLE Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-05 03:38:37 "},"数据模型/指针.html":{"url":"数据模型/指针.html","title":"指针","keywords":"","body":"指针 指针是python中没有的概念.上语文课的时候,老师最长说的话是不是\"请将课本翻到xxx页\"?在那一页上有课上的内容,我们要看的是内容,但却使用页码标记内容,这就是指针的核心思想了. 指针是变量的地址,与之对应的是内存空间的标记,一本有页码的笔记本,在某一页上可以写着日记,也可以画着画,它只是被标记的空间而已,内容取决于需要. 取地址符&和指针运算符* 要取到变量的地址,只用在变量前使用&就可以得到了 如果我们想通过变量的地址获取它的值,那只要在地址前使用*就可以了 指针变量 存储变量地址的变量就是指针变量,他的声明形式很简单 类型* 变量名 这样变量中就是存的地址了,而要取出该地址中的值,同样的只要使用指针运算符即可 指针运算 指针也就是地址,在C中表现为可以运算的正整数数值,因此,它和int,long之类一样,是可以运算的,所用的运算符也是通常的运算符. 在C中我们可以直接通过运算来实现地址位置的偏移.这也是C作为系统语言的优势. 空指针 C中可以用NULL为任意指针变量赋值,他的意义是指针为空,或者说,指针变量没有指向任何地址 void类型的指针 void类型的指针很特殊,它有这样的性质: void指针可以指向任何数据类型,如果要将void指针赋给其他类型指针，则需要强制类型转换如：pint= (int *)pvoid 可以用任何类型的指针对void指针进行赋值和初始化 void指针无法进行指针操作 void* p就是一个典型的void指针,一般void指针用在内存操作, 因此void指针常用在: 内存操作 定义函数时,如果函数的参数可以是任意类型指针，那么应声明其参数为void* 作为指向函数的指针 为什么要用指针? 如上面所说,指针是保存的一个变量的内存地址,那为什么要这么做呢? C语言按值传递参数 和python中不同,C语言调用函数的方式是严格按值传递. #include int add(int x){ x++; printf(\"inner x:%d\\n\",x); return x; } int main(){ int x = 4; printf(\"before add x:%d\\n\",x); int y = add(x); printf(\"after add x:%d\\n\",x); return 0; } before add x:4 inner x:5 after add x:4 上例中的add函数接收一个int类型的参数,在被调用时,传入的参数值会按顺序被复制给函数对应的栈中对应的变量中. 这样的好处是函数的结果的不会因为外部数据变化而受到影响,坏处就是也影响不到外面的变量数据.而如果希望函数改变外部数据,那就应该使用指针.因为传入的是一段地址,所以只要根据这段地址找到这个变量的值就行. Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-05 01:53:48 "},"基本语法/运算符.html":{"url":"基本语法/运算符.html","title":"运算符","keywords":"","body":"运算符 C中的运算符和python中的类似,这边只拉出不同的几个 自增运算符 也就是传说中的++/--当然最好别用,语义不清.当然C中也有赋值运算符+=,但还是讲下,前置++速度高于后置,结果的区别看例子: #include int main(void){ int a = 5,b = 5; a++; ++b; printf(\"a:%db:%d,\\n\",a,b); a = b++; printf(\"after a=b++\\na:%db:%d,\\n\",a,b); a = ++b; printf(\"after a=++b\\na:%db:%d,\\n\",a,b); return 0; } a:6b:6, after a=b++ a:6b:7, after a=++b a:8b:8, 如果前面有赋值,前置++后变量值自增1,后置++变量先赋值过去,然后再自增 逻辑运算符 Python中使用and or not 这些英文单词作为逻辑运算符,C++中则使用符号: C++中 python中 意义 && and 与 ll or 或 ! not 非 条件运算符 这个算是比较奇葩的了,C++中使用?:来做条件运算(三元运算),与之对应的是python中的条件表达式 True if exp else False. 看个例子: #include int main(void){ int a = 5; printf(\"a=5 是%s\\n\",a%2==0? \"偶数\":\"奇数\"); return 0; } a=5 是奇数 sizeof运算符 sizeof运算符用来获取变量或者类型占用的内存大小 #include int main(void){ long long a = 5; printf(\"a=5 占用%lu位\\n\",sizeof(a)); return 0; } a=5 占用8位 强制类型转换运算符 伴随着类型系统,必然会有的就是类型转换操作,在python中形式是这样 a = 10 float(a) 10.0 c++中类似但形式不同 他的操作符是这样 (float) 变量名 #include int main(void){ int a = 5; float b; b = (float) a; printf(\"a = %d,b = %f\\n\",a,b); return 0; } a = 5,b = 5.000000 Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-05 23:39:20 "},"基本语法/逻辑控制语句.html":{"url":"基本语法/逻辑控制语句.html","title":"逻辑控制语句","keywords":"","body":"逻辑控制语句 C中的逻辑控制语句其实还是基本的那么几个,与python相比,多了switch语句和goto语句.作为pythoner这部分其实没啥可讲,这边只列出形式. 循环语句 for循环 for(exp1;exp2;exp3){ 代码块 } exp1 一般是变量初始化,注意变量需要先声明,标准c语言不允许在exp1中直接声明变量,但其实很多编译器已经支持这种写法 exp2 用于判断是否停止循环,如果为为true则执行下面的代码块,否则不执行并且语句结束 exp3 如果exp2为true,则在执行完代码块后执行exp3,然后进入下一循环 while循环 while(exp){ 代码块 } exp 判断其是否为真,如果是则循环结束,否则进入代码块执行,然后进入下一循环 do...while循环 do{ 代码块 }while(exp); 先执行do中代码块 在判断while中表达式,如果为真则循环结束,否则继续循环执行do中代码 break和continue 和python中一样,我们也可以用break和contiue来中断循环.规则也相同 例: 牛顿法求2开根 python版本 EPS = 0.00001 a = 2 X = a/2.0 lastX = 0 while(abs(X - lastX) > EPS ): lastX = X X = (lastX+float(a/lastX))/2 print(X) 1.4142135623746899 C版本: #include #include const double N = 2.0; double sqrt_my(double a,double EPS){ double x,last_x; x = a/2; do{ last_x = x; x = (last_x + a/last_x)/2; }while(fabs(last_x - x) > EPS); return x; } int main(void){ printf(\"根号2是%lf\\n\",sqrt_my(N,0.0001)); return 0; } 条件语句 if(exp1){ 代码块 }else if(exp2){ 代码块 }else{ 代码块 } 这个和python的差不多 分支语句 switch在python中被去掉了,主要也是因为它与if语句功能重复,不过swtich还是有用的,可以让代码看起来干净不少 switch(exp){ case 常量表达式1: 语句组1 break; case 常量表达式2: 语句组2 break; case 常量表达式3: 语句组3 break; default: 语句组4 } case是可以贯通的,如果case下面没有break,则它会穿到下一个break之上的位置才执行结束. goto goto就厉害了,这个体现了c对底层的支持,它表示无条件跳转,用法是用label:标记要跳转的位置,然后goto label就可以了 这个语句是汇编语言的常用语句,用好了很牛,用烂很烂,建议不要滥用. 大致有这么两个使用场景: 多层循环跳出 多层循环嵌套代码会很难以维护,这时候可以考虑使用goto. #include #include int complex_loop(void){ for (int i=1;i 结果是1 统一处理并返回 这种尤其在异常处理时比较好用. int func(){ int res = 0; if(!){ goto func_return_fail; } if(!func_step2()){ goto func_return_fail; } func_return_normal: UnlockSomething(); return res; func_return_fail: res = -1; UnlockSomething(); return res; } Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-08 09:48:07 "},"基本语法/函数.html":{"url":"基本语法/函数.html","title":"函数","keywords":"","body":"函数 函数的定义 C语言中的函数声明和定义必须带参数和返回值类型,他的形式是这样 返回变量类型 函数名(参数类型 参数1,参数类型,参数2){ 语句组 return 返回值; } 在上一讲中我们计算开方已经使用了函数,需要注意的是C中的函数并不像python中那么万能,它无法作为参数或者返回值,也没有匿名函数,它的作用只是写接口和一些简单抽象而已. 函数的类型 我们定义函数的类型就是它返回值的类型,别问为啥反正就是这样. 函数的调用 C中的函数只在被调用时才会在内存中开辟出空间,当调用结束后,为函数开辟出的空间就会被回收,C是一种非常节俭的语言,也正因为这样它才能在单片机的编程中有所作为 函数的参数传递 函数的参数可以带有默认值,默认值可以是常数,也可以是表达式. C中的函数参数在一般情况下都是传值的(也就是复制),只有参数是引用(数组,指针)的时候才是传递的引用(数组,指针) 函数的原型与函数声明 C语言的特点是可以先声明再定义,对于函数也一样,通常声明会放在头文件中,这部分内容会放在部分理解 在C语言中函数的声明就是函数的原型,他的形式是: 返回变量类型 函数名(参数类型1,参数类型2); 入口函数与命令行参数输入 之前的例子中,我们接触的入口函数都是参数为空,返回为int这样的,这种形式常见于直接执行的程序,而典型命令行工具的比如像gcc这样,它必然需要有一个输入参数,这种时候我们可以利用另一种形式的入口函数来实现: int main(int argc, char *argv[]){ 代码段 } argc 是入口参数的长度(几个参数) argv 则是由输入字符串组成的数组 例: 将之前的牛顿法求开根改为命令行工具,参数为第一位要开的数,第二位为开几次方根,精度规定为0.0000001,如果达不到,那允许最多迭代500次 牛顿法扩展都n次方根$ \\sqrt[k] a $的表达式为: $x_{n+1} = x_n - \\frac {x_n^k-a} {kx_n^{k-1}} = \\frac {k-1}{k} x_n + \\frac {a}{kx_n^{k-1}}$ #include #include #include const double EPS = 0.0000001; double newton_method(double a,int n){ double x=0,last_x=0; if (a>0){ x = a/n; for(int i = 0;i 内联函数 inline关键字可以指定函数为内联函数,内联函数没有多余的函数调用开销,是一种以空间换时间的技术 inline int min(int first, int secend) {/****/}; 慎用内联 内联能提高函数的执行效率,为什么不把所有的函数都定义成内联函数?如果所有的函数都是内联函数,还用得着\"内联\"这个关键字吗?内联是以代码膨胀(复制)为代价,仅仅省去了函数调用的开销,从而提高函数的执行效率.如果执行函数体内代码的时间,相比于函数调用的开销较大,那么效率的收获会很少.另一方面,每一处内联函数的调用都要复制代码,将使程序的总代码量增大,消耗更多的内存空间. 以下情况不宜使用内联: 如果函数体内的代码比较长，使用内联将导致内存消耗代价较高. 如果函数体内出现循环,那么执行函数体内代码的时间要比函数调用的开销大.类的构造函数和析构函数容易让人误解成使用内联更有效.要当心构造函数和析构函数可能会隐藏一些行为,如\"偷偷地\"执行了基类或成员对象的构造函数和析构函数.所以不要随便地将构造函数和析构函数的定义体放在类声明中.一个好的编译器将会根据函数的定义体,自动地取消不值得的内联(这进一步说明了inline不应该出现在函数的声明中). 函数与指针 C语言中的精髓之一就在于函数与指针互动了 指针作为参数 指针作为参数就可以理解为所谓的传引用,以地址作为参数,函数的操作会影响引用的内容,这样几百年函数的内存被回收,操作的结果也会生效 最典型的,交换两个变量的值 #include void exchange(int* ptr_a,int* ptr_b){ int temp; temp = *ptr_a; *ptr_a = *ptr_b; *ptr_b = temp; return; } int main(void) { int a = 78,b = 28; printf(\"before exchange a=%d,b=%d\\n\",a,b); exchange(&a,&b); printf(\"after exchange a=%d,b=%d\\n\",a,b); return 0; } before exchange a=78,b=28 after exchange a=28,b=78 指针参数的保护 我们如果传递的是指针,那么就意味着内容是可变的,于是就又被篡改的危险,但如果我们希望不被篡改,那么最好的办法就是将这个指针引用的内容在函数中保护起来,这就用到了const参数了,这个被称作常量指针 #include int main(void) { const int a = 78,b = 28; int c = 18; const int* p = &a; printf(\"p:%d\\n\",*p); //*p = 58//报错,*p无法重新复制 p = &b;//可以给p重新复制, printf(\"p:%d\\n\",*p); return 0; } p:78 p:28 指针作为返回值(指针函数) 如果要一个函数返回指针,那么就像下面这么定义 int *f(int，int); 指针作为返回值就意味着可以返回复杂的数据结构以及数组了 函数指针 函数指针是指指向函数的指针,事实上函数一样也是一种储存在内存中的数据,如果要做一定的抽象,函数指针是必不可少的.定义一个函数指针如下: int (*f)(int,int); 形式上 指针函数和函数指针很像,也就是一对括号的不同而已,但差异非常大,指针函数是定义的函数,而函数指针是定义的指针 函数常量指针 C中事实上并没有所谓常量函数,但我们确实可以指定指向函数的指针,或者函数的返回值指针,各种各样的指针为常数 int (*const func)(int) = some_func;//指向函数的常量指针,通常会接一个初始化 void const *(*func)(int);//指定返回值为常量指针 void const *(*const func)(int) = func;//指向函数的常量指针,并指定返回值为常量指针 模拟高阶函数 对于函数式编程而言,高阶函数是一切的基础,学过python的一定不会陌生,C++中如何实现高阶函数呢 函数作为参数 求a到b间整数的和 int sum_int(int a,int b){ return a>b ?0:a + sum_int((a+1),b); } 求a到b间的整数的立方和: int cube(int x){ return (int)pow(x,3); } int sum_func(int a,int b,int (*func)(int)){ return a>b ?0:(*func)(a) + sum_func((a+1),b,func); } 求: 11⋅3+15⋅7+19⋅11+⋯ \\frac {1}{1 \\cdot 3} + \\frac {1}{5 \\cdot 7} + \\frac {1}{9 \\cdot 11} +\\cdots​1⋅3​​1​​+​5⋅7​​1​​+​9⋅11​​1​​+⋯ 它会非常缓慢地收敛到π8\\frac {\\pi}{8}​8​​π​​ float sum_func_stp(int a,int b,float (*const func)(int) , int (*const step)(int)){ return a>b ?0:(*func)(a) + sum_func_stp((*step)(a),b,func,step); } float func(int x){ return 1.0/(x*(x+2)); } int stp(int x){ return x+4; } float sum_pi(int a,int b){ float (*const ptr_func)(int) = func; int (*const ptr_stp)(int) = stp; return sum_func_stp(a,b,ptr_func,ptr_stp); } 完整的高阶函数例子: #include #include int sum_int(int a,int b){ return a>b ?0:a + sum_int((a+1),b); } int cube(int x){ return (int)pow(x,3); } int sum_func(int a,int b,int (*const func)(int)){ return a>b ?0:(*func)(a) + sum_func((a+1),b,func); } int sum_cube(int a,int b){ int (*const ptr_func)(int) = cube; return sum_func(a,b,ptr_func); } float sum_func_stp(int a,int b,float (*const func)(int) , int (*const step)(int)){ return a>b ?0:(*func)(a) + sum_func_stp((*step)(a),b,func,step); } float func(int x){ return 1.0/(x*(x+2)); } int stp(int x){ return x+4; } float sum_pi(int a,int b){ float (*const ptr_func)(int) = func; int (*const ptr_stp)(int) = stp; return sum_func_stp(a,b,ptr_func,ptr_stp); } int main(void) { int top = 5,bottom = 1; printf(\"range(%d,%d) = %d\\n\", bottom,top,sum_int(bottom,top)); printf(\"range(%d,%d)的立方和为%d\\n\", bottom,top,sum_cube(bottom,top)); printf(\"sum_pi(%d,%d)为%f\\n\", bottom,top,sum_pi(bottom,top)); } range(1,5) = 15 range(1,5)的立方和为225 sum_pi(1,5)为0.361905 Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-08 09:47:56 "},"基本语法/数组.html":{"url":"基本语法/数组.html","title":"数组","keywords":"","body":"数组 数组是一连串固定个数的同类型的数据,他们是一段连续的内存空间,数组是最高效也是最简单的数据结构,它的声明方式: 类型 变量名[元素个数]; 如果是多维数组,则可以是: 类型 变量名[元素个数][元素个数][元素个数]...; 数组可以通过下标访问内部元素,下标从0开始计数,c语言中数组的大小也是有限制的,尤其在函数内部定义的数组长度是很有限的.各个编译器不同,但一般还是够用的,但最好不要定义过大,以避免栈溢出 多维数组 C语言中的多为数组是从最右边的下标开始变化的,如果把多位数组看作是张量,那么最右边的就是最后面的向量,比如二维数组,右边的下标是向量,左边的下标向量的个数 数组初始化 C语言是比较原始的,声明的数组不会自动初始化,必须手动实现,以一个一维数组为例: int arrayA[5] = {0,0,0,0,0}; 而多维数组的初始化不过是将其中的元素替换为数组而已 int arrayA[5][2] = {{0,0},{0,0},{0,0},{0,0},{0,0}}; 如果不初始化而直接访问声明的数组,那么你会看到其中的元素是不知道啥玩意儿 访问数组元素 和python中的list,tuple类似,C中访问数组的元素也是使用[i]的形式,其实这个操作和指针的偏移量一致 数组作为函数参数 一维数组作为函数参数可以不写长度 二维数组作为函数参数可以不写行数,但列数必须写 数组越界问题 C语言算是比较原始的,数组的下标如果超过数组本身长度,编译器是可以编译的,也可以正常执行,就是结果会很诡异,因此需要避免. 用数组模拟矩阵 很多时候我们希望利用C扩展python的矩阵运算性能,这种时候多维数组就是我们最常接触的工具了 例,计算矩阵$\\left(\\begin{matrix}1 & 2 &3\\4 & 5 & 6\\end{matrix}\\right)$中最大的元素 #include int main(void){ int max_elem = 0; int matrix[3][2] = {{1,4},{2,5},{3,6}}; for (int i = 0;i=max_elem) { max_elem = matrix[i][j]; } } } printf(\"max element is %d\\n\",max_elem); return 0; } max element is 6 这是使用原生的数组进行实现,这种形式其实并不方便使用,更好的方式其实是开辟一段一维数组,然后通过封装实现功能.我们后面进行实现 数组与指针 很多学过C的人都认为数组和指针实际是一回事,其实不是这么回事,数组只是在一些情况下可以指针等价,但并不是一回事.以下情况下数组和指针是一回事: 表达式中的数组名就是指针 假如我们声明:int a[10], *p,i = 2; 我们就可以通过以下任何一种方式来访问a[i] p = a; p[i]; p = a; *(p + i); p = a + i; *p; 数组下标作为指针的偏移量 作为函数参数的数组名等同于指针 实际上编译器处理指针和数组的处理方式是不同的: 首先需要注意的是地址 y和地址 y 的内容之间的区别.因为在大多数编程语言中我们用同一个符号来表示这两个东西,由编译器根据上下文环境判断它的具体含义. x = y; 上面的式子就是最简单的赋值语句.其中等号的左边叫做左值,右边叫做右值. 编译器为每个变量分配一个地址作为左值,这个地址在编译时是可知的,而且该变量在运行时一直保存于这个地址.相反的,存储于变量中的值(右值)只有在运行时才可知.如果需要用到变量中存储的值,编译器就发出指令从指定地址读入变量值并将它存于寄存器中. 这里的关键之处在于每个符号的地址在编译时可知,所以,如果编译器需要一个地址(可能还需要加上偏移量)来执行某种操作,它就可以直接进行操作,并不需要增加指令首先取得具体地址,相反,对于指针,必须首先在运行时取得它的当前值,然后才能对它进行解除引用操作. 如果申明为数组extern char a[],那么a也就是一个内存地址.数组内的字符可以从这个地址找到.编译器并不需要知道数组有多长,因为它只产生从起始位置起的到偏移量位置的便宜地址. 如果申明为extern char *p,那么它将告诉编译器p是一个指针,指向的对象是一个字符,为了取得这个字符,必须得到地址p的内容,把它作为字符的地址并从这个地址中取得这个字符.指针的访问灵活许多,但需要增加一次额外的提取. 如果定义为指针,但以数组方式引用char *p=\"asdf\";c=p[i]: 那么编译器会了解到有个符号p,地址已知,比如1234,那么运行时他的操作为: 取地址1234中的内容,也就是其中存的内容的地址,比如4321, 取i的值并与p中保存的值相加 取地址[4321+i]这个地址的内容 既然把p声明为一个指针,那么不管原先是定义为指针还是数组,都会参照上面的步骤进行操作,但只有当p原来定义为指针时这个方法才是正确的.比如在头文件中申明为char* p,但是实现是char p[10];这种时候p[i]取到的实际是个字符,但编译器却把它当作一个指针,因此就会出错.避免这种错误的方法也就是要声明一致. 数组和指针的其他区别 指针 数组 保存数据的地址 保存数据 间接访问数据,首先取得指针的内容,把它作为地址,然后从这个地址提取数据.如果指针有一个下标,就把指针的内容加上这个下标作为地址,从中提取数据 直接访问数据,a[i]只是简单的以a+i为地址取得数据 通常用于动态数据结构 通常用于存储固定数据且数据类型相同的元素 相关的函数为malloc和free 隐式分配和删除 通常指向匿名数据 自身即为数据名 定义指针是编译器并不为指针所指向的对象分配空间,它只分配指针本身的空间. 特例初始化字符串 在标准C中.初始化指针时所创建的字符串常量被定义为只读,如果试图通过指针修改这个字符串,程序就会出现未定义的行为,字符串常量一般被存放在只读的文本段中以防止被修改. 与指针相反,使用字符串常量初始化数组,那么字符串常量就是可以被修改的 char a[]=\"gooseberry\"; strncpy(a,\"black\",5); 结果数组就会被修改为blackberry. 动态数组 C语言中数组是静态的,一旦编译好了就是固定好了的长度.这就对哪些需要在运行时分配的情况非常不友好,我们只能用一些迂回的方式实现动态数组,具体来说就是使用malloc函数动态分配内存空间的数组. 其原理就是用malloc动态的在堆上开辟空间. #include #include int* createSlice(len,scop){ int *arr; arr = (int*)malloc(sizeof(int)*scop); for (int i = 0; i 0 0 0 0 0 在C99标准中新增了不定长数组(长度为变量),这个数组的长度可以到运行时才决定.申明方式是使用int[*].这样我们就不需要显式的使用malloc来开拓堆上的空间了 #include #include int* createSlice(len,scop){ int arr[scop]; for (int i = 0; i /var/folders/2w/71b83qh117q3sjhm8xgnr7w00000gn/T/tmpo7pt83ze.c:9:12: warning: address of stack memory associated with local variable 'arr' returned [-Wreturn-stack-address] return arr; ^~~ 1 warning generated. 0 0 0 0 0 Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-08 10:24:28 "},"基本语法/字符串和Unicode.html":{"url":"基本语法/字符串和Unicode.html","title":"字符串和Unicode","keywords":"","body":"字符串 C语言中的字符串与Python3中的字符串并不是一回事这需要注意.Python3中的字符串准确的说应该叫Unicode,而C语言中的其实更类似Python2中的str,也就是以ASCII编码的字节串,因此不具备读写非英语的能力;在C中要使用utf-8.后文中我们以字符串代表C中的字符串. 字符串是特殊的数组,可以理解为他是由字符为元素组成的数组,处理方式和数组其实一样.定义字符串一般有这样几种方式: char str1[] = \"asdfg\"; char str2[10] = \"asdfg\"; char str3[10]; strcpy(str3,\"abcd\"); 需要注意的是字符串一旦定义就只能一个元素一个元素的修改内容了,这样很麻烦,因此一般赋值会用string.h中的strcpy函数 UTF-8,UTF-16,UTF-32支持 在C99标准中,我们可以在字符串中使用utf-8字符,用法就是在字符串前加上u8或在字符串中使用utf-8编码的字符串 #include int main(void) { char s1[] = \"a猫?\"; // 或 \"a\\u732B\\U0001F34C\" char s2[] = u8\"a猫?\"; printf(\"%s\\n\",s1); printf(\"%s\\n\",s2); } a猫? a猫? Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-08 10:37:23 "},"输入输出/":{"url":"输入输出/","title":"输入输出","keywords":"","body":"C语言的IO操作 系统的io是指的输入输出,一般来讲有3种io 标准io,指在运行程序所在的命令行中的写入读取. 文件io,指从文件系统中写入读取 网络io,指从网络上写入读取. 标准io一般用于debug,文件io则会更多的用于数据存储,网络io则一般用于通信.通常io都是由系统直接提供的接口,各种语言实际上只是调用这些接口而已.而比较复杂的是网络io接口,网络io由于各个系统并没有统一,C语言的网络io无法简单使用.因此本文只讲前两个. Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-08 12:21:18 "},"输入输出/标准输入输出.html":{"url":"输入输出/标准输入输出.html","title":"标准输入输出","keywords":"","body":"标准输入输出 C语言使用标准库stdio.h控制标准输入输出.其中printf为标准输出,scanf为标准输入.我们其实在之前的例子中已经大量用过. 我们可以使用格式字符串格式化要输出的内容: 在Turbo C中格式字符串的一般形式为： [标志][输出最小宽度][.精度][长度]类型。 其中方括号[]中的项为可选项. 类型 类型字符用以表示输出数据的类型,其格式符和意义如下表所示： 格式字符 意义 d 以十进制形式输出带符号整数(正数不输出符号) o 以八进制形式输出无符号整数(不输出前缀0) x,X 以十六进制形式输出无符号整数(不输出前缀Ox) u 以十进制形式输出无符号整数 f 以小数形式输出单,双精度实数 e,E 以指数形式输出单,双精度实数 g,G 以%f或%e中较短的输出宽度输出单,双精度实数 c 输出单个字符 s 输出字符串 标志 标志字符为-、+、# 和空格四种,其意义下表所示 标志 意义 - 结果左对齐，右边填空格 + 输出符号(正号或负号) 空格 输出值为正时冠以空格,为负时冠以负号 # 对c、s、d、u类无影响;对o类，在输出时加前缀o;对x类，在输出时加前缀0x;对e、g、f类当结果有小数时才给出小数点 输出最小宽度 用十进制整数来表示输出的最少位数.若实际位数多于定义的宽度,则按实际位数输出,若实际位数少于定义的宽度则补以空格或0. 精度 精度格式符以.开头,后跟十进制整数.本项的意义是:如果输出数字,则表示小数的位数;如果输出的是字符,则表示输出字符的个数;若实际位数大于所定义的精度数,则截去超过的部分. 长度 长度格式符为h、l两种,h表示按短整型量输出,l表示按长整型量输出 #include int main(void){ int a=15; double b=123.1234567; char c='p'; printf(\"a=%d\\n\", a); printf(\"a(%%d)=%d, a(%%5d)=%5d, a(%%o)=%o, a(%%x)=%x\\n\\n\",a,a,a,a); printf(\"b=%f\\n\", b); printf(\"b(%%f)=%f, b(%%lf)=%lf, b(%%5.4lf)=%5.4lf, b(%%e)=%e\\n\\n\",b,b,b,b); printf(\"c=%c\\n\", c); printf(\"c(%%c)=%c, c(%%8c)=%8c\\n\",c,c); return 0; } a=15 a(%d)=15, a(%5d)= 15, a(%o)=17, a(%x)=f b=123.123457 b(%f)=123.123457, b(%lf)=123.123457, b(%5.4lf)=123.1235, b(%e)=1.231235e+02 c=p c(%c)=p, c(%8c)= p Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-08 14:27:10 "},"输入输出/文件操作.html":{"url":"输入输出/文件操作.html","title":"文件操作","keywords":"","body":"文件操作 通过重新定向标准输出当然是一种省时省力的方法,但当需要同时按需输出到不同的文件中时,这种方法就很不便利了,像python中可以使用open函数打开一个文件一样,C中也可以使用fopen来做到同样的效果,而且其用法与python中不用with上下文管理器的open用法几乎一样,不同之处只在它的输入输出使用fscanf和fprintf. fopen在stdlib.h中,他的返回值类型为FILE类型,它也需要指定文件的操作权限,可选的和python也差不多,r表示可读,w表示可写 #include #include #include int main(int argc, char *args[]){ char line[80]; if (argc != 7){ fprintf(stderr, \"You need to give 6 arguments\\n\"); return 1; } FILE *in = fopen(args[6], \"r\"); FILE *file1 = fopen(args[2], \"w\"); FILE *file2 = fopen(args[4], \"w\"); FILE *file3 = fopen(args[5], \"w\"); while (fscanf(in, \"%79[^\\n]\\n\", line) == 1) { if (strstr(line, args[1])) fprintf(file1, \"%s\\n\", line); else if (strstr(line, args[3])) fprintf(file2, \"%s\\n\", line); else fprintf(file3, \"%s\\n\", line); } fclose(file1); fclose(file2); fclose(file3); return 0; } Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-08 14:00:58 "},"宏与编译期操作/":{"url":"宏与编译期操作/","title":"宏与编译期操作","keywords":"","body":"宏与编译期操作 C语言有编译期和运行时两个执行时间,编译期是指的在源文件被编译为可执行文件或库文件时编译期执行的事件,运行时指的是可执行文件或库文件被调用时的执行时间.C语言支持简易的宏可以控制一些编译期行为. 使用编译期行为主要的作用有: 简化源码 一些运算在编译期做好了节省运行时消耗 防止源文件被重复引用 方便debug等 Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-08 14:32:35 "},"宏与编译期操作/基本的宏写法.html":{"url":"宏与编译期操作/基本的宏写法.html","title":"基本的宏写法","keywords":"","body":"基本的宏写法 C语言中允许用一个标识符来标识一个字符串,称为宏;标识符为宏名.在编译期程序中所有出现的\"宏名\"都会由宏定义时的字符串去代换,简称宏代换或宏展开.一般形式为#define 宏名 字符串 宏可分为两类--有参数和无参数 无参宏 凡是以#开头的均为预处理命令。“define”为宏定义的命令,标识符为定义的宏名.字符串可以是常量,表达式,格式化字符串等. #define M (x*3+x*5) #include int main(void) { int s = 0; int x = 5; s = 3*M; // 3*(x*3+x*5) printf(\"s = %d\\n\", s); } s = 120 这种宏常用于定义一些常量,比如错误信息,Pi,e这类常数等 有参宏 C语言允许有参宏(即宏带有参数).在宏定义中的参数称之为形式参数,形式参数在编译的时候是不会分配空间的.在宏调用中的参数称之为\"实际参数\".其一般形式为:#define 宏名(形参表) 字符串 有参宏的说明及注意： 有参宏定义中,宏名和形参表之间不能有空格; 在宏定义中的形参是标识符,而宏调用中的实参可以是表达式; 在宏定义中,字符串内的形参通常用括号括起来,以免出错; 宏定义也可以用来定义多个语句. #define SSSV(s1, s2, s3, v) s1=l*w; s2=l*h; s3=w*h; v=l*w*h #include int main() { int l = 3, w = 4, h = 5, sa, sb, sc, vv; SSSV(sa, sb, sc, vv); printf(\"sa = %d\\tsb = %d\\tsc = %d\\tvv = %d\\n\", sa, sb, sc, vv); return 0; } sa = 12 sb = 15 sc = 20 vv = 60 #操作符 宏中只有#是特殊操作符.其用法是: 操作符#:表示字符串化操作符,它把其后的串转换为用双引号包围的串； 操作符##:可以把两个独立的字符串链接成一个字符串. 这个操作符我们常用于通过值找定义的字面量 #include #define Error1 1 #define Error2 2 #define Error3 3 #define Error4 4 #define ENUM_ERROR_CASE(x) case x: return(#x); static inline const char *cvmx_error_to_string(int x) { switch (x) { ENUM_ERROR_CASE(Error1) ENUM_ERROR_CASE(Error2) ENUM_ERROR_CASE(Error3) ENUM_ERROR_CASE(Error4) } return \"Unsupported Error\"; } int main() { printf(\"the result:%s \\n\",cvmx_error_to_string(Error3)); printf(\"the result:%s \\n\",cvmx_error_to_string(2)); return 0; } the result:Error3 the result:Error2 头文件的包含 使用#include申明以\"\"或者<>包围的文件名称可以引入依赖的头文件.其一般形式为#include \"stdio.h\"或者#include . 其区别为: <>:表示在包含文件目录中去查找(包含目录是由用户在设置环境时设置的),而不再源文件的目录下去查找; \"\":表示首先在源文件的目录下查找,若查找到,则会去包含文件目录中查找. 条件编译 多个编译指令允许程序员有选择的编译程序源代码的不同部分,这种过程称为条件编译. #if、#else、#elif、#endif 就像正常编程语言一样,宏中的条件语句如下: #if constant Statement sequence #elif constant1 Statement sequence #elif constant2 Statement sequence #else Statement sequence #endif #ifdef和#ifndef 这个一般用于防止同名宏在不同文件间造成歧义. 用法如下: #ifdef 标识符 程序段1 #else 程序段2 #endif 或者 #ifndef 标识符 程序段1 #else 程序段2 #endif 预设的宏 C语言中有一些预设的宏,他们一般以__开头,有特殊作用: __LINE__:在源代码中插入当前源代码行号; __FILE__:在源文件中插入当前源文件名; __DATE__:在源文件中插入当前的编译日期; __TIME__:在源文件中插入当前编译时间; 这些宏一般用于debug Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-08 15:02:52 "},"宏与编译期操作/基础泛型机制.html":{"url":"宏与编译期操作/基础泛型机制.html","title":"基础泛型机制","keywords":"","body":"基础泛型机制 我一直以为C会一直没有泛型,结果在C11标准中加入了宏_Generic,我们可以使用简单的泛型了!先来一个演示 #define get_type(expr) _Generic((expr), int: \"int\",char: \"char\", double: \"double\") #include int main(void){ printf(\"Type of 234: %s\\n\", get_type(234)); printf(\"Type of 'A': %s\\n\", get_type('A')); printf(\"Type of (char)'A': %s\\n\", get_type((char)'A')); printf(\"Type of 3.14: %s\\n\", get_type(3.14)); } Type of 234: int Type of 'A': int Type of (char)'A': char Type of 3.14: double _Generic的用法是_Generic ( assignment-expression , generic-assoc-list ). assignment-expression,用于判断表达式类型 generic-assoc-list用于根据表达式类型来执行不同的操作,一个稍微复杂的操作 #define generic_add(x,y) _Generic( x,int: _Generic(y,\\ int: x+y,\\ double:(double)x+y,\\ default:0),\\ double: _Generic(y,\\ int: x+(double)y,\\ double:x+y,\\ default:0),\\ default:0) #include int main(void){ printf(\"int add: %d\", generic_add(1,2)); printf(\"int add: %f\", generic_add(1.2,2)); } int add: 3int add: 3.200000 这个例子我们演示了如果泛型函数有两个参数该如何写,没错就只能嵌套着写了,我们必须一个参数一个参数的判断类型,之后再写执行逻辑.C语言的泛型编程现在还相当初级,不过既然有了,我想完善也是迟早的事儿. Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-08 14:32:54 "},"异常处理.html":{"url":"异常处理.html","title":"异常处理","keywords":"","body":"异常处理 程序中的错误分为3种: 用户错误 预期会发生的错误,用户的特定操作就会导致特定的错误,比如注册邮箱时填入的内容没有\"@\"这种.这种错误通常应该是程序主体就要处理的.通过返回特定的错误码进行提示. 运行时错误 运行时错误从来都是非预期的,表明程序出了bug,程序必须要结束.通常需要使用断言来捕获这种错误 异常 介于洪湖错误和程序bug之间,异常可能是比较罕见的错误,比如算数运算时候的溢出情况.通常异常不返回错误码,而是由恢复代码处理,类似于非局部的goto. C语言没有异常,更不要提异常处理了,一般来说是通过自己规定的返回码来标识异常的.通常使用标准库errno.h配合标准库string.h中的函数strerror和标准库stdio.h中的perror用于打印异常信息. errno.h是C标准库中的一个检查错误的头文件,它的内部有一个全局变量errno.它可以被赋值,而C库中的每个模块都会包含这个errno.h头文件,那么errno这个可以被赋值的宏,就相当于整个C标准库的全局变量,如果在使用某个模块的函数过程中发生了错误,这个errno宏就会在函数内部被赋予一个有含义的值,相当于一个错误代码,并且无论库的哪个模块或库函数都不会把errno设置为零.所以我们在使用这个模块的时候只需要在一个库函数调用前将errno设置为零,然后在调用之后检查errno的值即可知道这个被调用的库函数有没有发生错误.关于errno.h的使用技巧可以这篇文章 一个简单的例子如下: #include #include #include int main() { errno=0; FILE *fp = fopen(\"test.txt\",\"r\"); if(errno!=0) { printf(\"errno值： %d\\n\",errno); printf(\"错误信息： %s\\n\",strerror(errno)); perror(strerror(errno)); } } errno值： 2 错误信息： No such file or directory No such file or directory: No such file or directory 比较常见的ERROR定义如下: #define EPERM 1 /* Operation not permitted */ #define ENOENT 2 /* No such file or directory */ #define ESRCH 3 /* No such process */ #define EINTR 4 /* Interrupted system call */ #define EIO 5 /* I/O error */ #define ENXIO 6 /* No such device or address */ #define E2BIG 7 /* Argument list too long */ #define ENOEXEC 8 /* Exec format error */ #define EBADF 9 /* Bad file number */ #define ECHILD 10 /* No child processes */ #define EAGAIN 11 /* Try again */ #define ENOMEM 12 /* Out of memory */ #define EACCES 13 /* Permission denied */ #define EFAULT 14 /* Bad address */ #define ENOTBLK 15 /* Block device required */ #define EBUSY 16 /* Device or resource busy */ #define EEXIST 17 /* File exists */ #define EXDEV 18 /* Cross-device link */ #define ENODEV 19 /* No such device */ #define ENOTDIR 20 /* Not a directory */ #define EISDIR 21 /* Is a directory */ #define EINVAL 22 /* Invalid argument */ #define ENFILE 23 /* File table overflow */ #define EMFILE 24 /* Too many open files */ #define ENOTTY 25 /* Not a typewriter */ #define ETXTBSY 26 /* Text file busy */ #define EFBIG 27 /* File too large */ #define ENOSPC 28 /* No space left on device */ #define ESPIPE 29 /* Illegal seek */ #define EROFS 30 /* Read-only file system */ #define EMLINK 31 /* Too many links */ #define EPIPE 32 /* Broken pipe */ #define EDOM 33 /* Math argument out of domain of func */ #define ERANGE 34 /* Math result not representable */ C语言中也往往用这种方式自定义模块的宏,自定义一个模块级的全局变量并结合一个错误枚举以及从枚举值转换为字面量的函数.就可以实现上面的错误处理方式了. 明显的这种方式在处理异常时是不会终止程序的,如果需要终止程序,我们就得使用标准库stdlib.h的abort()方法 #include #include #include #include int main() { errno=0; FILE *fp = fopen(\"test.txt\",\"r\"); if(errno!=0){ printf(\"errno值： %d\\n\",errno); printf(\"错误信息： %s\\n\",strerror(errno)); perror(strerror(errno)); abort(); } for(int i=0;i No such file or directory: No such file or directory errno值： 2 错误信息： No such file or directory [C kernel] Executable exited with code -6 断言 C语言标准库有头文件assert.h将assert(e)定义为宏,assert(e)会计算表达式e的值,如果e为0则向标准错误stderr写出诊断信息,并调用标准库函数abort退出程序执行.诊断信息包含失败的断言文本和断言出现的坐标,该信息的格式是具体实现定义的.assert(0)可以用户指明\"不可能发生\"的情况,当然如下也对: #include #include #include #include int main() { assert(!\"ptr==NULL -- can't happen\"); } Assertion failed: (!\"ptr==NULL -- can't happen\"), function main, file /var/folders/2w/71b83qh117q3sjhm8xgnr7w00000gn/T/tmp11prdxto.c, line 7. [C kernel] Executable exited with code -6 另一种方案 另一种方案在\"C语言接口与实现\"一书中有提到--使用标准库提供了setjmp和longjmp建立结构化异常处理,具体来说,setjmp实例化一个处理程序,longjmp引发一个异常 try-except代码块 try-except代码块在现代编程语言中几乎是标配,在实践中也被证明非常有用.然而C中没有.\"C语言接口与实现\"一书中有一个使用宏的实现,接下来会写一个库专门用于实现try-except代码块.不过有几个受限的使用形式: TRY-END_TRY 相当于{xxx}语句不变只是引入一个新的作用域 TRY-ELSE-END_TRY 相当于python中的try-except Exception,只要有异常就处理,不管是啥异常 TRY-EXCEPT-...-END_TRY 相当于python中的try-except E_1-except E_2-... TRY-EXCEPT-...-ELSE-END_TRY 注意这与python中不同,相当于python中的try-except E_1-...- except Exception TRY-EXCEPT-FINALLY-END_TRY 相当于python中的try-except E_1-finally无论是否有异常都会执行FINALLY,这个用法可以像python中的with语句一样提供一个上下文. TRY-EXCEPT-ELSE-FINALLY-END_TRY 相当于python中的try-except E_1-except Exception-finally无论是否有异常都会执行FINALLY,这个用法可以像python中的with语句一样提供一个上下文. 如果TRY语句中需要执行返回,那么必须使用宏RETURN返回. \"C语言接口与实现\"一书中提供的这组宏显然还是比较粗糙而且脆弱的,宏毕竟不会检查运行时错误,但一般用用足够.C语言中并不提倡大量使用异常,设计算法的时候这组宏也应当被谨慎的使用. 这个模块在代码中有收录,它与下面的断言收录在一起. C语言接口与实现中的断言 \"C语言接口与实现\"一书中提供了一个标准库\"assert.h\"的替代,用它的好处是如果断言失败不会向stderr打印消息,也不会跳出程序,也不会提供表达式e的文本,而是抛出上文中定义的Assert_Failed异常. Copyright © hsz 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-05 03:49:41 "}}